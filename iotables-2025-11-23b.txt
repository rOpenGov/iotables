#' Get air pollutant data (Eurostat env_ac_ainah_r2)
#'
#' @description Retrieves Air Emissions Accounts (env_ac_ainah_r2)
#' by NACE Rev. 2 activity for
#' environmental impact assessments.
#' Automatically manages Eurostat caching via
#' `tempdir()` or a user-specified `data_directory`.
#'
#' @details The Eurostat dataset *Air emissions accounts by NACE Rev. 2
#' activity* (`env_ac_ainah_r2`) contains emissions of major pollutants,
#' including: CO2, biomass CO2, N2O, CH4, PFCs, HFCs, SF6, NOx, NMVOC, CO, PM10,
#' PM2.5, SO2, and NH3. See Eurostat metadata for definitions of aggregated
#' indicators (GHG, ACG, O3PR, etc.).
#'
#' @note The function adjusts the invalid industry codes, like
#' `C10-C12` to `C10-12`.
#'
#' @inheritParams iotables_download
#' @param airpol Pollutant code (e.g. `"GHG"`, `"CO2"`, `"CH4"`,
#' `"NOX"`, `"NH3"`, etc.).
#' @param geo Country code (e.g. `"BE"`, `"DE"`). The special value
#'   `"germany_1995"` returns the built-in example dataset
#'    [germany_airpol].
#' @param year Reference year (≥ 2008 for NACE Rev. 2).
#' @param unit Unit of measure (default `"THS_T"` = thousand tonnes).
#'
#' @return A tidy data frame with air pollutant emissions aligned to IO
#' classifications.
#'
#' @source Eurostat dataset:
#'   [env_ac_ainah_r2](https://ec.europa.eu/eurostat/web/products-datasets/-/env_ac_ainah_r2)
#' @importFrom dplyr everything filter select relocate case_when
#' @importFrom dplyr group_by summarise
#' @importFrom tidyr pivot_wider
#' @importFrom assertthat assert_that
#' @export
airpol_get <- function(airpol = "GHG",
                       geo = "BE",
                       year = 2020,
                       unit = "THS_T",
                       data_directory = NULL,
                       force_download = FALSE) {
  # --- Handle built-in dataset -------------------------------------------
  if (geo == "germany_1995") {
    airpol_input <- airpol
    return_df <- getdata("germany_airpol") %>%
      dplyr::filter(airpol %in% airpol_input) %>%
      dplyr::select(iotables_col, value) %>%
      tidyr::pivot_wider(
        names_from = iotables_col,
        values_from = value
      ) %>%
      dplyr::mutate(indicator = paste0(airpol_input, "_emission")) %>%
      dplyr::relocate(indicator,
        .before = dplyr::everything()
      )
    return(return_df)
  }

  # --- Define and prepare cache directory -------------------------------
  cache_dir <- if (!is.null(data_directory)) {
    data_directory
  } else {
    file.path(tempdir(), "eurostat")
  }
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)

  cache_file <- file.path(cache_dir, "env_ac_ainah_r2_processed.rds")

  # --- Retrieve data ----------------------------------------------------
  if (!force_download && file.exists(cache_file)) {
    message("Reading cached Eurostat air pollutant data from: ", cache_file)
    tmp <- tryCatch(readRDS(cache_file), error = function(e) NULL)
  }

  if (!is.null(geo) || is.null(unit) || is.null(year)) {
    filters_list <- list(geo = geo, unit = unit, time = year, airpol = airpol)
    tmp <- get_eurostat_data(
      id = "env_ac_ainah_r2",
      filters = filters_list
    )
  } else {
    message("Downloading Eurostat dataset env_ac_ainah_r2 (force_download=", force_download, ")")
    tmp <- tryCatch(
      eurostat::get_eurostat("env_ac_ainah_r2",
        cache = !force_download,
        cache_dir = cache_dir
      ),
      error = function(e) {
        stop("Eurostat download failed: ", conditionMessage(e), call. = FALSE)
      }
    )
    saveRDS(tmp, cache_file, version = 2)
    message("Saved processed dataset to ", cache_file)
  }

  # --- Basic format check ----------------------------------------------
  assertthat::assert_that(
    is.data.frame(tmp),
    msg = "Eurostat air pollutant dataset not loaded properly."
  )

  # --- Harmonize time column name --------------------------------------
  tmp <- dplyr::rename(tmp, time = dplyr::any_of("TIME_PERIOD"))

  # --- Filter by pollutant ---------------------------------------------
  assertthat::assert_that(
    airpol %in% tmp$airpol,
    msg = glue::glue(
      "{airpol} is not recognized as a valid pollutant in env_ac_ainah_r2."
    )
  )
  airpol_df <- dplyr::filter(tmp, airpol == !!airpol)

  # --- Filter by country -----------------------------------------------
  assertthat::assert_that(
    geo %in% airpol_df$geo,
    msg = glue::glue(
      "No data for geo='{geo}' in env_ac_ainah_r2."
    )
  )

  airpol_df <- dplyr::filter(airpol_df, geo == !!geo)

  # --- Filter by year --------------------------------------------------
  assertthat::assert_that(
    as.Date(paste0(year, "-01-01")) %in% airpol_df$time,
    msg = glue::glue(
      "No data for year={year} with geo='{geo}' in env_ac_ainah_r2."
    )
  )
  airpol_df <- dplyr::filter(
    airpol_df,
    time == as.Date(paste0(year, "-01-01"))
  )

  # --- Filter by unit --------------------------------------------------
  assertthat::assert_that(
    unit %in% airpol_df$unit,
    msg = glue::glue(
      "No data for unit='{unit}' for geo='{geo}' and airpol='{airpol}'."
    )
  )
  airpol_df <- dplyr::filter(airpol_df, unit == !!unit)

  # --- Harmonize NACE structure ---------------------------------------

  country_ghg <- airpol_df %>%
    dplyr::mutate(nace_r2 = dplyr::case_when(
      nace_r2 == "C10-C12" ~ "C10-12",
      nace_r2 == "C13-C15" ~ "C13-15",
      nace_r2 == "C31_C32" ~ "C31_32",
      nace_r2 == "E37-E39" ~ "E37-39",
      nace_r2 == "J59_J60" ~ "J59_60",
      nace_r2 == "J62_J63" ~ "J62_63",
      nace_r2 == "M69_M70" ~ "M69_70",
      nace_r2 == "M74_M75" ~ "M74_75",
      nace_r2 == "N80-N82" ~ "N80-82",
      nace_r2 == "Q87_Q88" ~ "Q87_88",
      nace_r2 == "R90-R92" ~ "R90-92",
      TRUE ~ nace_r2
    ))

  group_match <- country_ghg %>%
    dplyr::rename(nace = nace_r2) %>%
    dplyr::mutate(nace_r2 = substr(nace, 1, 1)) %>%
    dplyr::group_by(airpol, unit, geo, time, nace_r2) %>%
    dplyr::summarise(values = sum(values), .groups = "keep") %>%
    dplyr::anti_join(country_ghg, by = "nace_r2") %>%
    dplyr::mutate(freq = "A")

  return_df <- dplyr::bind_rows(
    country_ghg,
    group_match
  )

  if ("rowid" %in% names(return_df)) {
    return_df <- dplyr::select(return_df, -rowid)
  }

  return_df <- return_df %>%
    tidyr::pivot_wider(
      names_from = nace_r2,
      values_from = values
    ) %>%
    ensure_l68_columns(c("L68A", "L68B")) %>%
    dplyr::relocate(L68A, .after = "L") %>%
    dplyr::relocate(L68B, .after = "L68A") %>%
    dplyr::relocate(TOTAL, .after = "U") %>%
    dplyr::relocate(U, .before = "TOTAL") %>%
    dplyr::mutate(prod_na = paste0(airpol, "_emission")) %>%
    dplyr::relocate(prod_na, .before = dplyr::everything()) %>%
    select(-geo, -freq, -time, -airpol, -unit, -year)

  attr(return_df, "geo") <- geo
  attr(return_df, "year") <- year
  attr(return_df, "unit") <- unit
  attr(return_df, "freq") <- "A"
  return_df
}
#' Backward Linkages
#'
#' Compute the backward linkages of each industry or product sector from a
#' Leontief inverse matrix. Backward linkages indicate how strongly a sector is
#' interconnected on the demand side: when a sector increases its output, it
#' will increase intermediate demand on all other sectors.
#'
#' @details Backward linkages are defined as the column sums of the Leontief
#'   inverse, in line with the *Eurostat Manual of Supply, Use and Input–Output
#'   Tables* (pp. 506–507) and the *United Nations Handbook on Supply and Use
#'   Tables and Input–Output Tables with Extensions and Applications* (p. 636).
#'
#' @param Im A Leontief inverse matrix created by [leontief_inverse_create()].
#'
#' @return A one-row `data.frame` containing the backward linkage values for
#'   each column (industry or product) of the Leontief inverse. The first column
#'   is the sector key column, and the remaining columns correspond to the
#'   linkage values.
#'
#' @family linkage functions
#'
#' @examples
#' de_coeff <- input_coefficient_matrix_create(iotable_get(), digits = 4)
#' I <- leontief_inverse_create(de_coeff)
#' backward_linkages(I)
#'
#' # Trivial example: identity matrix gives linkages = 1
#' I <- diag(3)
#' colnames(I) <- rownames(I) <- c("A", "B", "C")
#' I_df <- data.frame(sector = rownames(I), I, check.names = FALSE)
#' backward_linkages(I_df)
#'
#' @importFrom dplyr mutate across
#' @importFrom tidyselect where
#' @export
backward_linkages <- function(Im) {
  Im <- dplyr::mutate(Im, dplyr::across(
    where(is.factor),
    function(x) as.character(x)
  ))

  total_row <- data.frame(
    name = "backward linkages"
  )

  names(total_row)[1] <- names(Im[1])

  total_row <- cbind(
    total_row,
    t(colSums(Im[, 2:ncol(Im)]))
  )

  total_row
}
#' @title Check digits parameter
#' @description This is an internal function to determine if the rounding can go
#'   ahead.
#' @param digits Digit input to check for validity.
#' @return An error if the digits are not \code{NULL} or an integer value.
#' @keywords internal
check_digits <- function(digits) {
  if (!is.null(digits)) {
    if (!inherits(digits, "numeric")) {
      stop(
        paste(
          "Error in check_digits(digits):",
          "rounding 'digits' must be numeric or NULL."
        )
      )
    }
  }
  invisible(TRUE)
}
#' @title Create an input (technical) coefficient matrix
#'
#' @description
#' Computes the **input (technical) coefficient matrix** from a symmetric
#' input–output table (SIOT), use table, or supply table. Each element
#' represents the amount of a product used as input per unit of output
#' (usually at basic prices).
#'
#' @details
#' The coefficient matrix \eqn{A}—also called the *technological* or
#' *direct requirements* matrix—is obtained by dividing each element of
#' the inter-industry (intermediate use) block \eqn{Z} by the corresponding
#' column total of output \eqn{x}:
#'
#' \deqn{A_{ij} = Z_{ij} / x_j}
#'
#' where \eqn{Z_{ij}} denotes the use of product *i* by industry (or product)
#' *j*, and \eqn{x_j} is total output at basic prices.
#'
#' This formulation follows the *Eurostat Manual of Supply, Use and
#' Input–Output Tables* (Beutel, 2008, §15.1–15.3) and the *System of
#' National Accounts 2008* (§14.90–14.91).
#'
#' By default, the denominator row is `"output"` (equivalent to ESA 2010
#' transaction `"P1"` or `"output_bp"`). Alternative totals such as
#' `"total"` or `"cpa_total"` may be used through the `total` argument.
#'
#' @param data_table A symmetric input–output table, use table, margins or
#'   tax table retrieved by [iotable_get()].
#' @param total Character. Label of the row used as denominator.
#'   Defaults to `"output"`. Accepts `"P1"`, `"output_bp"`, `"total"`,
#'   or `"cpa_total"`.
#' @param digits Optional integer. Number of digits for rounding.
#'   Default `NULL` (no rounding).
#' @param return_part Optional. `"products"`, `"industries"`, or
#'   `"primary_inputs"` to select part of the matrix. Default `NULL`
#'   returns the full matrix.
#' @param remove_empty Logical. Should empty rows be removed?
#'   Defaults to `TRUE`.
#' @param households Logical. If `TRUE`, include the household column.
#'   Default `FALSE`.
#' @param ... Reserved for future extensions.
#'
#' @return
#' A `data.frame` containing:
#' - the key (row label) column from `data_table`
#' - numeric columns with input (technical) coefficients
#'
#' @references
#' Beutel, J. (2008). *Eurostat Manual of Supply, Use and Input–Output
#' Tables*. Luxembourg: Publications Office of the European Union, ch. 15.
#' United Nations et al. (2009). *System of National Accounts 2008*,
#' §§14.90–14.91.
#'
#' @family indicator functions
#'
#' @examples
#' cm <- coefficient_matrix_create(
#'   data_table = iotable_get(source = "germany_1995"),
#'   total = "output",
#'   digits = 4
#' )
#' head(cm)
#'
#' @export
coefficient_matrix_create <- function(
    data_table,
    total = "output",
    digits = NULL,
    remove_empty = TRUE,
    households = FALSE,
    return_part = NULL,
    ...) {
  data_table <- data_table %>%
    dplyr::mutate(dplyr::across(where(is.factor), as.character))

  if (remove_empty) data_table <- empty_remove(data_table)

  last_column <- quadrant_separator_find(data_table, include_total = FALSE)

  if (!is.null(households) && households) {
    household_column <- household_column_get(data_table)
    quadrant <- data_table[, 1:last_column]
    data_table <- dplyr::left_join(quadrant, household_column,
      by = names(quadrant)[1]
    )
    last_column <- last_column + 1
  } else {
    data_table <- data_table[, 1:last_column]
  }

  key_column <- tolower(as.character(unlist(data_table[, 1])))

  # find denominator row
  if (total %in% c("output", "p1", "output_bp")) {
    total_row <- data_table[which(key_column %in%
      c("output", "p1", "output_bp", "total output"))[1], ]
    if (nrow(total_row) == 0) stop("Output row not found.")
  } else if (total %in% c("total", "cpa_total")) {
    total_row <- data_table[which(key_column %in% c("total", "cpa_total"))[1], ]
  } else {
    total_row <- data_table[which(tolower(key_column) %in% tolower(total)[1]), ]
    if (nrow(total_row) == 0) stop("Requested total row not found.")
  }

  # avoid division by zero
  null_to_eps <- function(x) ifelse(x == 0, 1e-6, x)
  total_row <- dplyr::mutate(
    total_row,
    dplyr::across(where(is.numeric), null_to_eps)
  )

  coeff_matrix <- data_table %>%
    dplyr::mutate(dplyr::across(where(is.numeric), as.numeric))

  for (i in seq_len(nrow(data_table))) {
    coeff_matrix[i, 2:last_column] <-
      coeff_matrix[i, 2:last_column] / as.numeric(total_row[2:last_column])
  }

  # return_part filter
  if (!is.null(return_part)) {
    last_row <- which(tolower(unlist(data_table[, 1])) %in%
      c("cpa_total", "total", "total output"))
    if (return_part == "primary_inputs") {
      coeff_matrix <- coeff_matrix[last_row:nrow(coeff_matrix), ]
    } else if (return_part %in% c("products", "industries")) {
      coeff_matrix <- coeff_matrix[1:last_row, ]
    }
  }

  if (is.null(digits)) coeff_matrix else round_table(coeff_matrix, digits)
}
#' Create an Empty Conforming Vector
#'
#' Create a named vector (in wide format) that conforms to the structure of a
#' given analytical object, such as a use table, coefficient matrix, or
#' Leontief matrix. This helps avoid mistakes when manually defining large
#' vectors (e.g., for 60 × 60 matrices).
#'
#' The empty conforming vector can also be exported to `.csv` format and used
#' as a template for importing scenarios from a spreadsheet application.
#'
#' @param data_table A use table, coefficient matrix, Leontief matrix, or other
#'   named matrix or data frame.
#'
#' @return A one-row `data.frame` with the same column names as `data_table`,
#'   but with all values set to zero.
#'
#' @family iotables processing functions
#'
#' @examples
#' de_input_flow <- input_flow_get(data_table = iotable_get())
#' conforming_vector_create(de_input_flow)
#'
#' @export
conforming_vector_create <- function(data_table) {
  conforming_vector <- data_table[1, , drop = FALSE]
  conforming_vector[] <- 0
  conforming_vector
}
#' Convert industry columns to product columns
#'
#' A utility function to adjust column names for supplementary data,
#' for example, air pollution data, where the industry codes are denoted
#' with `ind_ava` or `ind_use` (or similar codes).
#'
#' For example, `A01` (agriculture) is converted to `CPA_A01` (product
#' of agriculture).
#'
#' This corresponds to the bridge matrix (B) defined in Eurostat
#' Manual §15.4.2,  used to transform industry-based extensions to
#' product-based form.
#'
#' @param data_table A table where the names of the columns are denoted
#' with the `ind_ava` or `ind_use` or `ind_use` vocabularies, for
#' example, agriculture is denoted with `A01`.
#'
#' @returns A converted, named vector or table where the columns are
#' denoted with `prd_ava` codes, i.e., `A01` is converted to `CPA_A01`.
#' @export
#'
#' @seealso [supplementary_add()]
#' @importFrom dplyr rename select bind_cols
#'
#' @examples
#' data_table <- data.frame(
#'   ind_use = "A01",
#'   A01 = 1, A02 = 3, TOTAL = 4,
#'   HH = 2
#' )
#' convert_industry_to_product(data_table)
convert_industry_to_product <- function(data_table) {
  ind_ava <- getdata("ind_ava")
  intermediate <- filter(ind_ava, block == "intermediate")

  intermed_cols <- data_table[, which(names(data_table)
  %in% intermediate$id)]

  other_col_n <- which(!names(data_table) %in% names(intermed_cols))

  other_cols <- dplyr::select(data_table, all_of(other_col_n))
  names(intermed_cols) <- paste0("CPA_", names(intermed_cols))

  first_col <- other_cols %>% select(1)
  first_col_name <- names(first_col)

  return_df <- bind_cols(first_col, intermed_cols) %>%
    dplyr::rename(TOTAL = CPA_TOTAL)
  if (ncol(other_cols) > 1) {
    dplyr::bind_cols(return_df, other_cols %>% select(-any_of(first_col_name)))
  } else {
    return_df
  }
}
#' @title Create an output-independent, formatted kable table
#'
#' @description Wrapper around [knitr::kable()] with sensible defaults
#' for alignment, borders, and formatting, compatible with HTML and LaTeX
#' output formats.
#'
#' @param data_table A `data.frame`, tibble, named matrix, or `knitr_kable` object.
#' @param caption Optional table caption. Defaults to `NA` (no caption).
#' @param digits Number of digits to display for numeric variables.
#'   Defaults to `getOption("digits")`.
#' @param col.names Column names for the table. If `NULL`, uses
#'   `names(data_table)`.
#' @param width_unit Character. Unit for column widths (default `"cm"`).
#' @param col_width Numeric vector of column widths. If `NULL`, defaults to
#'   2 for the first column and equal share for the rest.
#' @param col_align Column alignment. Defaults to `"l"` for the first column,
#'   `"c"` for others.
#' @param border_right_cols Logical vector for right-hand column borders.
#'   Defaults to `TRUE` for the first column, `FALSE` otherwise.
#' @param bold_cols Logical vector. If `TRUE`, makes the column bold.
#'   Defaults to all `FALSE`.
#' @param bootstrap_options Passed to [kableExtra::kable_styling()] for
#'   HTML output. Defaults to `c("striped", "hover", "condensed")`.
#' @param latex_options Passed to [kableExtra::kable_styling()] for
#'   LaTeX output. Defaults to `c("scale_down", "striped")`.
#' @param output_format Character: `"html"`, `"latex"`, or `"image"`.
#'   If `NULL`, auto-detects from knitr options.
#' @param keep_pdf Logical. Only relevant for `output_format = "image"`.
#'   Defaults to `FALSE`.
#' @param latex_header_includes Character vector of LaTeX headers to include.
#'   Defaults to `c("\\usepackage[magyar]{babel}", "\\usepackage[utf8]{inputenc}")`.
#'
#' @return A `knitr_kable` object with styling applied.
#' @importFrom knitr kable is_latex_output is_html_output
#' @importFrom kableExtra kable_styling column_spec
#' @keywords internal
create_knitr_table <- function(data_table,
                               digits = NULL,
                               caption = NA,
                               col.names = NULL,
                               col_width = NULL,
                               width_unit = "cm",
                               col_align = NULL,
                               border_right_cols = NULL,
                               bold_cols = NULL,
                               bootstrap_options = c("striped", "hover", "condensed"),
                               latex_options = NULL,
                               output_format = NULL,
                               keep_pdf = FALSE,
                               latex_header_includes = c(
                                 "\\usepackage[magyar]{babel}",
                                 "\\usepackage[utf8]{inputenc}"
                               )) {
  if (is.null(ncol(data_table))) {
    stop("Empty data table inputted.")
  }

  # Auto-detect output format if not set
  if (is_latex_output()) {
    output_format <- "latex"
  } else if (is_html_output()) {
    output_format <- "html"
  }
  if (is.null(output_format) || !output_format %in% c("latex", "html")) {
    output_format <- "image"
  }

  if (!inherits(data_table, "knitr_kable")) {
    # Column names
    if (is.null(col.names)) col.names <- names(data_table)

    # Alignment defaults
    if (is.null(col_align)) col_align <- c("l", rep("c", ncol(data_table) - 1))

    # Borders
    if (is.null(border_right_cols)) {
      border_right_cols <- c(TRUE, rep(FALSE, ncol(data_table) - 1))
    }

    # Boldness
    if (is.null(bold_cols)) bold_cols <- rep(FALSE, ncol(data_table))

    # Column widths
    if (is.null(col_width)) {
      col_width <- c(2, 18 / (ncol(data_table) - 1))
    }
    col_width <- paste0(col_width, width_unit)

    # Digits
    if (is.null(digits) || digits < 0) digits <- getOption("digits")

    # Table format
    table_format <- if (output_format == "image") "latex" else output_format

    knitr_table <- knitr::kable(
      data_table,
      digits = digits,
      format = table_format,
      format.args = list(big.mark = " ", decimal.mark = ","),
      caption = caption,
      booktabs = TRUE,
      col.names = col.names,
      align = col_align
    )
  }

  # Apply styling
  if (table_format == "html") {
    if (is.null(bootstrap_options)) {
      bootstrap_options <- c("striped", "hover", "condensed")
    }
    knitr_table <- kableExtra::kable_styling(
      kable_input = knitr_table,
      bootstrap_options = bootstrap_options
    )
  }

  if (table_format %in% c("latex", "image")) {
    if (is.null(latex_options)) {
      latex_options <- c("scale_down", "striped")
    }
    knitr_table <- kableExtra::kable_styling(
      kable_input = knitr_table,
      latex_options = latex_options
    )
  }

  # Column-specific formatting
  for (i in seq_len(ncol(data_table))) {
    knitr_table <- kableExtra::column_spec(
      kable_input = knitr_table,
      column = i,
      width = col_width[i],
      bold = bold_cols[i],
      border_right = border_right_cols[i]
    )
  }

  knitr_table
}
#' Eurostat Product Classification (CPA 2.1 — Summary and Aggregate Levels)
#'
#' A reference vocabulary derived from Eurostat’s **CPA 2.1 — Statistical Classification
#' of Products by Activity**, restricted to high-level (summary) items, extensions, and
#' 0-, 1-, and 2-digit product aggregates.
#'
#' This vocabulary provides the **product-side** codes used in Eurostat’s
#' **supply–use** and **input–output** frameworks, consistent with NACE Rev. 2 activity
#' groupings. It is used by the [iotables] package to order and label the **product × product**
#' blocks of symmetric input–output tables (SIOTs) and their supply–use counterparts.
#'
#' @details
#' The `cpa2_1` vocabulary was obtained from the official Eurostat SKOS registry
#' (<https://dd.eionet.europa.eu/vocabulary/eurostat/cpa2_1/>, filter: `conceptStatusInt = 128`,
#' i.e. active concepts).
#'
#' From the full CPA 2.1 hierarchy, this dataset retains:
#'
#' * **0-digit** sections (e.g. `"CPA_L"`, `"CPA_O"`),
#' * **1-digit** aggregates,
#' * **2-digit** divisions, and
#' * published **summary** and **extension** items.
#'
#' These levels correspond to the structure of Eurostat’s aggregated supply–use tables and
#' are suitable for analytical applications such as cultural, tourism, or environmental
#' satellite accounts.
#'
#' All entries are marked with status `"valid"`, reflecting their current publication state
#' in the Eurostat metadata repository.
#'
#' @format A tibble (data frame) with 10 variables:
#' \describe{
#'   \item{id}{Canonical Eurostat concept identifier (SKOS URI fragment).}
#'   \item{label}{Official English label from the Eurostat CPA 2.1 vocabulary.}
#'   \item{status}{Concept validity flag (`"valid"` for all entries).}
#'   \item{status_modified}{Date of the most recent status update.}
#'   \item{notation}{Official CPA 2.1 notation (e.g. `"CPA_A01"`, `"CPA_C10"`).}
#'   \item{quadrant}{Integer flag used internally in \pkg{iotables} to identify the analytical
#'     block (`10` = intermediate, `20` = value added, `30` = control totals).}
#'   \item{numeric_order}{Ordinal position key ensuring correct row sequencing in
#'     reshaped input–output matrices.}
#'   \item{iotables_label}{Simplified legacy label used internally by the [iotables] package.}
#'   \item{block}{Semantic block category inferred from `quadrant`
#'     (`intermediate`, `primary_inputs`, `control_total`, `extension`).}
#'   \item{uri}{Stable URI for the SKOS concept at
#'     <https://dd.eionet.europa.eu/vocabulary/eurostat/cpa2_1/>.}
#' }
#'
#' @source
#' Eurostat metadata registry (DD EIONET vocabulary:
#' <https://dd.eionet.europa.eu/vocabulary/eurostat/cpa2_1/>)
#'
#' @seealso
#' Other Eurostat vocabularies included in the package:
#' [ind_use], [ind_ava], [prd_use], [prd_ava].
#'
#' @keywords datasets metadata Eurostat CPA products SUT SIOT
#'
#' @examples
#' data(cpa2_1)
"cpa2_1"
#' @title Input-output table for Croatia, 2010
#'
#' @description
#' Symmetric input-output table at basic prices (product × product).
#' Original code: **1700**.
#' Values are expressed in thousand kunas (`T_NAC`).
#'
#' @source
#' [Državni zavod za statistiku](https://dzs.gov.hr/)
#'
#' @format A data frame with 13 variables:
#' \describe{
#'   \item{t_rows2}{Technology codes in row names, following Eurostat
#'     conventions.}
#'   \item{t_rows2_lab}{Longer labels for `t_rows2`.}
#'   \item{t_cols2}{Technology codes in column names, following Eurostat
#'     conventions.}
#'   \item{t_cols2_lab}{Longer labels for `t_cols2`.}
#'   \item{iotables_col}{Standardized column labels for easier reading.}
#'   \item{col_order}{Ordering index to keep the matrix legible.}
#'   \item{row_order}{Ordering index to keep the matrix legible.}
#'   \item{iotables_row}{Standardized row labels for easier reading.}
#'   \item{unit}{Unit of measure. Here: thousand national currency units
#'     (kunas).}
#'   \item{geo}{ISO/Eurostat country code for Croatia.}
#'   \item{geo_lab}{ISO/Eurostat country name, "Croatia".}
#'   \item{time}{Date of the SIOT.}
#'   \item{values}{Observed values in thousand kunas.}
#' }
#'
#' @family Croatia 2010 datasets
"croatia_2010_1700"
#' @title Input-output table for Croatia, 2010 (domestic production)
#'
#' @description
#' Symmetric input-output table (SIOT) for domestic production (product ×
#' product), code **1800**.
#'
#' Values are expressed in thousand kunas (T_NAC).
#'
#' @format A data frame with 13 variables:
#' \describe{
#'   \item{t_rows2}{Technology codes in row names, following Eurostat
#'     conventions.}
#'   \item{t_rows2_lab}{Longer labels for `t_rows2`.}
#'   \item{values}{Actual values of the table in thousand kunas.}
#'   \item{t_cols2}{Column labels, following Eurostat conventions. A `CPA_`
#'     suffix was added to original DZS column names.}
#'   \item{t_cols2_lab}{Longer labels for `t_cols2`.}
#'   \item{iotables_col}{Standardized `iotables` column labels for easier
#'     reading.}
#'   \item{col_order}{Column ordering to keep the matrix legible.}
#'   \item{iotables_row}{Standardized `iotables` row labels for easier reading.}
#'   \item{row_order}{Row ordering to keep the matrix legible.}
#'   \item{unit}{Different from Eurostat tables, in thousand national currency
#'     units.}
#'   \item{geo}{ISO/Eurostat country code for Croatia.}
#'   \item{geo_lab}{ISO/Eurostat country name, Croatia.}
#'   \item{time}{Date of the SIOT.}
#' }
#'
#' @source [Državni zavod za statistiku](https://dzs.gov.hr/)
#'
#' @family Croatia 2010 datasets
"croatia_2010_1800"
#' @title Input-output table for Croatia, 2010 (imports)
#'
#' @description
#' Symmetric input-output table (SIOT) for imports (product × product), code
#' **1900**.
#'
#' Values are expressed in thousand kunas (T_NAC).
#'
#' @format A data frame with 13 variables:
#' \describe{
#'   \item{t_rows2}{Technology codes in row names, following Eurostat
#'     conventions.}
#'   \item{t_rows2_lab}{Longer labels for `t_rows2`.}
#'   \item{values}{Actual values of the table in thousand kunas.}
#'   \item{t_cols2}{Column labels, following Eurostat conventions. A `CPA_`
#'     suffix was added to original DZS column names.}
#'   \item{t_cols2_lab}{Longer labels for `t_cols2`.}
#'   \item{iotables_col}{Standardized `iotables` column labels for easier
#'     reading.}
#'   \item{col_order}{Column ordering to keep the matrix legible.}
#'   \item{iotables_row}{Standardized `iotables` row labels for easier reading.}
#'   \item{row_order}{Row ordering to keep the matrix legible.}
#'   \item{unit}{Different from Eurostat tables, in thousand national currency
#'     units.}
#'   \item{geo}{ISO/Eurostat country code for Croatia.}
#'   \item{geo_lab}{ISO/Eurostat country name, Croatia.}
#'   \item{time}{Date of the SIOT.}
#' }
#'
#' @source [Državni zavod za statistiku](https://dzs.gov.hr/)
#'
#' @family Croatia 2010 datasets
"croatia_2010_1900"
#' @title Croatian employment data for 2013
#'
#' @description
#' Aggregated employment statistics for Croatia in 2013, formatted to match
#' the Eurostat standard symmetric input-output table (SIOT) structure.
#'
#' @format A data frame with 107 observations and 3 variables:
#' \describe{
#'   \item{code}{Short labels for industries or sectors.}
#'   \item{iotables_row}{`iotables`-style row labels.}
#'   \item{employment}{Employment in the sector (absolute values, not in
#'     thousands).}
#' }
#'
#' @usage data(croatia_employment_2013)
#'
#' @family Croatia 2010 datasets
"croatia_employment_2013"
#' Aggregation Table for Croatian Employment Statistics
#'
#' A mapping table to aggregate detailed Croatian employment statistics into
#' the Croatian (EU-standard) symmetric input–output table (SIOT) format.
#'
#' @format A data frame with 105 rows (including empty rows) and 2 variables:
#' \describe{
#'   \item{employment_label}{Labels from the DZS (Croatian Bureau of Statistics)
#'     English-language export.}
#'   \item{t_cols2}{Labels used in EU/DZS symmetric input–output tables
#'     (SIOTs).}
#' }
#'
#' @details
#' This dataset provides a concordance between Croatian employment
#' classifications and the EU/DZS SIOT framework, enabling consistent
#' integration of employment data into input–output analysis.
#'
#' @family Croatia 2010 datasets
"croatia_employment_aggregation"
#' Employment Metadata
#'
#' A reference dataset linking Eurostat national accounts vocabulary with
#' employment statistics data.
#'
#' @format A data frame with 6 variables:
#' \describe{
#'   \item{emp_code}{Codes used in the employment statistics.}
#'   \item{code}{Eurostat labels for SIOTs corresponding to `emp_code`.}
#'   \item{label}{Eurostat label descriptions for SIOTs corresponding to
#'     `emp_code`.}
#'   \item{variable}{Eurostat vocabulary source (e.g., `t_rows`, `t_cols`,
#'     `prod_na`, `induse`).}
#'   \item{group}{Grouping of accounts (different from Eurostat tables), in
#'     thousands of national currency units.}
#'   \item{iotables_label}{Custom machine-readable snake_case variable names.}
#' }
#'
#' @details
#' This dataset provides a mapping between employment statistics codes and the
#' vocabulary used in Eurostat input–output tables, ensuring compatibility when
#' joining employment and national accounts data.
#'
#' @family metadata datasets
"employment_metadata"
#' Eurostat Industry Supply, Adjustments and Value Added Vocabulary (`ind_ava`)
#'
#' A reference codelist used in Eurostat’s national accounts framework for
#' the **industry × industry** (NACE-based) symmetric input–output tables (SIOTs).
#' This vocabulary enumerates the **rows** of the table, covering both the
#' intermediate (Quadrant 1) and value-added (Quadrant 3) blocks, and includes
#' the control total *“Total supply at basic prices”* published by Eurostat.
#'
#' @details
#' The `ind_ava` vocabulary aligns with the official Eurostat SDMX codelist
#' *“Industries, adjustments and value added”* and is used by the
#' [iotables] package to order the rows of industry-by-industry tables
#' (datasets such as `naio_10_cp1750`).
#'
#' Codes correspond to NACE Rev. 2 divisions and ESA 2010 accounting aggregates.
#' Each entry includes its quadrant classification and an ordinal numeric order
#' to preserve correct row sequencing when reshaping long-form data.
#'
#' The dataset retains the published control total (“Total supply at basic prices”)
#' for consistency with Eurostat’s metadata, but this row is normally excluded
#' from analytical matrix operations.
#'
#' Because the Eurostat SIOT datasets sometimes contain more detailed industry
#' breakup than their vocabulary, we adopted industry codeing from  [cpa2_1].
#' These codes are marked the "Adopted from CPA2_1" status.
#'
#' @format A tibble (data frame) with 10 variables:
#' \describe{
#'   \item{id}{Canonical Eurostat concept identifier.}
#'   \item{label}{Official Eurostat label (preferred English term).}
#'   \item{status}{"Valid" or "Adopted from CPA2_1".}
#'   \item{status_modified}{Date of the most recent status update.}
#'   \item{notation}{Alternate human-readable code or short form (e.g. `CPA_A01`).}
#'   \item{group}{Optional grouping of related industries or aggregates.}
#'   \item{quadrant}{Integer designating the analytical block:
#'     `10` = Intermediate (technology block, Quadrant 1);
#'     `20` = Value added (primary inputs, Quadrant 3);
#'     `30` = Control total(s).}
#'   \item{numeric_order}{Ordinal position key for sorting within quadrant.}
#'   \item{iotables_label}{Simplified legacy label used in the [iotables] package.}
#'   \item{block}{Semantic block category inferred from `quadrant`
#'     (`intermediate`, `primary_inputs`, `control_total`, `extension`).}
#'   \item{uri}{Stable URI linking to the Eurostat SKOS concept at
#'     <https://dd.eionet.europa.eu/>.}
#' }
#'
#' @source Eurostat metadata registry (DD EIONET vocabulary:
#' <https://dd.eionet.europa.eu/vocabulary/eurostat/ind_ava/>)
#'
#' @seealso
#'   Other Eurostat vocabularies included in the package:
#'   [ind_use], [prd_use], [prd_ava], [cpa2_1].
#'
#' @keywords datasets metadata Eurostat input-output SUT SIOT
#'
#' @examples
#' data(ind_ava)
"ind_ava"
#' Eurostat Industry Uses Vocabulary (`ind_use`)
#'
#' A reference codelist used in Eurostat’s national accounts framework for
#' **industry × industry** (NACE-based) symmetric input–output tables (SIOTs).
#' This vocabulary enumerates the **columns** of the table, covering the
#' intermediate-use block (Quadrant 1), the value-added block (Quadrant 3), and
#' the final-use and balancing items (Quadrant 2/50).
#'
#' @details The `ind_use` vocabulary corresponds to the official Eurostat SDMX
#' codelist
#' *“Industry uses”*.
#' It is used by the [iotables] package to order the **column dimension** of
#' industry-by-industry tables (datasets such as `naio_10_cp1750`).
#'
#' Codes follow **NACE Rev. 2** for industries and **ESA 2010** for accounting
#' aggregates. Each entry includes its quadrant classification and an ordinal
#' numeric sequence for reproducible column ordering when reshaping long-form
#' data.
#'
#' The vocabulary also includes recent Eurostat additions introduced in 2023
#' (*ITTM* – International trade and transport margins, *MCH* – Merchanting, and
#' *OP* – Purchases by residents abroad). These appear in the final-use block
#' (`quadrant = 30`) and are retained for completeness and balancing, though
#' they are not part of the analytical technology matrix.
#'
#' Because the Eurostat SIOT datasets sometimes contain more detailed industry
#' breakup than their vocabulary, we adopted industry codeing from  [cpa2_1].
#' These codes are marked the "Adopted from CPA2_1" status.
#'
#' @format A tibble (data frame) with 10 variables:
#' \describe{
#'   \item{id}{Canonical Eurostat concept identifier.}
#'   \item{label}{Official Eurostat label (preferred English term).}
#'   \item{status}{"Valid" or "Adopted from CPA2_1".}
#'   \item{status_modified}{Date of last status modification.}
#'   \item{notation}{Alternate human-readable code or short form (e.g. `CPA_A01`).}
#'   \item{quadrant}{Integer designating the analytical block:
#'     `10` = Intermediate (technology block, Q1);
#'     `20` = Primary inputs / GVA (Q3);
#'     `30` = Final use / control totals (Q2);
#'     `50` = Extensions / diagnostics.}
#'   \item{numeric_order}{Ordinal key for ordering columns within quadrants.}
#'   \item{iotables_label}{Simplified legacy label used in the [iotables] package.}
#'   \item{block}{Semantic block category inferred from `quadrant`
#'     (`intermediate`, `primary_inputs`, `final_use`, `extension`).}
#'   \item{uri}{Stable URI linking to the Eurostat SKOS concept at
#'     <https://dd.eionet.europa.eu/>.}
#' }
#'
#' @source Eurostat metadata registry
#'   (<https://dd.eionet.europa.eu/vocabulary/eurostat/ind_use/>)
#'
#' @seealso Related Eurostat vocabularies: [ind_ava], [prd_ava], [prd_use],
#' [cpa2_1].
#'
#' @keywords datasets metadata Eurostat input-output SUT SIOT
#'
#' @examples
#' data(ind_use)
#' dplyr::count(ind_use, quadrant)
"ind_use"
#' Eurostat National Accounts Vocabulary Metadata (legacy)
#'
#' @description
#' The `metadata` dataset provides the **legacy** Eurostat national accounts
#' vocabulary used in earlier versions of the **iotables** package to correctly
#' order wide-format rows and columns when reshaping bulk long-form Eurostat
#' input–output (IO) and supply–use (SUT) tables.
#'
#' It predates the modern SDMX-aligned metadata system introduced in 2025 and
#' has been retained for backward compatibility and reproducibility of analyses
#' built on earlier versions of the Eurostat warehouse (ESA 2010, 2014–2022).
#'
#' The dataset encodes the structure of the pre-2023 vocabularies (`prod_na`,
#' `induse`, `t_rows`, `t_cols`) used by the legacy `iotable_get()` and
#' `iotable_get_builtin()` functions. It provides the column and row ordering
#' necessary for consistent matrix construction.
#'
#' @format A data frame with 8 variables:
#' \describe{
#'   \item{variable}{Vocabulary source identifier (e.g. `t_rows`, `t_cols`,
#'     `prod_na`, `induse`).}
#'   \item{group}{Informal macroeconomic grouping or block label.}
#'   \item{code}{Eurostat SDMX code used as identity.}
#'   \item{label}{Official Eurostat description of the code.}
#'   \item{quadrant}{Numeric indicator of table placement:
#'     `10` = intermediate (Quadrant 1),
#'     `20` = GVA/value added (Quadrant 3),
#'     `30` = final use (Quadrant 2).}
#'   \item{account_group}{Grouping of accounts (not part of the original Eurostat
#'     tables). Used for internal ordering and labelling.}
#'   \item{numeric_label}{Numeric key derived from `quadrant`, `account_group`,
#'     and digit-based components of `code`, used to sort rows and columns.}
#'   \item{iotables_label}{Legacy, machine-readable label in snake_case used
#'     internally for ordering and analysis.}
#' }
#'
#' @details
#' This dataset is maintained only for compatibility with legacy Eurostat
#' vocabularies (ESA 2010 format, pre-2023).
#'
#' \strong{Transition note:}
#' The functions [`iotables_download()`] and [`iotable_get_eurostat()`] now use
#' use [ind_ava], [prd_ava], [ind_use], [prd_use] —
#' the SDMX-aligned canonical
#' metadata vocabularies introduced in 2025.
#' The `metadata` object remains accessible for
#' reproducing results from earlier iotables versions (≤ 0.9.4) or from studies
#' relying on the `naio_10_cp16*` and `naio_10_cp17*` datasets prior to the
#' Eurostat vocabulary migration.
#'
#' @family metadata datasets
#' @seealso [ind_ava], [prd_ava], [ind_use], [prd_use],
#'  [iotable_get_eurostat()], [iotables_download()]
#' @keywords internal
#'
#' @examples
#' # Preview structure of legacy metadata
#' head(metadata)
#'
#' # Filter for old 'prod_na' items (legacy ESA 2010 vocabulary)
#' subset(metadata, variable == "prod_na")[1:6, c("code", "label")]
#'
"metadata"
#' Multipliers and Effects (Product) for Testing
#'
#' A reference dataset derived from the **United Kingdom Input–Output
#' Analytical Tables, 2010**. This version was imported from Excel and
#' reformatted for internal testing.
#'
#' @format A data frame with 10 variables:
#' \describe{
#'   \item{variable}{A constant used by [iotable_get()].}
#'   \item{uk_row}{Row identifiers from the UK tables. Dots and `&` were
#'     converted to `-`.}
#'   \item{uk_col}{Column identifiers from the UK tables. Dots and `&` were
#'     converted to `-`.}
#'   \item{uk_row_label}{Original UK row labels.}
#'   \item{uk_col_label}{Original UK column labels.}
#'   \item{eu_prod_na}{Eurostat vocabulary equivalent of `uk_row`.}
#'   \item{row_order}{Ordering key for rows.}
#'   \item{col_order}{Ordering key for columns.}
#'   \item{prod_na}{Eurostat-like key values for rows.}
#'   \item{induse}{Eurostat-like key values for columns.}
#' }
#'
#' @details
#' This dataset provides a mapping between the UK 2010 analytical input–output
#' tables and Eurostat-compatible codes, intended mainly for testing and
#' validation.
#'
#' @family metadata datasets
"metadata_uk_2010"
#' Eurostat Product Supply, Adjustments and Value Added Vocabulary (`prd_ava`)
#'
#' A reference codelist used in Eurostat’s national accounts framework for
#' **product × product** symmetric input–output tables (SIOTs).
#' This vocabulary enumerates the **rows** of product-based tables, covering
#' intermediate products (Quadrant 1), value-added components (Quadrant 3), and
#' selected control totals such as *“Total supply at basic prices”*.
#'
#' @details The `prd_ava` vocabulary aligns with the official Eurostat SDMX
#'   codelist
#' *“Products, adjustments and value added”*.
#'   It is used by the [iotables] package to order the **row dimension** of
#'   product-by-product tables (datasets such as `naio_10_cp1700`).
#'
#'   Codes correspond to **CPA 2.1** product classifications and ESA 2010
#'   accounting aggregates. Each entry includes a quadrant identifier and an
#'   ordinal numeric order for consistent placement when reshaping long-form
#'   data.
#'
#'   The dataset retains published control totals and balancing items for
#'   completeness (e.g., *Total supply at basic prices* or *CIF/FOB
#'   adjustments*), but these rows are normally excluded from analytical
#'   matrices.
#'
#'   Because the Eurostat SIOT datasets sometimes contain more detailed industry
#'   breakup than their vocabulary, we adopted industry codeing from  [cpa2_1].
#'   These codes are marked the "Valid in CPA2_1" status.
#'
#' @format A tibble (data frame) with 10 variables:
#' \describe{
#'   \item{id}{Canonical Eurostat concept identifier.}
#'   \item{label}{Official Eurostat label (preferred English term).}
#'   \item{status}{"Valid" or "Valid in CPA2_1".}
#'   \item{status_modified}{Date of last status modification.}
#'   \item{notation}{Alternate human-readable code or short form (e.g. `CPA_A01`).}
#'   \item{ind_ava_notation}{Legacy comparison column retained for internal cross-checks.}
#'   \item{quadrant}{Integer designating the analytical block:
#'     `10` = Intermediate (technology block, Quadrant 1);
#'     `20` = Primary inputs / GVA (Quadrant 3);
#'     `30` = Control totals;
#'     `50` = Extensions / adjustments.}
#'   \item{numeric_order}{Ordinal position key for ordering within quadrants.}
#'   \item{iotables_label}{Simplified legacy label used in the [iotables] package.}
#'   \item{block}{Semantic block category inferred from `quadrant`
#'     (`intermediate`, `primary_inputs`, `control_total`, `extension`).}
#'   \item{uri}{Stable URI linking to the Eurostat SKOS concept at
#'     <https://dd.eionet.europa.eu/>.}
#' }
#'
#' @source Eurostat metadata registry
#'   (<https://dd.eionet.europa.eu/vocabulary/eurostat/prd_ava/>)
#'
#' @seealso Related Eurostat vocabularies: [ind_ava], [ind_use], [prd_use],
#'   [cpa2_1].
#'
#' @keywords datasets metadata Eurostat input-output SUT SIOT
#'
#' @examples
#' data(prd_ava)
"prd_ava"
#' Eurostat Product Uses Vocabulary (`prd_use`)
#'
#' A reference codelist used in Eurostat’s national accounts framework for
#' **product × product** symmetric input–output tables (SIOTs).
#' This vocabulary enumerates the **columns** of product-based tables, covering
#' intermediate product uses (Quadrant 1), value-added components (Quadrant 3),
#' and the final-use block (Quadrant 2), as well as balancing or extension
#' items.
#'
#' @details The `prd_use` vocabulary corresponds to the official Eurostat SDMX
#' codelist
#' *“Product uses”*.
#' It is used by the [iotables] package to order the **column dimension** of
#' product-by-product tables (datasets such as `naio_10_cp1700`).
#'
#' Codes follow **CPA 2.1** for products and **ESA 2010** for accounting
#' aggregates. Each entry includes a quadrant identifier and a numeric order key
#' that ensures consistent column ordering when reshaping Eurostat’s long-form
#' data into analytical matrices.
#'
#' The dataset also retains control totals and adjustment items (Quadrant 30/50)
#' such as *Total use at purchasers’ prices*, *CIF/FOB adjustments*, or
#' *Discrepancy*, which are part of Eurostat’s published codelist but are
#' normally excluded from matrix algebra operations.
#'
#' Because the Eurostat SIOT datasets sometimes contain more detailed industry
#' breakup than their vocabulary, we adopted industry codeing from  [cpa2_1].
#' These codes are marked the "Valid in CPA2_1" status.
#'
#' @format A tibble (data frame) with 10 variables:
#' \describe{
#'   \item{id}{Canonical Eurostat concept identifier.}
#'   \item{label}{Official Eurostat label (preferred English term).}
#'   \item{status}{"Valid" or "Valid in CPA2_1".}
#'   \item{status_modified}{Date of last status modification.}
#'   \item{notation}{Alternate human-readable code or short form (e.g. `CPA_A01`).}
#'   \item{quadrant}{Integer designating the analytical block:
#'     `10` = Intermediate (technology block, Q1);
#'     `20` = Primary inputs / GVA (Q3);
#'     `30` = Final use (Q2);
#'     `50` = Extensions / diagnostics.}
#'   \item{numeric_order}{Ordinal key for ordering columns within quadrants.}
#'   \item{iotables_label}{Simplified legacy label used in the [iotables] package.}
#'   \item{block}{Semantic block category inferred from `quadrant`
#'     (`intermediate`, `primary_inputs`, `final_use`, `extension`).}
#'   \item{uri}{Stable URI linking to the Eurostat SKOS concept at
#'     <https://dd.eionet.europa.eu/>.}
#' }
#'
#' @source Eurostat metadata registry
#'   (<https://dd.eionet.europa.eu/vocabulary/eurostat/prd_use/>)
#'
#' @seealso Related Eurostat vocabularies: [prd_ava], [ind_ava], [ind_use].
#'
#' @keywords datasets metadata Eurostat input-output SUT SIOT
#'
#' @examples
#' data(prd_use)
"prd_use"
#' Primary input abbreviations
#'
#' Only currently used primary inputs. Abbreviations for filtering.
#' @format A data frame with 105 rows (including empty ones) and 2 variables.
#' \describe{
#'   \item{t_rows2}{Eurostat code of the input.}
#'   \item{t_rows2_lab}{Labelling of the input by Eurostat.}
#'   \item{source}{Eurostat / DZS }
#'   \item{indicator}{Human readable abbreviation}
#' }
#' @usage data("croatia_employment_aggregation")
#' @family Croatia 2010 datasets
"primary_inputs"
#' United Kingdom Input–Output Analytical Tables, 2010
#'
#' @description
#' Official **Input–Output Analytical Tables** for the United Kingdom (2010),
#' published by the Office for National Statistics (ONS).
#'
#' These replication data are harmonized to the *iotables* package format
#' and can be accessed via [iotable_get()] by setting the `source` parameter
#' to one of the available tables.
#'
#' @details
#' The dataset includes five analytical table types from the 2010 UK Input–Output release:
#'
#' - `uk_2010_siot` — Input–Output table (domestic use, basic prices, product × product)
#' - `uk_2010_use` — Domestic use table at basic prices (product × industry)
#' - `uk_2010_imports` — Imports use table at basic prices (product × product)
#' - `uk_2010_coeff` — Matrix of coefficients (product × product)
#' - `uk_2010_inverse` — Leontief inverse (product × product)
#'
#' These correspond to the Excel sheets from the official ONS publication.
#'
#' @usage
#' data(uk_2010_data)
#'
#' @format
#' A [tibble][tibble::tibble] with **10 variables**:
#'
#' \describe{
#'   \item{uk_row}{Row identifier (dots and `&` converted to `-`).}
#'   \item{uk_row_lab}{Original ONS row label.}
#'   \item{uk_col}{Column identifier (dots and `&` converted to `-`).}
#'   \item{uk_col_lab}{Original ONS column label.}
#'   \item{geo}{Eurostat-style geocode (constant: `"UK"`).}
#'   \item{geo_lab}{Human-readable country label (constant: `"United Kingdom"`).}
#'   \item{indicator}{Indicator or table name, matching Excel sheet title.}
#'   \item{unit}{Eurostat-style unit code (e.g. `"MIO_NAC"`).}
#'   \item{unit_lab}{Human-readable unit label (e.g. `"Million national currency"`).}
#'   \item{values}{Numeric values for each indicator.}
#'   \item{year}{Constant value: `2010`.}
#' }
#'
#' @source
#' Office for National Statistics (2010). *United Kingdom Input–Output Analytical Tables, 2010.*
#' Retrieved from the [UK National Archives (ONS Web Archive)](https://webarchive.nationalarchives.gov.uk/20160114044923/https://www.ons.gov.uk/ons/rel/input-output/input-output-analytical-tables/2010/index.html).
#'
#' @seealso
#' - [iotable_get()] for accessing and filtering IO tables.
#' - [iotables_download()] for downloading current Eurostat and UK datasets.
#'
#' @family validation datasets
#' @keywords datasets
#'
"uk_2010_data"
#' @title UK multipliers and effects (product), 2010
#'
#' @description
#' Published multipliers and effects from the United Kingdom
#' Input–Output Analytical Tables, reference year 2010.
#'
#' This dataset contains output, employment cost, and GVA multipliers
#' and effects, together with their published rankings. It is imported
#' from the official ONS Excel release and normalized for use in
#' \pkg{iotables}. It is primarily used in the
#' \code{vignette("united_kingdom_2010", package = "iotables")} to
#' validate the package’s multiplier functions against official UK
#' results.
#'
#' @details
#' The Office for National Statistics (ONS) publishes Input–Output
#' Analytical Tables (IOATs) for the UK. From these, Type I and Type II
#' multipliers and effects are calculated. This dataset contains those
#' published values at the product level for 2010, enabling direct
#' cross-checks with \pkg{iotables} computations.
#'
#' @format A tibble with 127 rows and 12 variables:
#' \describe{
#'   \item{uk_row_label}{Product/industry label.}
#'   \item{output_multiplier}{Output multiplier (published).}
#'   \item{output_multiplier_rank}{Ranking of output multipliers.}
#'   \item{employment_cost_multiplier}{Employment cost multiplier.}
#'   \item{employment_cost_multiplier_rank}{Ranking of employment cost multipliers.}
#'   \item{employment_cost_effects}{Employment cost effects.}
#'   \item{employment_cost_effects_rank}{Ranking of employment cost effects.}
#'   \item{gva_multiplier}{GVA multiplier.}
#'   \item{gva_multiplier_rank}{Ranking of GVA multipliers.}
#'   \item{gva_effects}{GVA effects.}
#'   \item{gva_effects_rank}{Ranking of GVA effects.}
#'   \item{indicator}{Indicator label, usually
#'     "Multipliers and effects (product)".}
#' }
#'
#' @source
#' Office for National Statistics (ONS), UK Input–Output Analytical
#' Tables 2010 (Excel release).
#'
#' @seealso
#' \code{vignette("united_kingdom_2010", package = "iotables")}
#'
#' @family validation datasets
"uk_test_results"
#' Germany 1995 symmetric input–output table (ESA 2010 codes)
#'
#' @description
#' Reproduction of Table 15.4 in the Eurostat Manual
#' (*Input–output table of domestic output at basic prices, Version A*).
#' This is a small, well-documented benchmark dataset that accompanies the
#' \pkg{iotables} package. It is reformatted into the same long structure
#' as Eurostat warehouse SIOTs, so that functions and tests can work
#' identically on this example and on real Eurostat downloads.
#'
#' @details
#' The values come from Beutel (2008), *Eurostat Manual of Supply, Use and
#' Input–Output Tables*, Table 15.4. Labels and codes follow ESA 2010
#' conventions (e.g. \code{CPA_A}, \code{CPA_B-E}, \code{P3_S14}),
#' allowing direct comparison with modern Eurostat releases.
#'
#' This dataset underpins many unit tests in \pkg{iotables}: multipliers,
#' coefficients, and linkage indices are validated against the published
#' benchmark. Because it is small (247 rows), it is also used in vignettes
#' and examples to demonstrate workflows.
#'
#' @format A data frame with 247 rows and 11 columns:
#' \describe{
#'   \item{prod_na}{Row code (ESA 2010 / CPA aggregate).}
#'   \item{prod_na_lab}{Row label, long description.}
#'   \item{iotables_row}{Row identifier used internally.}
#'   \item{iotables_col}{Column identifier (factor with 13 levels).}
#'   \item{values}{Cell value, in millions of euros (integer).}
#'   \item{induse}{Column code (ESA 2010 / CPA aggregate or national accounts
#'     item).}
#'   \item{geo}{Country code, always \code{"DE"}.}
#'   \item{geo_lab}{Country name, \code{"Germany"}.}
#'   \item{time}{Reference year, as a Date (\code{"1995-01-01"}).}
#'   \item{unit}{Unit code, \code{"MIO_EUR"}.}
#'   \item{unit_lab}{Unit label, \code{"Million euro"}.}
#' }
#'
#' @source
#' Beutel, J. (2008). *Eurostat Manual of Supply, Use and Input–Output
#' Tables*, Table 15.4. Luxembourg: Office for Official Publications of the
#' European Communities.
#'
#' @seealso
#' [iotable_get()] for extracting comparable tables from Eurostat.
#'
#' @examples
#' data(germany_1995)
#' head(germany_1995)
#' # Verify against the Eurostat manual:
#' subset(germany_1995, prod_na == "CPA_A" & iotables_col == "agriculture_group")
"germany_1995"
#' @title Air pollution table for Germany, 1995
#'
#' @description
#' Air pollution values for validation and cross-checking with the Eurostat
#' Manual.
#'
#' @details
#' This dataset is provided for testing purposes. Labels were slightly adjusted
#' to reflect the transition from ESA95 to ESA2010 vocabulary since the
#' publication of the Eurostat Manual.
#'
#' @source
#' Eurostat (2008). *Eurostat Manual of Supply, Use and Input–Output Tables*,
#' p. 482.
#' Available at \url{https://ec.europa.eu/eurostat/documents/3859598/5902113/KS-RA-07-013-EN.PDF}
#'
#' @format A data frame with 72 observations and 4 variables:
#' \describe{
#'   \item{airpol}{Abbreviation of the air pollutant.}
#'   \item{induse}{Column labels, following Eurostat conventions with minor
#'     differences.}
#'   \item{iotables_col}{Column labels using `iotables` abbreviations.}
#'   \item{value}{Values in thousand tons.}
#' }
#'
#' @family validation datasets

"germany_airpol"
#' @title Simplified input–output table for the Netherlands, 2000 (Spicosa example)
#'
#' @description
#' Aggregated symmetric input–output table (SIOT) for the Netherlands,
#' reference year 2000, reproduced from the *Science Policy Integration
#' for Coastal Systems Assessment* (Spicosa) project’s multiplier
#' specification sheet (D’Hernoncourt, Cordier & Hadley, 2011).
#'
#' This dataset was originally created in the Spicosa project (circa 2006)
#' as a simplified teaching table, based on OECD/Eurostat SIOT data.
#' Column and row names were slightly adjusted to resemble Eurostat
#' conventions and to align with the main example dataset [germany_1995].
#'
#' @details
#' The Spicosa specification sheet demonstrates the derivation of type I
#' and type II multipliers step by step from this table. This dataset
#' corresponds to Table 1 of that report, the domestic transactions
#' input–output table (million EUR, year 2000). It is not an official
#' Statistics Netherlands SIOT, but a simplified, aggregated example for
#' multiplier analysis.
#'
#' @format A data frame with 14 observations and 13 variables:
#' \describe{
#'   \item{prod_na}{Simplified product/industry names.}
#'   \item{agriculture_group}{Aggregated agricultural products.}
#'   \item{mining_group}{Aggregated mining products.}
#'   \item{manufacturing_group}{Aggregated manufacturing products.}
#'   \item{construction_group}{Construction.}
#'   \item{utilities_group}{Aggregated utilities products/services.}
#'   \item{services_group}{Aggregated services products.}
#'   \item{TOTAL}{Row/column sums; a simple summary not present in the
#'     original source.}
#'   \item{final_consumption_private}{Aggregated final private consumption.}
#'   \item{final_consumption_households}{Aggregated final household
#'     consumption.}
#'   \item{final_consumption_government}{Aggregated final government
#'     consumption.}
#'   \item{gross_fixed_capital_formation}{Gross fixed capital formation (GFCF).}
#'   \item{exports}{Aggregated exports.}
#'   \item{total_use}{Aggregated total use.}
#' }
#'
#' @source
#' D’Hernoncourt, J., Cordier, M. & Hadley, D. (2011).
#' *Input–Output Multipliers: Specification sheet and supporting material*.
#' Spicosa Project Report. <https://hal.science/hal-03233439>
#'
#' @family validation datasets
"netherlands_2000"
#' @title Create direct effects
#'
#' @description The function creates the effects.
#' @param input_requirements A matrix or vector created by
#' \code{\link{input_indicator_create}}
#' @param inverse A Leontief-inverse created by
#' \code{\link{leontief_inverse_create}}.
#' @param digits Rounding digits, defaults to \code{NULL}, in which case
#' no rounding takes place.
#' @importFrom dplyr select mutate all_of
#' @return A data.frame containing the direct effects and the necessary
#' metadata to sort them or join them with other matrixes.
#' @family indicator functions
#' @examples
#' nl <- netherlands_2000
#'
#' input_coeff_nl <- input_coefficient_matrix_create(
#'   data_table = netherlands_2000,
#'   households = FALSE
#' )
#'
#' compensation_indicator <- input_indicator_create(netherlands_2000, "compensation_employees")
#'
#' I_nl <- leontief_inverse_create(input_coeff_nl)
#'
#' direct_effects_create(
#'   input_requirements = compensation_indicator,
#'   inverse = I_nl
#' )
#' @export

direct_effects_create <- function(input_requirements,
                                  inverse,
                                  digits = NULL) {
  names_direct <- names(input_requirements)
  key_column <- names(input_requirements)[1]
  replace_dot <- function(x) gsub(pattern = "_indicator", "", x)
  extend <- function(x) paste0(x, "_effect")

  new_key_column <- input_requirements %>%
    select(1:2) %>%
    mutate(across(all_of(key_column), replace_dot)) %>%
    mutate(across(all_of(key_column), extend))

  if (all(names(inverse) %in% names(input_requirements))) {
    input_requirements <- select(
      input_requirements,
      all_of(names(inverse))
    )
  }

  col_n <- ncol(input_requirements)

  # columns of the left matrix must be the same as the number of rows of
  # the right matrix
  # Remove key column------
  key_column <- subset(input_requirements, select = 1)
  input_requirements_matrix <- input_requirements[, -1]
  inverse <- inverse[, -1]

  inverse <- as.matrix(inverse)
  input_requirements_matrix <- as.matrix(input_requirements_matrix)


  effects <- input_requirements_matrix %*% inverse

  if (!is.null(digits)) {
    if (digits >= 0) {
      effects <- round(effects, digits)
    }
  }

  cbind(new_key_column[, 1], effects)
}
#' Get Eurostat employment data for SIOTs
#'
#' Download employment data from Eurostat (dataset
#' [lfsq_egan22d](https://ec.europa.eu/eurostat/web/products-datasets/-/lfsq_egan22d))
#' and arrange it to match 64 × 64 symmetric input–output tables (SIOTs).
#'
#' @details
#' - Currently implemented only for product × product tables.
#' - Country codes are harmonized: `"GB"` → `"UK"`, `"GR"` → `"EL"`.
#' - Sex is normalized internally to Eurostat codes `"T"`, `"F"`, `"M"`.
#' - Results are cached as `.rds` files in `data_directory` if supplied.
#' - An imputed rent column (`L68A`/`CPA_L68A`) with zero is always added.
#'
#' @param geo A two-letter country code (Eurostat style). `"GB"` and `"GR"`
#'   are automatically converted to `"UK"` and `"EL"`.
#' @param year Year of employment data (>= 2008, when NACE Rev. 2 was
#'   introduced).
#' @param sex Employment by sex. Defaults to `"Total"`. Alternatives are
#'   `"Female"`/`"F"`, `"Male"`/`"M"`. Case-insensitive.
#' @param age Eurostat age code. Defaults to `"Y_GE15"`. Any valid Eurostat
#'   code may be supplied (see Eurostat metadata).
#' @param labelling Controls output row/column labelling:
#'   - `"iotables"`: iotables manual-style labels
#'   - `"prod_na"`: product × product (CPA codes)
#'   - `"induse"`: industry × industry (NACE codes)
#' @param data_directory Optional path to save/load pre-processed employment
#'   data (`.rds` files). If `NULL`, only downloads are used.
#' @param force_download Logical. If `TRUE`, forces a fresh Eurostat download
#'   even if local cache files exist.
#'
#' @return A one-row `data.frame` containing employment input values aligned
#'   with the chosen SIOT labelling, including an imputed rent column set to 0.
#'
#' @source Eurostat dataset
#'   [lfsq_egan22d](https://ec.europa.eu/eurostat/web/products-datasets/-/lfsq_egan22d)
#'
#' @family import functions
#' @importFrom dplyr ungroup rename filter mutate summarize group_by
#' @importFrom dplyr ungroup
#' @importFrom tidyr spread
#' @examples
#' \dontrun{
#' employment <- employment_get(
#'   geo = "CZ",
#'   year = "2010",
#'   sex = "Total",
#'   age = "Y_GE15",
#'   data_directory = NULL,
#'   force_download = TRUE
#' )
#' }
#' @export


employment_get <- function(geo,
                           year = "2010",
                           sex = "Total",
                           age = "Y_GE15",
                           labelling = "iotables",
                           data_directory = NULL,
                           force_download = FALSE) {
  if (!labelling %in% c("iotables", "prod_na", "induse")) {
    stop("Labelling must be any of 'iotables', 'prod_na' [product x product] or 'induse' [industry x industry]")
  }

  year_number <- as.numeric(year)

  ## Avoiding no visible binding for global variable 'data' ----------
  getdata <- function(...) {
    e <- new.env()
    name <- utils::data(..., envir = e)[1]
    e[[name]]
  }

  employment_metadata <- getdata("employment_metadata")

  save_employment_file <- paste0(
    "employment_", tolower(age), "_",
    tolower(sex), "_",
    geo, "_", year, "_avg.rds"
  )

  ### Changing to Eurostat in case of GB/UK and GR/EL-------
  if (geo %in% c("GB", "GR")) {
    if (geo == "GB") {
      warning("Switching GB to Eurostat abbreviation UK.")
      geo <- "UK"
    }
    if (geo == "GR") {
      warning("Switching GR to Eurostat abbreviation EL.")
      geo <- "EL"
    }
  }

  sex <- tolower(sex)
  sex <- ifelse(grepl("total", sex), "T",
    ifelse(grepl("female", sex), "F", "M")
  )

  emp <- NULL

  ## Use data_directory if it exists--------------------------------
  if (!is.null(data_directory)) {
    # pre-existing raw data file in the data directory
    emp_file_name <- file.path(data_directory, "lfsq_egan22d.rds")

    if (!force_download) { # no new download and filtered version exists
      if (file.exists(file.path(data_directory, save_employment_file))) {
        message("Try to use pre-existing file ", save_employment_file)

        tryCatch({
          emp <- readRDS(file.path(data_directory, save_employment_file))
        }, error = function(cond) {
          message("Could not read file.", cond)
          return(NULL)
        }, finally = {
          return(emp)
        })
      } else { # no filtered version exists, work with raw file

        tryCatch({
          # Read pre-existing unfiltered raw data file
          emp <- readRDS(emp_file_name)
        }, error = function(cond) {
          message("Could not read file ", emp_file_name, "\n", cond)
          return(NULL)
        }, finally = {
          message("Read ", emp_file_name)
        })
      }
    } # end case of no forced download
  } # end case data_directory is not NULL

  ## Forced/new download--------------------------------
  if (is.null(emp)) {
    message("Downloading employment data from the Eurostat database.")
    emp <- eurostat::get_eurostat("lfsq_egan22d")

    if (!is.null(data_directory)) {
      # if !is.null emp_file_name is the general file name (without filtering
      # for the statistic and was created in the previous block including the
      # directory name)

      tryCatch({
        # Read pre-existing unfiltered raw data file
        saveRDS(emp, file = emp_file_name)
      }, error = function(cond) {
        message("Failed to save ", emp_file_name, ".")
      }, finally = {
        message("Saving raw employment data to ", emp_file_name)
      })
    }
  }

  ## Geo selection and exception handling--------------------------------
  if (geo %in% unique(emp$geo)) {
    select_geo <- which(as.character(emp$geo) %in% as.character(geo))
    emp <- emp[select_geo, ]
  } else {
    stop("No employment data found with geo parameter = ", geo)
  }

  if ("TIME_PERIOD" %in% names(emp)) {
    # Breaking change from eurostat 4.0.0
    emp <- emp %>% rename(time = TIME_PERIOD)
  }

  emp$year <- as.numeric(substr(as.character(emp$time), start = 1, stop = 4))

  ## Year selection and exception handling -------------------------------------

  if (year %in% unique(emp$year)) {
    select_year <- which(emp$year %in% year_number)
    emp <- emp[select_year, ]
  } else {
    stop("No employment data found with the year parameter = ", year)
  }

  ## Age group selection and exception handling ---------------------------------
  if (age %in% unique(emp$age)) {
    select_age <- which(as.character(emp$age) %in% as.character(age))
    emp <- emp[select_age, ]
  } else {
    stop("No employment data found with the age parameter = ", age)
  }

  ## Sex variable selection and exception handling--------------------------------
  if (sex %in% unique(emp$sex)) {
    select_sex <- which(as.character(emp$sex) %in% as.character(sex))
    emp <- emp[select_sex, ]
  } else {
    stop("No employment data found with sex parameter = ", sex)
  }

  ## Missing values changed to 0 -------------------------------------------------
  emp$values <- ifelse(is.na(emp$values), 0, emp$values)

  ## Data processing for employment variables ------------------------------------
  employment <- emp %>%
    mutate(nace_r2 = as.character(.data$nace_r2)) %>%
    group_by(nace_r2, year) %>%
    summarize(values = mean(.data$values), .groups = "drop") %>%
    dplyr::rename(emp_code = nace_r2) %>%
    ungroup() %>%
    left_join(employment_metadata,
      by = "emp_code"
    ) %>% # iotables:::employment_metadata
    dplyr::group_by(.data$code, .data$variable, .data$iotables_label) %>%
    dplyr::summarize(values = sum(.data$values), .groups = "drop")


  ## If data_directory exists, save results -------------------------------

  if (!is.null(data_directory)) {
    message("Saving ", save_employment_file)
    saveRDS(employment, file = file.path(
      data_directory,
      save_employment_file
    ))
  }


  ## If data_directory exists, save results--------------------------------

  emp_sex <- ifelse(tolower(sex) == "t", "total",
    ifelse(tolower(sex) == "f", "female", "male")
  )


  if (labelling == "iotables") { # this is the Eurostat manual-tutorial type labelling format
    prefix <- data.frame(
      iotables_row = paste0("employment_", emp_sex)
    )

    primary_employment_input <- employment %>%
      filter(variable == "prod_na") # does not matter which, not used

    ## No employment for imputed rent column--------------------------------

    primary_employment_input <- primary_employment_input %>%
      dplyr::ungroup() %>%
      select(iotables_label, values) %>%
      tidyr::spread(iotables_label, values) %>%
      ensure_l68_columns("real_estate_imputed_a") # use iotables_label in this case
  } else if (labelling == "prod_na") { ## this is the product x product labelling format
    prefix <- data.frame(
      prod_na = paste0("employment_", emp_sex)
    )

    primary_employment_input <- employment %>%
      dplyr::filter(variable == "prod_na")

    primary_employment_input <- primary_employment_input %>%
      dplyr::ungroup() %>%
      dplyr::select(code, values) %>%
      tidyr::spread(code, values) %>%
      ensure_l68_columns("CPA_L68A") # use code for standard Eurostat library
  } else if (labelling == "induse") { # this is the industry x industry labelling format
    prefix <- data.frame(
      induse = paste0("employment_", emp_sex)
    )

    primary_employment_input <- employment %>%
      dplyr::filter(variable == "induse")

    primary_employment_input <- primary_employment_input %>%
      dplyr::ungroup() %>%
      dplyr::select(code, values) %>%
      tidyr::spread(code, values) %>%
      ensure_l68_columns("L68A") # use code for standard Eurostat library
  } else {
    warning("No L68A was added.")
    return(primary_employment_input)
  }

  return_employment <- cbind(prefix, primary_employment_input)

  return_employment
}
#' Remove Empty Rows and Columns Symmetrically
#'
#' Remove columns and their corresponding rows if they contain only zeros or
#' missing values. This ensures that the resulting table remains symmetric (same
#' dimensions in rows and columns).
#'
#' @param data_table A symmetric input–output table, or the symmetric quadrant
#'   of a use or supply table.
#'
#' @return A `data.frame` (or tibble) with a key column and symmetric matrix,
#'   after removing all-zero (or all-missing) columns and their corresponding
#'   rows.
#'
#' @details The function first identifies columns that contain only zeros or
#'   missing values, then removes both those columns and the rows with matching
#'   labels in the first (key) column. A message is printed listing the removed
#'   columns.
#'
#' @examples
#' # Example using the built-in demo table
#' test_table <- input_coefficient_matrix_create(
#'   iotable_get(source = "germany_1995")
#' )
#'
#' # Set one column to zero, then remove it
#' test_table[, 2] <- 0
#' empty_remove(test_table)
#'
#' @family iotables processing functions
#' @export

empty_remove <- function(data_table) {
  ### Find non-zero cols and rows and remove them----
  non_zero_cols <- vapply(
    data_table[, seq_len(ncol(data_table))],
    non_zero_columns_find, logical(1)
  )
  non_zero_rows <- as.logical(non_zero_cols[-1])

  remove_cols <- names(data_table)[which(is.na(non_zero_cols) | non_zero_cols == FALSE)]

  siot_rows <- as.character(unlist(data_table[, 1]))

  if (length(remove_cols) > 0) {
    message("Columns and rows of ", paste(remove_cols, collapse = ", "), " are all zeros and will be removed.")
  }

  data_table[
    !siot_rows %in% remove_cols,
    !names(data_table) %in% remove_cols
  ]
}

#' Find Non-zero Columns
#'
#' Internal helper to detect empty columns (or rows) in symmetric input–output
#' style tables.
#'
#' @param data_table A column (vector) from a symmetric input–output table,
#'   a use table, or a supply table. May also be a factor or character vector.
#'
#' @return A logical value: `TRUE` if the column contains at least one non-zero
#'   numeric entry, or if the input is a factor/character column; `FALSE`
#'   otherwise.
#'
#' @keywords internal

non_zero_columns_find <- function(data_table) {
  if (class(data_table) %in% c("factor", "character")) {
    return(TRUE)
  }
  ifelse(all(as.numeric(unlist(data_table)) == 0), FALSE, TRUE)
}
#' Solve a basic matrix equation
#'
#' Match a left-hand side (LHS) vector to a Leontief inverse by column names
#' and compute the matrix product \eqn{\text{LHS} \times \text{Im}}.
#'
#' @details
#' This helper is used by higher-level wrappers such as
#' [multiplier_create()]. It assumes both inputs have a first key column,
#' followed by numeric columns whose names define the alignment. The function
#' multiplies the numeric row of `LHS` by the numeric block of `Im` after a
#' basic conformity check.
#'
#' @param LHS A one-row data frame (or matrix) with a key column first and
#'   numeric columns named to match the Leontief inverse.
#' @param Im A Leontief inverse with a key column first and a square numeric
#'   block whose column names match the `LHS` numeric names.
#'
#' @return A numeric 1×N matrix containing the solution
#'   \eqn{\text{LHS} \times \text{Im}}.
#'
#' @importFrom dplyr select mutate across full_join any_of
#'
#' @examples
#' Im <- data.frame(
#'   a = c("row1", "row2"),
#'   b = c(1, 1),
#'   c = c(2, 0)
#' )
#' LHS <- data.frame(
#'   a = "lhs",
#'   b = 1,
#'   c = 0.5
#' )
#' equation_solve(Im = Im, LHS = LHS)
#'
#' @export

equation_solve <- function(LHS = NULL, Im = NULL) {
  if (is.null(LHS) | is.null(Im)) {
    stop(
      "Error: matrix equation inputs are not given."
    )
  }

  LHS <- LHS %>%
    mutate(across(where(is.factor), as.character))

  Im <- Im %>%
    mutate(across(where(is.factor), as.character))

  if (ncol(Im) < ncol(LHS)) {
    not_found <- names(LHS)[which(!names(LHS) %in% names(Im))]

    if (all(not_found %in% c(
      "CPA_T", "CPA_U", "CPA_L68A",
      "TOTAL", "CPA_TOTAL"
    ))) {
      warning(
        paste(not_found, collapse = ","),
        " from the input vector is removed. These are likely zero values,
               and cannot be found in the Leontief-inverse."
      )
      LHS <- dplyr::select(LHS, -dplyr::any_of(not_found))
    } else if (any(not_found %in% c("households", "P3_S14"))) {
      stop("The input vector has households but the Leontief-inverse has not.")
    } else {
      stop("Non conforming input vector and Leontief-inverse.")
    }
  }

  ### Joining matrices to find out if all data is present ---------------------

  names_lhs <- names(LHS)
  names_Im <- names(Im)

  names_lhs
  names_Im

  joined <- tryCatch(
    full_join(LHS, Im, by = names(LHS)),
    error = function(e) {
      message("The technology columns are not matching.")
      return(NULL)
    }
  )

  if (is.null(joined)) {
    stop("Error: no result is returned.") # early termination if not
  }

  ### Joining matrices to find out if all data is present -----------------

  lhs <- joined[1, ]
  lhs <- as.numeric(lhs[1, 2:ncol(lhs)]) # numeric left-hand side in conforming order

  # lhs <- LHS[ ,which ( vapply(LHS,is.numeric,  logical(1)))]
  # lhs <- lhs %>% select ( any_of(names(Im))) %>% as.matrix()

  im <- joined[2:nrow(joined), ]
  im <- as.matrix(im[, 2:ncol(im)]) # numeric Leontief inverse in conforming order

  # im <- Im[, which ( vapply(LHS,is.numeric,  logical(1)))]


  ### Try to solve the matrix equation  ---------------------

  solution <- tryCatch(
    lhs %*% im,
    error = function(e) {
      message("Violation of the matrix operation.")
      return(NULL)
    }
  )

  solution
} # end of function
#' @title Forward linkages
#'
#' @description Forward linkages capture how the increased output of a sector
#' provides additional inputs to other sectors, enabling them to expand
#' production.
#'
#' @details Defined as the row sums of the Ghosh inverse, in line with the
#' Eurostat Manual of Supply, Use and Input-Output Tables (pp. 506–507) and
#' the United Nations *Handbook on Supply and Use Tables and Input-Output
#' Tables with Extensions and Applications* (p. 637).
#'
#' @param output_coefficient_matrix An output coefficient matrix created with
#'   [output_coefficient_matrix_create()].
#' @param digits Integer. Number of decimals for rounding. Defaults to `NULL`
#'   (no rounding).
#'
#' @return A `data.frame` with two columns:
#' * The metadata column from the input matrix (sector/product names)
#' * `forward_linkages`: the forward linkage indicator values
#'
#' @importFrom dplyr mutate across
#' @family linkage functions
#'
#' @examples
#' data_table <- iotable_get()
#'
#' de_out <- output_coefficient_matrix_create(
#'   data_table, "tfu",
#'   digits = 4
#' )
#'
#' forward_linkages(
#'   output_coefficient_matrix = de_out,
#'   digits = 4
#' )
#' @export
forward_linkages <- function(output_coefficient_matrix,
                             digits = NULL) {
  output_coefficient_matrix <- mutate(
    output_coefficient_matrix,
    across(where(is.factor), as.character)
  )

  G <- ghosh_inverse_create(output_coefficient_matrix)

  FLm <- G
  FLm$forward_linkages <- rowSums(G[, -1])

  if (!is.null(digits)) {
    FLm[, 2:ncol(FLm)] <- round(FLm[, 2:ncol(FLm)], digits)
  }

  FLm[, c(1, ncol(FLm))]
}
#' @keywords internal
#' @importFrom dplyr relocate filter
#' @importFrom httr2 req_user_agent req_retry req_error
#' @importFrom httr2 resp_body_json req_perform resp_content_type
get_eurostat_filtered <- function(id,
                                  filters = list(),
                                  type = "code",
                                  lang = "en",
                                  ...) {
  # ---- Build query URL ------------------------------------------------------
  base_url <- sprintf(
    "https://ec.europa.eu/eurostat/api/dissemination/statistics/1.0/data/%s",
    id
  )

  if (length(filters)) {
    query <- paste0(
      names(filters), "=",
      vapply(filters, paste, collapse = ",", FUN.VALUE = character(1)),
      collapse = "&"
    )
    base_url <- paste0(base_url, "?", query)
  }

  # ---- Download JSON --------------------------------------------------------
  jdat <- httr2::request(base_url) %>%
    httr2::req_user_agent("https://github.com/eviota/iotables") %>%
    httr2::req_retry(max_tries = 3, max_seconds = 60) %>%
    httr2::req_error(is_error = function(resp) FALSE) %>%
    httr2::req_perform() %>%
    {
      if (httr2::resp_content_type(.) != "application/json") {
        stop("Eurostat API did not return JSON", call. = FALSE)
      }
      httr2::resp_body_json(., simplifyVector = TRUE)
    }

  dims <- jdat$dimension
  ids <- jdat$id

  # ---- Construct tidy grid --------------------------------------------------
  dims_list <- lapply(dims[rev(ids)], function(x) {
    lab <- x$category$label
    if (identical(type, "label")) {
      unname(unlist(lab, use.names = FALSE))
    } else if (identical(type, "code")) {
      names(lab)
    } else if (identical(type, "both")) {
      unlist(lab)
    } else {
      stop("Invalid 'type' argument.")
    }
  })

  downloaded <- expand.grid(
    dims_list,
    KEEP.OUT.ATTRS = FALSE,
    stringsAsFactors = FALSE
  ) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(
      values = NA_real_,
      values = {
        vals <- unlist(jdat$value, use.names = FALSE)
        inds <- 1 + as.numeric(names(jdat$value))
        replace(values, inds, vals)
      }
    )

  downloaded <- tibble::rowid_to_column(downloaded)

  # ---- Filter sparce matrix  -----------------------------------
  if (all(c("prd_ava", "prd_use") %in% names(downloaded))) {
    # Product x Product Structure  --------

    row_vocab <- getdata("prd_ava")
    col_vocab <- getdata("prd_use")

    not_in_prd_ava <- downloaded %>%
      filter(is.na(values)) %>%
      filter(!prd_ava %in% row_vocab)

    not_in_prd_use <- downloaded %>%
      filter(is.na(values)) %>%
      filter(!prd_ava %in% col_vocab)

    valid_rows <- setdiff(
      downloaded$rowid,
      c(not_in_prd_ava$rowid, not_in_prd_use$rowid)
    )

    downloaded <- downloaded %>%
      filter(rowid %in% valid_rows) %>%
      select(-rowid)
  }

  if (all(c("ind_ava", "ind_use") %in% names(downloaded))) {
    # Industry x Industry Structure  --------

    row_vocab <- getdata("ind_ava")
    col_vocab <- getdata("ind_use")

    not_in_ind_ava <- downloaded %>%
      filter(is.na(values)) %>%
      filter(!ind_ava %in% row_vocab)

    not_in_ind_use <- downloaded %>%
      filter(is.na(values)) %>%
      filter(!ind_ava %in% col_vocab)

    valid_rows <- setdiff(
      downloaded$rowid,
      c(not_in_ind_ava$rowid, not_in_ind_use$rowid)
    )

    downloaded <- downloaded %>%
      filter(rowid %in% valid_rows) %>%
      select(-rowid)
  }


  # ---- Harmonise time field -------------------------------------------------
  if ("time" %in% names(downloaded)) {
    downloaded <- downloaded %>%
      dplyr::rename(TIME_PERIOD = time) %>%
      dplyr::mutate(TIME_PERIOD = as.Date(
        paste0(TIME_PERIOD, "-01-01")
      ))
  }

  attr(downloaded, "dataset") <- id

  downloaded <- tibble::rowid_to_column(downloaded)
  new_names <- names(downloaded)
  change <- which(!names(downloaded) %in% c("rowid", "TIME_PERIOD", "values"))
  new_names[change] <- paste0(new_names[change], "_lab")

  downloaded$year <- lubridate::year(downloaded$TIME_PERIOD)
  invisible(gc())
  downloaded
}


#' Use this function for non-SIOT data like air pollutants or
#' employment
#' @keywords internal
#' @importFrom dplyr relocate filter
#' @importFrom httr2 req_user_agent req_retry req_error
#' @importFrom httr2 resp_body_json req_perform resp_content_type
get_eurostat_data <- function(id,
                              filters = list(),
                              type = "code",
                              lang = "en",
                              ...) {
  # ---- Build query URL ------------------------------------------------------
  base_url <- sprintf(
    "https://ec.europa.eu/eurostat/api/dissemination/statistics/1.0/data/%s",
    id
  )

  if (length(filters)) {
    query <- paste0(
      names(filters), "=",
      vapply(filters, paste, collapse = ",", FUN.VALUE = character(1)),
      collapse = "&"
    )
    base_url <- paste0(base_url, "?", query)
  }

  # ---- Download JSON --------------------------------------------------------
  jdat <- httr2::request(base_url) %>%
    httr2::req_user_agent("https://github.com/eviota/iotables") %>%
    httr2::req_retry(max_tries = 3, max_seconds = 60) %>%
    httr2::req_error(is_error = function(resp) FALSE) %>%
    httr2::req_perform() %>%
    {
      if (httr2::resp_content_type(.) != "application/json") {
        stop("Eurostat API did not return JSON", call. = FALSE)
      }
      httr2::resp_body_json(., simplifyVector = TRUE)
    }

  dims <- jdat$dimension
  ids <- jdat$id

  # ---- Construct tidy grid --------------------------------------------------
  dims_list <- lapply(dims[rev(ids)], function(x) {
    lab <- x$category$label
    if (identical(type, "label")) {
      unname(unlist(lab, use.names = FALSE))
    } else if (identical(type, "code")) {
      names(lab)
    } else if (identical(type, "both")) {
      unlist(lab)
    } else {
      stop("Invalid 'type' argument.")
    }
  })

  downloaded <- expand.grid(
    dims_list,
    KEEP.OUT.ATTRS = FALSE,
    stringsAsFactors = FALSE
  ) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(
      values = NA_real_,
      values = {
        vals <- unlist(jdat$value, use.names = FALSE)
        inds <- 1 + as.numeric(names(jdat$value))
        replace(values, inds, vals)
      }
    )

  # ---- Harmonise time field -------------------------------------------------
  if ("time" %in% names(downloaded)) {
    downloaded <- downloaded %>%
      dplyr::rename(TIME_PERIOD = time) %>%
      dplyr::mutate(TIME_PERIOD = as.Date(
        paste0(TIME_PERIOD, "-01-01")
      ))
  }

  attr(downloaded, "dataset") <- id

  downloaded <- tibble::rowid_to_column(downloaded)
  downloaded$year <- lubridate::year(downloaded$TIME_PERIOD)
  invisible(gc())
  downloaded
}
#' @title Get an input-output table from a downloaded bulk file
#' @importFrom dplyr distinct across left_join rename select any_of
#' @importFrom tidyr pivot_wider unnest

#' @keywords internal
get_saved_table <- function(labelled_io_data,
                            geo,
                            year,
                            unit,
                            stk_flow) {
  if (nchar(geo) == 2 & geo == tolower(geo)) {
    geo <- toupper(geo)
  }

  iot <- find_saved_table(labelled_io_data,
    geo = geo,
    year = year,
    unit = unit,
    stk_flow = stk_flow
  )

  iot %>% unnest(.data$data)
}

#' @rdname get_saved_table
#' @importFrom assertthat assert_that
#' @importFrom dplyr filter

#' @keywords internal
find_saved_table <- function(labelled_io_data, geo, unit, year, stk_flow) {
  geo_input <- geo
  unit_input <- unit
  year_input <- year
  stk_flow_input <- stk_flow

  assert_that(all(c("geo", "unit", "year", "stk_flow", "data") %in% names(labelled_io_data)),
    msg = "The columns 'geo', 'year', 'unit', 'stk_flow' columns and the nested 'data' column must be present in labelled_io_data."
  )

  assert_that(geo_input %in% labelled_io_data$geo,
    msg = glue("The labelled_io_data$geo column does not contain geo='{geo_input}'.")
  )

  subset_labelled_io_data <- labelled_io_data %>% filter(geo == geo_input)

  assert_that(unit_input %in% subset_labelled_io_data$unit,
    msg = glue("The labelled_io_data$unit column does not contain unit='{unit_input}' (for geo='{geo_input}').")
  )

  subset_labelled_io_data <- subset_labelled_io_data %>% filter(unit == unit_input)

  assert_that(stk_flow_input %in% subset_labelled_io_data$stk_flow,
    msg = glue("The labelled_io_data$stk_flow column does not contain {stk_flow_input} (for geo='{geo_input}').")
  )

  subset_labelled_io_data <- subset_labelled_io_data %>% filter(stk_flow == stk_flow_input)

  assert_that(year_input %in% subset_labelled_io_data$year,
    msg = glue("The labelled_io_data$year column does not contain year='{year_input}' (for geo='{geo_input}', unit='{unit_input}', stk_flow='{stk_flow_input}'.)")
  )

  subset_labelled_io_data %>% filter(year == year_input)
}

#' @rdname get_saved_table
#' @importFrom lubridate year
#' @importFrom dplyr mutate
#' @keywords internal
get_package_iots <- function(source_input) {
  croatia_tables <- c("croatia_2010_1700", "croatia_2010_1800", "croatia_2010_1900")
  uk_tables <- c("uk_2010_siot", "uk_2010_coeff", "uk_2010_inverse")

  ## Read from file or internal dataset ----
  if (source_input == "germany_1995") {
    germany_1995 <- getdata("germany_1995")
    labelled_io_data <- germany_1995 # use germany example
    labelled_io_data$year <- 1990
  } else if (source_input == "croatia_2010_1700") {
    croatia_2010_1700 <- getdata("croatia_2010_1700")
    labelled_io_data <- croatia_2010_1700 %>%
      mutate(year = lubridate::year(.data$time))
  } else if (source_input == "croatia_2010_1800") {
    croatia_2010_1800 <- getdata("croatia_2010_1800")
    labelled_io_data <- croatia_2010_1800 %>%
      mutate(year = lubridate::year(.data$time))
  } else if (source_input == "croatia_2010_1900") {
    croatia_2010_1900 <- getdata("croatia_2010_1900")
    labelled_io_data <- croatia_2010_1900 %>%
      mutate(year = lubridate::year(.data$time))
  } else if (source_input %in% uk_tables) {
    labelled_io_data <- getdata("uk_2010_data") %>%
      mutate(year = 2010)

    if (source %in% uk_tables) {
      if (source == "uk_2010_siot") {
        labelled_io_data <- labelled_io_data %>%
          filter(indicator == "Input-Output table (domestic use, basic prices, product by product)")
      }

      if (source == "uk_2010_use") {
        labelled_io_data <- labelled_io_data %>%
          filter(indicator == "Domestic use table at basic prices (product by industry)")
      }

      if (source == "uk_2010_imports") {
        labelled_io_data <- labelled_io_data %>%
          filter(indicator == "Imports use table at basic prices (product by product)")
      }

      if (source == "uk_2010_coeff") {
        labelled_io_data <- labelled_io_data %>%
          filter(indicator == "Matrix of coefficients (product by product)")
      }

      if (source == "uk_2010_inverse") {
        labelled_io_data <- labelled_io_data %>%
          filter(indicator == "Leontief Inverse (product by product)")
      }
    }
  }
  labelled_io_data
}
#' @title Create Ghosh inverse from output coefficients
#'
#' @description
#' Compute the Ghosh inverse from an output-coefficient matrix.
#'
#' @details
#' The Ghosh inverse is defined as \eqn{G = (I - B)^{-1}}, where \eqn{B} is
#' the output-coefficient matrix created by
#' [output_coefficient_matrix_create()].
#'
#' See the United Nations *Handbook on Supply and Use Tables and Input–Output
#' Tables with Extensions and Applications* (2018, Rev. 1), pp. 622–639
#' (\href{https://unstats.un.org/unsd/nationalaccount/docs/SUT_IOT_HB_Final_Cover.pdf}{PDF}).
#'
#' For the analogous inverse based on input coefficients, see
#' [leontief_inverse_create()].
#'
#' @param output_coefficients_matrix A technology-coefficient matrix created by
#'   [output_coefficient_matrix_create()].
#' @param digits Optional integer precision for rounding. Default `NULL`
#'   (no rounding).
#'
#' @return
#' A `data.frame` with the original key column and the Ghosh inverse in the
#' remaining columns. If `digits` is provided, values are rounded.
#'
#' @importFrom dplyr mutate across where
#' @family analytic object functions
#'
#' @examples
#' # Minimal example
#' om <- output_coefficient_matrix_create(iotable_get())
#' ghosh_inverse_create(om)
#'
#' # Using the Germany 1995 benchmark table (Eurostat manual)
#' # data(germany_1995)
#' # om_de <- output_coefficient_matrix_create(germany_1995)
#' # ghosh_inverse_create(om_de)
#'
#' @export


ghosh_inverse_create <- function(output_coefficients_matrix,
                                 digits = NULL) {
  # The Ghosh-model is a dual pair of the Leontief-model, so we can use
  # the same functions, but with different inputs (output coefficients
  # instead of input coefficients.)

  ghosh_matrix <- leontief_matrix_create(
    technology_coefficients_matrix = output_coefficients_matrix
  )

  Gm <- as.matrix(ghosh_matrix[, 2:ncol(ghosh_matrix)])

  inverse <- solve(Gm)

  if (sum(vapply(inverse, function(x) sum(is.nan(x)), numeric(1))) > 0) {
    stop("Error: Could not invert the Ghosh-matrix.")
  }

  named_inverse <- cbind(
    as.data.frame(ghosh_matrix[, 1]),
    as.data.frame(inverse)
  ) %>%
    dplyr::mutate(dplyr::across(
      where(is.factor),
      function(x) as.character(x)
    ))

  names(named_inverse) <- names(ghosh_matrix)
  row.names(named_inverse) <- seq_len(nrow(named_inverse))

  if (is.null(digits)) {
    return(named_inverse)
  }

  round_table(named_inverse, digits = digits)
}
#' Package globals
#'
#' Symbols declared here avoid R CMD check "no visible binding for global variable"
#' notes. This file is transitional: as functions are refactored to use
#' `.data$var` or `.env$var` pronouns, entries can be removed.
#'
#' @keywords internal
"_PACKAGE"

#' Package globals
#'
#' Symbols declared here avoid R CMD check "no visible binding for global variable"
#' notes. This file is transitional: as functions are refactored to use
#' `.data$var` or `.env$var` pronouns, entries can be removed.
#'
#' @keywords internal
"_PACKAGE"

#' Package globals
#'
#' Symbols declared here avoid R CMD check "no visible binding for global variable"
#' notes. This file is transitional: as functions are refactored to use
#' `.data$var` or `.env$var` pronouns, entries can be removed.
#'
#' @keywords internal
"_PACKAGE"

utils::globalVariables(c(
  ".data",
  # airpol_get
  "iotables_col", "value", "indicator", "nace_r2", "time", "values",
  # employment_get
  "TIME_PERIOD", "code", "variable", "iotables_label",
  # iotable_get
  "time",
  # iotables_download
  "values_lab", "TIME_PERIOD_lab", "time_lab",
  # order_iotable
  "uk_col", "uk_row", "row_order", "col_order",
  "prod_na", "induse", "iotables_row", "iotables_col",
  "t_rows2", "t_cols2",
  # uk_2010_get
  "vars", "rowname", ".", "uk_col_lab", "uk_col",
  "uk_row_lab", "uk_row",
  # uk_2010_results_get
  "Product", "Rank...4", "Rank...6", "Rank...8",
  "Rank...10", "Rank...12",
  # vocabularies
  "label", "numeric_label",
  # get_metadata_cols
  "uk_row_label"
))
#' Find Household Expenditure Column
#'
#' Identify the column position corresponding to final household expenditure in
#' a symmetric input–output table or related table.
#'
#' @param data_table A symmetric input–output table, a use table, or a supply
#'   table.
#'
#' @return An integer vector giving the position(s) of household expenditure
#'   columns. Returns `NULL` if none are found.
#'
#' @details
#' The function searches column names case-insensitively. It first looks for
#' exact matches among the following alternatives:
#'
#' * `"households"`
#' * `"p3_s14"`
#' * `"final_consumption_households"`
#' * `"final_consumption_household"`
#' * `"consumption_expenditure_household"`
#' * `"consumption_expenditure_households"`
#'
#' If none of these are found, it falls back to any column name that contains
#' `"households"`.
#'
#' @examples
#' # German SIOT includes a household final consumption column
#' household_column_find(iotable_get(source = "germany_1995"))
#'
#' # Custom example
#' df <- data.frame(
#'   sector = c("A", "B"),
#'   households = c(100, 200)
#' )
#' household_column_find(df)
#'
#' @family iotables processing functions
#' @export


household_column_find <- function(data_table) {
  household_column <- NULL
  if (any(c(
    "households", "p3_s14", "final_consumption_households",
    "final_consumption_household",
    "consumption_expenditure_household", "consumption_expenditure_households"
  ) %in%
    tolower(names(data_table)))) {
    household_column <- which(tolower(names(data_table)) %in%
      c(
        "households", "p3_s14", "final_consumption_households", "final_consumption_household",
        "consumption_expenditure_household", "consumption_expenditure_households"
      ))
  } else if (any(grepl("households", tolower(names(data_table))))) {
    household_column <- which(grepl("households", tolower(names(data_table))))
  }
  household_column
}
#' @title Return Final Household Expenditure
#'
#' @description Extracts the column of final household expenditure from a
#' symmetric input-output table, a use table, or a supply table. If no
#' household expenditure column is detected, returns `NULL`.
#'
#' @param data_table A symmetric input-output table, a use table, or a
#' supply table.
#'
#' @return A tibble/data frame with the key column and the household
#' expenditure column. Returns `NULL` if no household column is found.
#'
#' @family iotables processing functions
#' @examples
#' household_column_get(iotable_get(source = "germany_1995"))
#' @export

household_column_get <- function(data_table) {
  household_column <- household_column_find(data_table)

  if (!is.null(household_column)) {
    data_table %>%
      dplyr::select(1, all_of(household_column)) %>%
      dplyr::mutate(across(2, fn_na_to_null))
  } else {
    NULL
  }
}
#' Create indirect effects
#'
#' Compute an indirect-effects vector from an input requirement indicator and
#' a Leontief inverse.
#'
#' @param input_requirements A data frame or matrix produced by
#'   [input_indicator_create()], with a key column first and numeric columns
#'   thereafter.
#' @param inverse A Leontief inverse created by
#'   [leontief_inverse_create()], with a key column first and numeric columns
#'   thereafter.
#' @param digits Integer number of decimal places for rounding. Defaults to
#'   `NULL` (no rounding).
#'
#' @return A `data.frame` containing the indirect effects and the first
#'   (key) column to allow sorting or joins with other tables.
#'
#' @examples
#' data(netherlands_2000)
#'
#' input_coeff_nl <- input_coefficient_matrix_create(
#'   data_table = netherlands_2000,
#'   households = FALSE
#' )
#'
#' compensation_indicator <- input_indicator_create(
#'   netherlands_2000, "compensation_employees"
#' )
#'
#' I_nl <- leontief_inverse_create(input_coeff_nl)
#'
#' indirect_effects_create(
#'   input_requirements = compensation_indicator,
#'   inverse = I_nl
#' )
#'
#' @export


indirect_effects_create <- function(input_requirements,
                                    inverse,
                                    digits = NULL) {
  names_direct <- names(input_requirements)
  col_n <- ncol(input_requirements)

  # columns of the left matrix must be the same as the number of rows of
  # the right matrix
  # Remove key column ------
  key_column <- subset(input_requirements, select = 1)

  new_key_column <- gsub(
    pattern = "_indicator",
    replacement = "",
    key_column[, 1]
  )

  new_key_column <- paste0(new_key_column, "_indirect_effect")
  new_key_column <- data.frame(key_colum = as.character(key_column))
  names(new_key_column)[1] <- names(input_requirements)[1]

  input_requirements_matrix <- input_requirements[, -1]
  inverse <- inverse[, -1]

  inverse <- as.matrix(inverse)
  input_requirements_matrix <- as.matrix(input_requirements_matrix)


  effects <- input_requirements_matrix %*% inverse
  multipliers <- effects
  indirect_effects <- effects

  for (i in seq_len(nrow(effects))) {
    multipliers[i, ] <- effects[i, ] / input_requirements_matrix[i, ]
    indirect_effects[i, ] <- multipliers[i, ] - effects[i, ]
  }

  if (!is.null(digits)) {
    if (digits >= 0) {
      multipliers <- round(indirect_effects, digits)
    }
  }

  cbind(new_key_column, indirect_effects)
}
#' @title Create an input coefficient matrix
#'
#' @description
#' Create an input coefficient matrix from the input flow matrix and the
#' output vector. This is a thin wrapper around
#' [coefficient_matrix_create()], with `total = "output"` and
#' `return_part = "products"`.
#'
#' @details
#' The input coefficients of production activities may be interpreted as the
#' corresponding cost shares for products and primary inputs in total output.
#' Our terminology follows the
#' \href{https://ec.europa.eu/eurostat/documents/3859598/5902113/KS-RA-07-013-EN.PDF}{Eurostat
#' Manual of Supply, Use and Input–Output Tables}. In some sources this
#' is called the *technological coefficients matrix*.
#'
#' @param data_table A symmetric input–output table, a use table,
#'   or margins/tax table retrieved by [iotable_get()].
#' @param households Logical; include the households column if available.
#'   Default `FALSE`.
#' @param digits Optional integer precision to round the resulting matrix.
#'   Default `NULL` (no rounding).
#'
#' @return
#' A `data.frame` containing the input coefficient matrix (products ×
#' products), with the key (row label) retained as the first column.
#' Any TOTAL rows/columns (`"cpa_total"`, `"total"`) are removed.
#'
#' @examples
#' cm <- input_coefficient_matrix_create(
#'   iotable_get(source = "germany_1995"),
#'   digits = 4
#' )
#' head(cm)
#'
#' # Equivalent direct call:
#' cm2 <- coefficient_matrix_create(
#'   iotable_get(source = "germany_1995"),
#'   total = "output",
#'   return_part = "products",
#'   digits = 4
#' )
#'
#' @export
input_coefficient_matrix_create <- function(data_table,
                                            households = FALSE,
                                            digits = NULL) {
  cm <- coefficient_matrix_create(
    data_table = data_table,
    total = "output",
    return_part = "products",
    households = households,
    digits = digits
  )

  potential_total_names <- c("cpa_total", "total")

  # Remove TOTAL rows and columns
  key_column <- tolower(as.character(unlist(cm[, 1])))
  remove_col <- which(potential_total_names %in% names(cm))
  remove_row <- which(key_column %in% potential_total_names)

  if (length(remove_row) > 0) cm <- cm[-remove_row, ]
  if (length(remove_col) > 0) cm <- cm[, -remove_col]

  cm
}
#' @title Create an input coefficient matrix
#'
#' @description Computes the **input (technical) coefficient matrix** from a
#'   symmetric input–output table or use table. Each element expresses the share
#'   of a product’s output used as input in another production activity.
#'
#' @details This is a wrapper around [coefficient_matrix_create()] with `total =
#'   "output"` and `return_part = "products"`. The resulting matrix \(A\)
#'   satisfies \(A_{ij} = z_{ij} / x_j\), where \(z_{ij}\) is intermediate use
#'   of product *i* by industry *j* and \(x_j\) is total output. Terminology
#'   follows the [Eurostat Manual of Supply, Use and Input–Output
#'   Tables](https://ec.europa.eu/eurostat/documents/3859598/5902113/KS-RA-07-013-EN.PDF),
#'   where this is also called the *technological coefficients matrix*.
#'
#' @param data_table A symmetric input–output or use table retrieved by
#'   [iotable_get()].
#' @param households Logical; include the household column if available. Default
#'   `FALSE`.
#' @param digits Optional integer precision for rounding the coefficients.
#'   Default `NULL` (no rounding).
#' @references
#' Beutel, J. (2008). *Eurostat Manual of Supply, Use and Input–Output Tables*.
#' Luxembourg: Office for Official Publications of the European Communities,
#' Table 15.6 (page 485). Validation against this reference confirms that
#' `input_coefficient_matrix_create()` reproduces the standard
#' Eurostat input–output coefficients for Germany 1995.
#'
#' United Nations et al. (2009). *System of National Accounts 2008*,
#' §§14.90–14.91.
#'
#' @return A `data.frame` containing the input coefficient matrix (products ×
#'   products), with the key (row label) as the first column. Rows and columns
#'   labelled `"cpa_total"` or `"total"` are removed.
#'
#' @examples
#' cm <- input_coefficient_matrix_create(
#'   iotable_get(source = "germany_1995"),
#'   digits = 4
#' )
#' head(cm)
#'
#' @export
input_coefficient_matrix_create <- function(data_table,
                                            households = FALSE,
                                            digits = NULL) {
  # --- Normalize column names (case-insensitive) ------------------------------
  names(data_table) <- tolower(names(data_table))

  alias_map <- c(
    tfu = "output",
    total = "total",
    cpa_total = "total"
  )
  for (nm in names(alias_map)) {
    if (nm %in% names(data_table) && !(alias_map[[nm]] %in% names(data_table))) {
      names(data_table)[names(data_table) == nm] <- alias_map[[nm]]
    }
  }

  # --- Handle missing total row (toy tables) ----------------------------------
  if (!any(grepl("total|cpa_total|total output", tolower(data_table[[1]])))) {
    return_part_arg <- NULL
    warning("No 'total' or 'cpa_total' row found; returning full matrix without subsetting.")
  } else {
    return_part_arg <- "products"
  }

  cm <- coefficient_matrix_create(
    data_table = data_table,
    total = "output",
    return_part = return_part_arg,
    households = households,
    digits = digits
  )

  potential_total_names <- c("cpa_total", "total")

  key_column <- tolower(as.character(unlist(cm[, 1])))
  remove_col <- which(names(cm) %in% potential_total_names)
  remove_row <- which(key_column %in% potential_total_names)

  if (length(remove_row) > 0) cm <- cm[-remove_row, , drop = FALSE]
  if (length(remove_col) > 0) cm <- cm[, -remove_col, , drop = FALSE]

  cm
}
#' Create an inter-industry (intermediate-use) matrix
#'
#' @description
#' Return the Quadrant I block (intermediate consumption) of a symmetric
#' input–output table. Optionally append the final household consumption
#' column for Type-II modelling.
#'
#' @details
#' In the Eurostat framework, the Quadrant I block shows *intermediate
#' consumption* by industry (columns) and product (rows), valued at
#' purchasers’ prices. Final household consumption belongs to the final
#' uses block (not Quadrant I); when `households = TRUE`, that column is
#' appended for convenience in Type-II analyses that endogenise private
#' consumption. See the *Eurostat Manual of Supply, Use and
#' Input-Output Tables* for the quadrant layout and definitions.
#'
#' @param data_table A symmetric input–output table (product-by-product
#'   or industry-by-industry) obtained via [iotable_get()].
#' @param households Logical. If `TRUE`, append the
#'   `final_consumption_households` column. Default `TRUE`.
#' @param empty_remove Logical. Reserved; currently ignored (no effect).
#'   Default `FALSE`.
#'
#' @return
#' A data frame with the key column and the Quadrant I block; if
#' `households = TRUE`, the household final consumption column is
#' appended.
#'
#' @seealso [input_coefficient_matrix_create()],
#'   [leontief_inverse_create()]
#'
#' @family analytic object functions
#'
#' @examples
#' # Basic extraction (Quadrant I + households column)
#' x <- input_flow_get(
#'   data_table   = iotable_get(),
#'   empty_remove = FALSE,
#'   households   = TRUE
#' )
#'
#' # Quadrant I only (no households column)
#' y <- input_flow_get(
#'   data_table   = iotable_get(),
#'   empty_remove = FALSE,
#'   households   = FALSE
#' )
#'
#' @importFrom dplyr mutate across left_join
#' @importFrom tidyselect where
#' @export

input_flow_get <- function(data_table,
                           empty_remove = FALSE,
                           households = TRUE) {
  data_table <- mutate(
    data_table,
    across(where(is.factor), as.character)
  )

  # Remove empty columns and rows
  if (empty_remove) siot <- empty_remove(data_table)

  last_column <- quadrant_separator_find(data_table)

  ## Adding households, if requested----------------------------------------
  if (households == TRUE) {
    household_column <- household_column_get(data_table)
    quadrant <- data_table[, seq_len(last_column)]
    input_flow_table <- left_join(
      quadrant, household_column,
      by = names(quadrant)[1]
    )
  } else {
    input_flow_table <- data_table[, seq_len(last_column)]
  }

  key_column <- tolower(as.character(unlist(input_flow_table[, 1])))

  last_row <- which(key_column %in% c("total", "cpa_total"))

  input_flow_table[1:last_row, ]
}
#' Create input indicator(s)
#'
#' Compute input indicators (e.g., GVA, compensation of employees) by selecting
#' specific input rows from the input-coefficient matrix.
#'
#' @details
#' Let \eqn{A} be the input-coefficient matrix (rows are inputs, columns are
#' products/industries). An *input indicator* for a given input row \eqn{r} is
#' simply the row \eqn{A_{r\cdot}}. These indicators are used in Beutel (2012)
#' and the Eurostat *Manual of Supply, Use and Input-Output Tables* (e.g.,
#' pp. 495–498) to derive effects and multipliers.
#'
#' Internally, the function builds \eqn{A} via
#' [coefficient_matrix_create()], then keeps only the requested input
#' rows and renames the key column to `*_indicator`. Optional rounding is
#' applied to numeric columns.
#'
#' @param data_table A symmetric input–output table, use table, margins, or
#'   tax table retrieved by [iotable_get()].
#' @param input_row Character vector of input row names to extract (e.g.,
#'   `"gva"`, `"compensation_employees"`). Matching is case-insensitive.
#' @param digits Integer number of decimal places for rounding. Default
#'   `NULL` (no rounding).
#' @param households Logical; include a households column if available.
#'   Default `FALSE`.
#' @param indicator_names Optional character vector of names for the returned
#'   indicators. If `NULL`, names are taken from the key column in the selected
#'   rows of the coefficient matrix and suffixed with `"_indicator"`.
#'
#' @return A `data.frame` whose first column is a key, followed by the selected
#'   input-indicator rows as numeric columns.
#'
#' @family indicator functions
#'
#' #' @references
#' Beutel, J. (2008).
#' *Eurostat Manual of Supply, Use and Input–Output Tables.*
#' Luxembourg: Office for Official Publications of the
#' European Communities.
#'
#' Validation examples:
#' – pp. 495–498: Input indicators (GVA, compensation of employees)
#'
#' Results reproduced by `input_indicator_create()` using
#' `iotable_get(source = "germany_1995")`.
#'
#' @examples
#' input_indicator_create(
#'   data_table = iotable_get(),
#'   input_row = c("gva", "compensation_employees"),
#'   digits = 4,
#'   indicator_names = c("GVA indicator", "Income indicator")
#' )
#'
#' # Beutel/Eurostat example: GVA indicator (cf. Manual, ~p. 498)
#' ii <- input_indicator_create(
#'   data_table = iotable_get(),
#'   input_row = "gva",
#'   digits = 4
#' )
#' head(ii)
#'
#' @export
input_indicator_create <- function(data_table,
                                   input_row = c(
                                     "gva_bp",
                                     "net_tax_production"
                                   ),
                                   digits = NULL,
                                   households = FALSE,
                                   indicator_names = NULL) {
  data_table <- data_table %>%
    mutate(across(where(is.factor), as.character))

  cm <- coefficient_matrix_create(
    data_table = data_table,
    households = households
  )

  key_column <- tolower(as.character(unlist(cm[, 1])))

  inputs_present <- which(key_column %in% tolower(input_row))

  if (length(inputs_present) == 0) {
    stop("The inputs were not found")
  } else if (length(inputs_present) < length(input_row)) {
    not_found <- chars_collapse(input_row[!input_row %in% key_column[inputs_present]])
    input_msg <- chars_collapse(input_row)
    warning(glue::glue("In input_indicator_create(data_table, input_row = {input_msg}) the rows {not_found} were not found in the data_table."))
  }

  input_matrix <- cm[inputs_present, ]

  final_names <- NULL

  if (!is.null(indicator_names)) {
    # adding custom names, if inputed
    if (length(indicator_names) == nrow(input_matrix)) {
      final_names <- indicator_names
    } else {
      warning("The number of new indicator names is different from indicators,
                default names are used")
    }
  }

  if (is.null(final_names)) { # creating default names
    final_names <- paste0(
      as.character(unlist(input_matrix[, 1])),
      "_indicator"
    )
  }

  input_matrix[, 1] <- final_names

  if (!is.null(digits)) {
    matrix_round(input_matrix, digits)
  } else {
    input_matrix
  }
}
#' @title Create input multipliers
#'
#' @description The function creates the multipliers (direct + indirect effects).
#' @param input_requirements A matrix or vector created by
#' \code{\link{input_indicator_create}}
#' @param Im A Leontief-inverse created by \code{\link{leontief_inverse_create}}.
#' @param multiplier_name An optional name to be placed in the key column of the multiplier.
#' Defaults to \code{NULL}.
#' @param digits Rounding digits, defaults to \code{NULL}, in which case
#' no rounding takes place. Rounding is important if you replicate examples from the literature,
#' rounding differences can add up to visible differences in matrix equations.
#' @importFrom dplyr select mutate across

#' @return A data frame with the vector of multipliers and the an
#' auxiliary metadata column, containing an automatically given row identifier (for joining with other matrixes)
#' which can be  overruled with setting \code{multiplier_name}.
#' @family multiplier functions
#' @examples
#' nl <- netherlands_2000
#'
#' input_coeff_nl <- input_coefficient_matrix_create(
#'   data_table = netherlands_2000,
#'   households = FALSE
#' )
#'
#' compensation_indicator <- input_indicator_create(netherlands_2000, "compensation_employees")
#'
#' I_nl <- leontief_inverse_create(input_coeff_nl)
#'
#' input_multipliers_create(
#'   input_requirements = compensation_indicator,
#'   Im = I_nl
#' )
#' @export

input_multipliers_create <- function(input_requirements,
                                     Im,
                                     multiplier_name = NULL,
                                     digits = NULL) {
  names_direct <- names(input_requirements)


  if (is.null(multiplier_name)) {
    multiplier_name <- gsub(
      "_coefficients|_coefficient|_effect",
      "_multiplier",
      unlist(input_requirements[1])
    )
  }


  new_key_column <- key_column_create(names(Im)[1], multiplier_name)


  col_n <- ncol(input_requirements)

  # columns of the left matrix must be the same as the number of rows of
  # the right matrix
  # Remove key column------
  key_column <- subset(input_requirements, select = 1)
  input_requirements_matrix <- input_requirements[, -1]
  inverse <- Im[, -1]

  if (!all(names(input_requirements_matrix) %in% names(inverse))) {
    mismatch_1 <- names(input_requirements_matrix)[which(!names(input_requirements_matrix) %in% names(inverse))]
    mismatch_2 <- names(inverse)[which(!names(inverse) %in% names(input_requirements_matrix))]
    stop(
      "input_multipliers_create() error. Non-conforming matrixes: ", paste0(mismatch_1, mismatch_2),
      " is not present in both input_requirements and Im."
    )
  }

  inverse <- as.matrix(inverse)
  input_requirements_matrix <- as.matrix(input_requirements_matrix)


  effects <- input_requirements_matrix %*% inverse
  multipliers <- effects

  for (i in seq_len(nrow(effects))) {
    multipliers[i, ] <- effects[i, ] / input_requirements_matrix[i, ]
  }

  ## Rounding is important when you compare with peer-reviewed literature sources.
  ## You want the same rounding to be able to replicate the results.

  if (!is.null(digits)) {
    if (digits >= 0) {
      multipliers <- round(multipliers, digits)
    }
  }

  cbind(new_key_column, multipliers)
}
#' Get a single input–output table from built-in datasets
#'
#' @description
#' Filter and reshape one IO/SUT table from a bulk dataset (typically a
#' Eurostat download). In most workflows you will call this function
#' rather than [iotables_download()], which it invokes as needed.
#'
#' @note
#' This is a wrapper around the
#' legacy getter function now only used for built-in datasets.
#'
#' @details
#' The Eurostat bulk tables arrive in long form and are not ordered for
#' matrix algebra. This function selects the requested country (`geo`),
#' year, unit and stock/flow (`stk_flow`), joins iotables metadata for
#' consistent row/column labelling, and returns a **wide** table ready
#' for analysis.
#'
#' Supported sources include:
#'
#' - `naio_10_cp1700` — symmetric IO, basic prices (prod × prod)
#' - `naio_10_pyp1700` — previous years' prices
#' - `naio_10_cp1750` — symmetric IO, basic prices (ind × ind)
#' - `naio_10_pyp1750` — previous years' prices
#' - `naio_10_cp15` — supply at basic prices incl. margins/taxes
#' - `naio_10_cp16` — use at purchasers' prices
#' - `naio_10_cp1610` — use at basic prices
#' - `naio_10_cp1620` — trade & transport margins (basic prices)
#' - `naio_10_cp1630` — taxes less subsidies on products (basic prices)
#' - `naio_10_pyp*` — corresponding previous years' prices variants
#' - `germany_1995` — packaged Beutel example
#' - `croatia_2010_1700/1800/1900` — packaged examples
#' - `uk_2010_*` — packaged UK 2010 variants
#'
#' @param labelled_io_data Optional nested bulk data as returned by
#'   [iotables_download()]. If `NULL` (default), data are retrieved from
#'   cache or downloaded.
#' @param source Data source code (see list above).
#' @param geo Country code or name, e.g. `"SK"` or `"Slovakia"`.
#' @param year Numeric year. Defaults to `1990` for `germany_1995`.
#' @param unit Currency unit, usually `"MIO_NAC"` or `"MIO_EUR"`.
#' @param stk_flow Stock/flow: `"DOM"`, `"IMP"`, or `"TOTAL"`. For
#'   margins/taxes (`cp1620`, `cp1630` and `pyp` variants) only `"TOTAL"`
#'   is used; other inputs are coerced with a warning.
#' @param labelling Column naming scheme: `"iotables"` (default) for
#'   consistent names; `"short"` for original short codes; `"eurostat"`
#'   is treated as `"short"`.
#' @param data_directory Optional directory to save the processed wide
#'   table (RDS). If `NULL`, nothing is saved.
#' @param force_download Logical. If `TRUE`, force a fresh download when
#'   `labelled_io_data` is not supplied. Defaults to `TRUE`.
#'
#' @return
#' A **wide** `data.frame` representing the selected IO table, with a key
#' column followed by ordered numeric columns.
#'
#' @family iotables import functions
#'
#' @examples
#' germany_table <- iotable_get(
#'   source = "germany_1995",
#'   geo = "DE", year = 1990, unit = "MIO_EUR",
#'   labelling = "iotables"
#' )
#'
#' @importFrom magrittr %>%
#' @importFrom dplyr filter select mutate rename left_join arrange
#' @importFrom dplyr across
#' @importFrom tidyselect any_of all_of where
#' @importFrom tidyr spread pivot_wider
#' @importFrom forcats fct_reorder
#' @importFrom lubridate year
#' @importFrom utils data
#' @export
iotable_get <- function(
    labelled_io_data = NULL,
    source = "germany_1995",
    geo = "DE",
    year = 1990,
    unit = "MIO_EUR",
    stk_flow = "DOM",
    labelling = "iotables",
    data_directory = NULL,
    force_download = TRUE) {
  # Built-in datasets (legacy branch)
  builtin_sources <- c(
    "germany_1995",
    "croatia_2010_1700", "croatia_2010_1800", "croatia_2010_1900",
    "uk_2010_siot", "uk_2010_coeff", "uk_2010_inverse"
  )

  # Switch
  if (source %in% builtin_sources) {
    # Using legacy iotable_get() now called iotable_get_builtin()
    return(iotable_get_builtin(
      labelled_io_data = labelled_io_data,
      source = source,
      geo = geo,
      year = year,
      unit = unit,
      stk_flow = stk_flow,
      labelling = labelling,
      data_directory = data_directory,
      force_download = force_download
    ))
  } else {
    # Wrapper around iotable_get_eurostat()
    return(iotable_get_eurostat(
      labelled_io_data = labelled_io_data,
      source = source,
      geo = geo,
      year = year,
      unit = unit,
      stk_flow = stk_flow,
      labelling = labelling,
      data_directory = data_directory,
      force_download = force_download
    ))
  }
}
#' Get a single input–output table from built-in datasets
#'
#' @description
#' Filter and reshape one IO/SUT table from a bulk dataset.
#'
#' @note
#' This is a legacy downloader that handles Eurostat datasets, too,
#' but with inefficient cache management.
#'
#' @details
#' The Eurostat bulk tables arrive in long form and are not ordered for
#' matrix algebra. This function selects the requested country (`geo`),
#' year, unit and stock/flow (`stk_flow`), joins iotables metadata for
#' consistent row/column labelling, and returns a **wide** table ready
#' for analysis.
#'
#' Supported sources include:
#'
#' - `naio_10_cp1700` — symmetric IO, basic prices (prod × prod)
#' - `naio_10_pyp1700` — previous years' prices
#' - `naio_10_cp1750` — symmetric IO, basic prices (ind × ind)
#' - `naio_10_pyp1750` — previous years' prices
#' - `naio_10_cp15` — supply at basic prices incl. margins/taxes
#' - `naio_10_cp16` — use at purchasers' prices
#' - `naio_10_cp1610` — use at basic prices
#' - `naio_10_cp1620` — trade & transport margins (basic prices)
#' - `naio_10_cp1630` — taxes less subsidies on products (basic prices)
#' - `naio_10_pyp*` — corresponding previous years' prices variants
#' - `germany_1995` — packaged Beutel example
#' - `croatia_2010_1700/1800/1900` — packaged examples
#' - `uk_2010_*` — packaged UK 2010 variants
#'
#' @param labelled_io_data Optional nested bulk data as returned by
#'   [iotables_download()]. If `NULL` (default), data are retrieved from
#'   cache or downloaded.
#' @param source Data source code (see list above).
#' @param geo Country code or name, e.g. `"SK"` or `"Slovakia"`.
#' @param year Numeric year. Defaults to `1990` for `germany_1995`.
#' @param unit Currency unit, usually `"MIO_NAC"` or `"MIO_EUR"`.
#' @param stk_flow Stock/flow: `"DOM"`, `"IMP"`, or `"TOTAL"`. For
#'   margins/taxes (`cp1620`, `cp1630` and `pyp` variants) only `"TOTAL"`
#'   is used; other inputs are coerced with a warning.
#' @param labelling Column naming scheme: `"iotables"` (default) for
#'   consistent names; `"short"` for original short codes; `"eurostat"`
#'   is treated as `"short"`.
#' @param data_directory Optional directory to save the processed wide
#'   table (RDS). If `NULL`, nothing is saved.
#' @param force_download Logical. If `TRUE`, force a fresh download when
#'   `labelled_io_data` is not supplied. Defaults to `TRUE`.
#'
#' @return
#' A **wide** `data.frame` representing the selected IO table, with a key
#' column followed by ordered numeric columns.
#'
#' @family iotables import functions
#'
#' @examples
#' germany_table <- iotable_get(
#'   source = "germany_1995",
#'   geo = "DE", year = 1990, unit = "MIO_EUR",
#'   labelling = "iotables"
#' )
#'
#' @importFrom magrittr %>%
#' @importFrom dplyr filter select mutate rename left_join arrange
#' @importFrom dplyr across
#' @importFrom tidyselect any_of all_of where
#' @importFrom tidyr spread pivot_wider
#' @importFrom forcats fct_reorder
#' @importFrom lubridate year
#' @importFrom utils data
#' @export

iotable_get_builtin <- function(
    labelled_io_data = NULL,
    source = "germany_1995",
    geo = "DE",
    year = 1990,
    unit = "MIO_EUR",
    stk_flow = "DOM",
    labelling = "iotables",
    data_directory = NULL,
    force_download = TRUE) {
  if (labelling == "eurostat") labelling <- "short"

  ## Parameter exception handling -------------------------------------
  if (is.null(source)) {
    stop("Parameter 'source' is a mandatory input.")
  }

  if (is.null(labelled_io_data) & is.null(geo)) stop("The 'geo' parameter must be a valid Eurostat 'geo' code")
  if (is.null(labelled_io_data) & !source %in% c(
    "germany_1995",
    "uk_2010",
    "croatia_2010_1900",
    "croatia_2010_1800",
    "croatia_2010_1700"
  )) {
    validate_source(source)
  }

  ## Exception handling for tax and margin tables -----------------------
  if (source %in% c(
    "naio_10_cp1620", "naio_10_cp1630",
    "naio_10_pyp1620", "naio_10_pyp1630"
  )
  ) {
    stk_flow_input <- "TOTAL" # tax and margin tables only have one version
  }

  uk_tables <- c("uk_2010_siot", "uk_2010_coeff", "uk_2010_inverse")

  ## Veryfing source parameter and loading the labelling  -----------
  prod_ind <- c(
    "naio_10_cp1700", "naio_10_cp1750", "naio_10_pyp1700",
    "naio_10_pyp1750", "naio_10_cp15", "naio_10_cp16",
    "naio_10_cp1610", "naio_10_cp1620", "naio_10_cp1630",
    "naio_10_pyp1620", "naio_10_pyp1630", "germany_1995"
  )

  trow_tcol <- croatia_files <- c(
    "croatia_2010_1700", "croatia_2010_1800",
    "croatia_2010_1900"
  )

  if (source %in% prod_ind) {
    metadata_rows <- getdata(metadata) %>% # tables that follow prod_ind vocabulary
      dplyr::filter(variable == "prod_na") %>%
      dplyr::rename(prod_na = code) %>%
      dplyr::rename(prod_na_lab = label) %>%
      dplyr::rename(row_order = numeric_label) %>%
      dplyr::rename(iotables_row = iotables_label)

    metadata_cols <- getdata(metadata) %>%
      dplyr::filter(variable == "induse") %>%
      dplyr::rename(induse = code) %>%
      dplyr::rename(induse_lab = label) %>%
      dplyr::rename(col_order = numeric_label) %>%
      dplyr::rename(iotables_col = iotables_label)

    if (source == "germany_1995") {
      year <- 1990
      geo <- "DE"
      unit <- "MIO_EUR"
      source <- "germany_1995"
    }

    year_input <- year
    geo_input <- geo
    unit_input <- unit
    source_inputed <- source
  } else if (source %in% trow_tcol) { # tables that follow trow_tcol vocabulary

    metadata <- getdata(metadata)

    metadata_rows <- metadata %>%
      dplyr::filter(variable == "t_rows") %>%
      dplyr::rename(t_rows2 = code) %>%
      dplyr::rename(t_rows2_lab = label) %>%
      dplyr::rename(row_order = numeric_label) %>%
      dplyr::rename(iotables_row = iotables_label)

    metadata_cols <- metadata %>%
      dplyr::filter(variable == "t_cols") %>%
      dplyr::rename(t_cols2 = code) %>%
      dplyr::rename(t_cols2_lab = label) %>%
      dplyr::rename(col_order = numeric_label) %>%
      dplyr::rename(iotables_col = iotables_label)

    year_input <- year
    geo_input <- geo
    unit_input <- unit
    source_inputed <- source
  } else if (source %in% uk_tables) {
    labelling <- "short"
    year <- year_input <- 2010
    unit <- unit_input <- "MIO_NAC"
    geo <- geo_input <- "UK"
    stk_flow <- stk_flow_input <- "TOTAL"

    metadata_uk_2010 <- getdata(metadata_uk_2010)

    metadata_cols <- metadata_uk_2010 %>%
      dplyr::filter(!is.na(uk_col)) %>%
      dplyr::select(-uk_row, -uk_row_label, -prod_na, -row_order) %>%
      mutate(uk_col = gsub("\\.", "-", as.character(uk_col))) %>%
      mutate(uk_col = gsub(" & ", "-", as.character(uk_col))) %>%
      mutate(uk_col = trimws(uk_col, "both"))

    metadata_rows <- metadata_uk_2010 %>%
      filter(!is.na(uk_row)) %>%
      select(-all_of(c("uk_col", "uk_col_label", "induse", "col_order"))) %>%
      mutate(uk_row = gsub("\\.", "-", as.character(uk_row))) %>%
      mutate(uk_row = gsub(" & ", "-", as.character(uk_row)))

    prod_ind <- c(prod_ind, uk_tables)
  } else {
    stop("This type of input-output database is not (yet) recognized by iotables.")
  }

  metadata_rows <- dplyr::mutate(
    metadata_rows,
    dplyr::across(tidyselect::where(is.factor), as.character)
  )

  metadata_cols <- dplyr::mutate(
    metadata_cols,
    dplyr::across(tidyselect::where(is.factor), as.character)
  )

  ### Exception handling for wrong paramters that are not directly inputed-----
  if (is.null(labelled_io_data)) { # if not directly inputed data
    if (is.null(geo)) stop("Error: no country selected.")
    if (!labelling %in% c("iotables", "short")) {
      stop("Only iotables or original short columns can be selected.")
    }

    if (!unit %in% c("MIO_NAC", "MIO_EUR", "T_NAC")) {
      stop("Currency unit must be MIO_NAC, MIO_EUR or T_NAC")
    }

    if (source %in% c("naio_10_cp1620", "naio_10_cp1630")) {
      if (stk_flow != "TOTAL") {
        stk_flow_input <- "TOTAL"
        warning("The parameter stk_flow was changed to TOTAL.")
      }
    }

    ## Creating a temporary file name for the input-output table ----
    tmp_rds <- file.path(tempdir(), paste0(source, "_", labelling, ".rds"))

    ## Read from file or internal dataset ----
    if (source_inputed == "germany_1995") {
      germany_1995 <- getdata("germany_1995")
      labelled_io_data <- germany_1995 # use germany example
      labelled_io_data$year <- 1990
    } else if (source_inputed == "croatia_2010_1700") {
      croatia_2010_1700 <- getdata(croatia_2010_1700)
      labelled_io_data <- croatia_2010_1700 %>%
        mutate(year = lubridate::year(time))
    } else if (source_inputed == "croatia_2010_1800") {
      croatia_2010_1800 <- getdata(croatia_2010_1800)
      labelled_io_data <- croatia_2010_1800 %>%
        mutate(year = lubridate::year(time))
    } else if (source_inputed == "croatia_2010_1900") {
      croatia_2010_1900 <- getdata(croatia_2010_1900)
      labelled_io_data <- croatia_2010_1900 %>%
        mutate(year = lubridate::year(time))
    } else {
      if (tmp_rds %in% list.files(path = tempdir())) {
        labelled_io_data <- readRDS(tmp_rds)
      } else { # getting or downloading the bulk long-form data
        labelled_io_data <- iotables_download(source,
          data_directory = data_directory,
          force_download = force_download
        )
      }
    } # use eurostat files
  } # end of possible downloads or data retrieval if not directly inputed

  ### Exception handling for UK test data ---------------------------
  if (source %in% uk_tables) {
    if (source == "uk_2010_siot") {
      labelled_io_data <- labelled_io_data %>%
        dplyr::filter(indicator == "Input-Output table (domestic use, basic prices, product by product)")
    }

    if (source == "uk_2010_use") {
      labelled_io_data <- labelled_io_data %>%
        dplyr::filter(indicator == "Domestic use table at basic prices (product by industry)")
    }

    if (source == "uk_2010_imports") {
      labelled_io_data <- labelled_io_data %>%
        dplyr::filter(indicator == "Imports use table at basic prices (product by product)")
    }

    if (source == "uk_2010_coeff") {
      labelled_io_data <- labelled_io_data %>%
        dplyr::filter(indicator == "Matrix of coefficients (product by product)")
    }

    if (source == "uk_2010_inverse") {
      labelled_io_data <- labelled_io_data %>%
        dplyr::filter(indicator == "Leontief Inverse (product by product)")
    }
  }

  ## Verifying parameters ----
  year_input <- year
  source_inputed <- source
  unit_input <- unit
  stk_flow_input <- stk_flow
  geo_input <- geo

  if (nchar(geo_input) == 2 & geo_input == tolower(geo_input)) {
    geo_input <- toupper(geo_input)
    warning("Warning: country code changed to upper case.")
  }

  if (!unit_input %in% labelled_io_data$unit) {
    stop("This currency unit is not found in the raw data frame.")
  }

  if (!geo_input %in% labelled_io_data$geo) {
    stop("This currency unit is not found in the raw data frame.")
  }

  if (!year_input %in% labelled_io_data$year) {
    stop("This year is not found in the raw data frame.")
  }


  ## Selecting table from nested data, if nested at all ---------------

  if (!source %in% c(
    "croatia_2010_1700", "croatia_2010_1800",
    "croatia_2010_1900",
    "germany_1995", uk_tables
  )) {
    selected_table <- which( ## get the number of table to be selected
      labelled_io_data$year == year &
        as.character(labelled_io_data$geo) == geo &
        labelled_io_data$unit == unit
    )

    if (length(selected_table) == 0) {
      stop(paste0(
        "There is no available table for country ", geo_input,
        " in the year ", year,
        " with ", unit_input, " units."
      ))
    } else if (length(selected_table) == 3) {
      selected_table <- which( ## get the number of table to be selected
        labelled_io_data$year == year &
          as.character(labelled_io_data$geo) == geo &
          labelled_io_data$unit == unit &
          labelled_io_data$stk_flow == stk_flow_input
      )
    }

    if (length(selected_table) != 1) {
      stop(
        "The parameters geo=", geo, "; unit=", unit_input,
        "; stk_flow=", stk_flow_input,
        "\ndo not select a unique table."
      )
    }

    iotable <- labelled_io_data$data[[selected_table]] ## the relevant io table data in long form
  } else { # if data is not nested
    iotable <- labelled_io_data
  }

  ## Converting factors to numbers --------------------------------------
  if (class(iotable$values) %in% c("character", "factor")) {
    iotable$values <- trimws(as.character(iotable$values), which = "both")
    iotable$values <- as.numeric(iotable$values)
    message("Warning: original data was converted to numeric format.")
  }

  ## Get and order the SIOT-------
  if (source %in% prod_ind) {
    col_join <- names(iotable)[which(names(iotable) %in% c("induse", "induse_lab", "iotables_col", "uk_col"))]
    row_join <- names(iotable)[which(names(iotable) %in% c("prod_na", "prod_na_lab", "iotables_row", "uk_row"))]

    remove_vars <- c(
      "quadrant", "account_group", "variable",
      "group", "eu_prod_na"
    )
    remove_vars <- remove_vars[remove_vars %in% names(metadata_cols)]

    iotable_labelled <- iotable %>%
      dplyr::filter(stk_flow == stk_flow_input) %>%
      dplyr::mutate(dplyr::across(tidyselect::where(is.factor), as.character)) %>%
      dplyr::left_join(metadata_cols, by = col_join) %>%
      dplyr::select(-tidyselect::any_of(remove_vars)) %>% # remove repeating columns before joining rows
      dplyr::mutate(dplyr::across(tidyselect::where(is.factor), as.character)) %>%
      dplyr::left_join(metadata_rows, by = row_join)

    if (nrow(iotable_labelled) == 0) {
      stop(
        "No rows found with geo = ", geo_input, " year = ", year,
        " unit = ", unit, " and stk_flow = ", stk_flow_input, "."
      )
    }

    iotable_labelled <- iotable_labelled %>%
      dplyr::mutate(prod_na = forcats::fct_reorder(
        prod_na,
        as.numeric(row_order)
      )) %>%
      dplyr::mutate(induse = forcats::fct_reorder(
        induse,
        as.numeric(col_order)
      ))

    if (all(c("iotables_row", "iotables_col") %in% names(iotable_labelled))) {
      iotable_labelled <- iotable_labelled %>%
        dplyr::mutate(iotables_row = forcats::fct_reorder(
          iotables_row,
          as.numeric(row_order)
        )) %>%
        dplyr::mutate(iotables_col = forcats::fct_reorder(
          iotables_col,
          as.numeric(col_order)
        ))
    }
  } else {
    if (!source %in% croatia_files) { # !prod_ind

      by_col <- names(iotable)[which(names(iotable) %in% c("t_cols2", "t_cols2_lab", "iotables_col"))]
      by_row <- names(iotable)[which(names(iotable) %in% c("t_rows2", "t_rows2_lab", "iotables_row"))]

      iotable_labelled <- iotable %>%
        dplyr::mutate(dplyr::across(tidyselect::where(is.factor), as.character)) %>%
        left_join(metadata_cols, by = by_col) %>%
        left_join(metadata_rows, by = by_row) %>%
        arrange(row_order, col_order)
    } else {
      iotable_labelled <- iotable
    }
    iotable_labelled <- iotable_labelled %>%
      dplyr::mutate(t_rows2 = forcats::fct_reorder(
        t_rows2,
        as.numeric(row_order)
      )) %>%
      dplyr::mutate(t_cols2 = forcats::fct_reorder(
        t_cols2,
        as.numeric(col_order)
      )) %>%
      dplyr::mutate(iotables_row = forcats::fct_reorder(
        iotables_row,
        as.numeric(row_order)
      )) %>%
      dplyr::mutate(iotables_col = forcats::fct_reorder(
        iotables_col,
        as.numeric(col_order)
      ))
  } # end of not prod_na cases

  if (labelling == "iotables") {
    iotable_labelled_w <- iotable_labelled %>%
      dplyr::arrange(iotables_row, iotables_col) %>%
      dplyr::select(all_of(c("iotables_col", "iotables_row", "values"))) %>%
      tidyr::spread(iotables_col, values)
  } else if (labelling == "short" & source %in% prod_ind) {
    iotable_labelled_w <- iotable_labelled %>%
      dplyr::select(prod_na, induse, values) %>%
      dplyr::filter(!is.na(prod_na)) %>%
      tidyr::spread(induse, values)
  } else {
    iotable_labelled_w <- iotable_labelled %>%
      dplyr::select(all_of(c("t_rows2", "t_cols2", "values"))) %>%
      tidyr::spread(t_cols2, values)
  }

  if (!is.null(data_directory)) {
    save_file_name <- paste0(
      geo, "_", year, "_",
      source, "_", stk_flow, "_", unit,
      ".rds"
    )
    save_file_name <- file.path(data_directory, save_file_name)
    message("Saving ", save_file_name, ".")
    saveRDS(iotable_labelled_w, save_file_name, version = 2)
  }

  iotable_labelled_w
}
#' Get a single Eurostat input–output table
#'
#' @description
#' Filters and reshapes one IO/SUT table from a bulk Eurostat dataset.
#' This version excludes all built-in datasets
#' (e.g. Germany 1995, Croatia 2010, UK 2010) which are retrieved with
#' the [iotable_get()] function.
#'
#' @details
#' The Eurostat bulk tables arrive in long form and are not ordered for
#' matrix algebra. This function selects the requested country (`geo`),
#' year, unit and stock/flow (`stk_flow`), joins iotables metadata for
#' consistent row/column labelling, and returns a **wide** table ready
#' for analysis.
#'
#' @inheritParams iotable_get
#' @importFrom forcats fct_reorder
#' @importFrom utils packageVersion
#' @importFrom glue glue
#' @importFrom dplyr rename transmute left_join distinct filter
#' @importFrom tidyr pivot_wider
#' @return
#' A **wide** `data.frame` representing the selected IO table.
#' @export
iotable_get_eurostat <- function(
    source = "naio_10_cp1700",
    geo = "IT",
    year = 2022,
    unit = "MIO_EUR",
    stk_flow = "TOTAL",
    labelling = "iotables",
    data_directory = NULL,
    force_download = TRUE,
    labelled_io_data = NULL) {
  if (labelling == "eurostat") labelling <- "short"

  # --- Validation ------------------------------------------------------------
  if (is.null(source)) stop("Parameter 'source' is mandatory.")
  if (is.null(labelled_io_data) & is.null(geo)) {
    stop("The 'geo' parameter must be a valid Eurostat 'geo' code")
  }

  validate_source(source)

  if (source %in% c(
    "naio_10_cp1620", "naio_10_cp1630",
    "naio_10_pyp1620", "naio_10_pyp1630"
  )) {
    stk_flow <- "TOTAL"
  }

  # --- Download --------------------------------------------------------------
  if (is.null(labelled_io_data)) {
    io_filters <- list(
      geo = geo,
      stk_flow = stk_flow,
      unit = unit
    )

    labelled_io_table <- get_eurostat_filtered(
      id = source,
      filter = io_filters
    )
    if (!is.null(year)) {
      labelled_io_table <- labelled_io_table[labelled_io_table$year == year, ]
      if (length(labelled_io_table) == 0) {
        err_msg <- glue::glue("No data available in source='{source}' for the year='{year}'.")
        stop(err_msg)
      }
    }
  }

  message("Retrieved dataset from Eurostat.")

  # --- Locate table ----------------------------------------------------------

  if (!is.null(labelled_io_data)) {
    selected_table <- which(
      tolower(labelled_io_data$geo) == toupper(geo) &
        labelled_io_data$year == as.numeric(year) &
        toupper(labelled_io_data$unit) == toupper(unit) &
        toupper(labelled_io_data$stk_flow) == toupper(stk_flow)
    )
    if (length(selected_table) == 0) {
      stop("No matching table found for geo/year/unit/stk_flow.")
    }
    iotable <- labelled_io_data$data[[selected_table]]
  } else {
    iotable <- labelled_io_table
  }

  # --- Establish the type of SIOT -----------------------------------

  structure_type <- NA_character_
  row_voc <- col_voc <- NA_character_

  row_vars <- c("prod_na", "prd_ava", "ind_ava", "primary_inputs")
  col_vars <- c("induse", "prd_use", "ind_use", "final_use")

  if (all(c("prd_ava", "prd_use") %in% names(iotable))) {
    structure_type <- "product_product"

    row_voc <- row_vars[which(row_vars %in% names(iotable))]
    col_voc <- col_vars[which(col_vars %in% names(iotable))]

    row_vocab <- getdata(row_voc)
    col_vocab <- getdata(col_voc)

    row_mismatch <- unique(iotable$prd_ava)[
      which(!unique(iotable$prd_ava) %in% unique(row_vocab$id))
    ]

    col_mismatch <- unique(iotable$prd_use)[
      which(!unique(iotable$prd_use) %in% unique(col_vocab$id))
    ]

    assertthat::assert_that(
      length(row_mismatch) == 0,
      msg = glue::glue(
        "Mismatch of row name vocabulary in '{source}' geo={geo} year={year}"
      )
    )

    assertthat::assert_that(
      length(col_mismatch) == 0,
      msg = glue::glue(
        "Mismatch of col name vocabulary in '{source}' geo={geo} year={year}"
      )
    )

    iotable <- iotable %>%
      dplyr::rename(
        prod_na     = prd_ava, # rows
        induse      = prd_use, # columns
      )

    if ("prod_ava_lab" %in% names(iotable)) {
      iotable <- rename(iotable, prod_na_lab = prd_ava_lab)
    } else {
      iotable$prod_na_lab <- NA_character_
    }

    if ("induse_lab" %in% names(iotable)) {
      iotable <- rename(iotable, induse_lab = prd_use_lab)
    } else {
      iotable$induse_lab <- NA_character_
    }
    message("Detected product × product (CPA) structure.")
  }

  if (all(c("ind_ava", "ind_use") %in% names(iotable))) {
    structure_type <- "industry_industry"

    row_voc <- row_vars[which(row_vars %in% names(iotable))]
    col_voc <- col_vars[which(col_vars %in% names(iotable))]

    row_vocab <- getdata(row_voc)
    col_vocab <- getdata(col_voc)

    row_mismatch <- unique(iotable$ind_ava)[
      which(!unique(iotable$ind_ava) %in% unique(row_vocab$id))
    ]

    col_mismatch <- unique(iotable$ind_use)[
      unique(iotable$ind_use)[which(!unique(iotable$ind_use) %in% unique(col_vocab$id))]
    ]

    assertthat::assert_that(
      length(row_mismatch) == 0,
      msg = glue::glue(
        "Mismatch of row name vocabulary in '{source}' geo={geo} year={year}"
      )
    )

    assertthat::assert_that(
      length(col_mismatch) == 0,
      msg = glue::glue(
        "Mismatch of col name vocabulary in '{source}' geo={geo} year={year}"
      )
    )

    iotable <- iotable %>%
      dplyr::rename(
        prod_na     = ind_ava, # rows
        induse      = ind_use, # columns
      )

    if ("ind_ava_lab" %in% names(iotable)) {
      iotable <- rename(iotable, prod_na_lab = ind_ava_lab)
    } else {
      prod_na_lab <- NA_character_
    }

    if ("induse_lab" %in% names(iotable)) {
      iotable <- rename(iotable, induse_lab = ind_use_lab)
    } else {
      induse_lab <- NA_character_
    }

    message("Detected industry × industry (NACE) structure.")
  }

  if (is.na(structure_type)) {
    review <- glue::glue(
      "https://ec.europa.eu/eurostat/databrowser/view/",
      source, "/default/"
    )
    stop(
      "The data received from\n", review,
      "\ndo not align with the expected metadata or structure."
    )
  }

  # --- Ensure numeric -------------------------------------------------------
  if (is.character(iotable$values) || is.factor(iotable$values)) {
    iotable$values <- as.numeric(trimws(as.character(iotable$values)))
  }

  # --- Load metadata  ------------------------------------------------
  # Dynamically choose which vocabularies to use for rows and columns
  metadata_row <- getdata(row_voc)
  metadata_col <- getdata(col_voc)

  meta_rows <- metadata_row %>%
    dplyr::transmute(
      prod_na = as.character(id),
      prod_na_lab_ref = as.character(label),
      row_order = numeric_order,
      iotables_row = as.character(iotables_label)
    ) %>%
    dplyr::distinct(prod_na, .keep_all = TRUE)

  meta_cols <- metadata_col %>%
    dplyr::transmute(
      induse = as.character(id),
      induse_lab_ref = as.character(label),
      col_order = numeric_order,
      iotables_col = as.character(iotables_label)
    ) %>%
    dplyr::distinct(induse, .keep_all = TRUE)

  # --- Join metadata ---------------------------------------------------------
  iotable_labelled <- iotable %>%
    dplyr::left_join(meta_cols, by = "induse") %>%
    dplyr::left_join(meta_rows, by = "prod_na")

  unlabelled_col <- iotable_labelled %>%
    dplyr::filter(is.na(col_order)) %>%
    dplyr::filter(!is.na(values))

  if (nrow(unlabelled_col) > 0) {
    warning(glue::glue(
      "There are unidentified cells in '{source}' geo='{geo}' year='{year}'"
    ))
  }

  if (nrow(iotable_labelled) == 0) {
    stop("No matching rows after metadata join.")
  }

  # --- Reorder factors -------------------------------------------------------
  if (!is.null(iotable_labelled$row_order)) {
    # reorder for iotables labelling ------------------
    iotable_labelled$iotables_row <- forcats::fct_reorder(
      iotable_labelled$iotables_row,
      as.numeric(iotable_labelled$row_order),
      .na_rm = TRUE
    )
  }

  if (!is.null(iotable_labelled$row_order)) {
    # reorder for eurostat short code labelling -----
    iotable_labelled$prod_na <- forcats::fct_reorder(
      iotable_labelled$prod_na,
      as.numeric(iotable_labelled$row_order),
      .na_rm = TRUE
    )
  }

  if (!is.null(iotable_labelled$col_order)) {
    # reorder for iotables labelling ----------------
    iotable_labelled$iotables_col <- forcats::fct_reorder(
      iotable_labelled$iotables_col,
      as.numeric(iotable_labelled$col_order),
      .na_rm = TRUE
    )
  }

  if (!is.null(iotable_labelled$col_order)) {
    # reorder for eurostat short code labelling -----
    iotable_labelled$induse <- forcats::fct_reorder(
      iotable_labelled$induse,
      as.numeric(iotable_labelled$col_order),
      .na_rm = TRUE
    )
  }

  # --- Pivot to wide (SIOT form) --------------------------------------------
  if (labelling == "iotables") {
    out <- iotable_labelled %>%
      dplyr::arrange(iotables_row, iotables_col) %>%
      dplyr::select(iotables_row, iotables_col, values) %>%
      tidyr::pivot_wider(
        names_from = iotables_col,
        values_from = values
      )
  } else {
    out <- iotable_labelled %>%
      dplyr::arrange(prod_na, induse) %>%
      dplyr::select(prod_na, induse, values) %>%
      tidyr::pivot_wider(names_from = induse, values_from = values)
  }

  # --- Attach metadata back --------------------------------------------------

  if (!is.null(labelled_io_data)) {
    out <- out %>%
      tibble::add_column(
        geo = labelled_io_data$geo[[selected_table]],
        year = labelled_io_data$year[[selected_table]],
        unit = labelled_io_data$unit[[selected_table]],
        stk_flow = labelled_io_data$stk_flow[[selected_table]],
        .before = 1
      )
  }

  ver_n <- as.character(utils::packageVersion("iotables"))
  finish_time <- as.character(Sys.time())
  prov_text <- glue::glue(
    "Created with R and the iotables library {ver_n} at {finish_time}."
  )

  attr(out, "dataset_source") <- source
  attr(out, "geo") <- geo
  attr(out, "unit") <- unit
  attr(out, "year") <- year
  attr(out, "stk_flow") <- stk_flow
  attr(out, "structure_type") <- structure_type
  attr(out, "provenance") <- prov_text


  # --- Save if requested -----------------------------------------------------
  if (!is.null(data_directory)) {
    saveRDS(out, file.path(
      data_directory,
      paste0(geo, "_", year, "_", source, "_", stk_flow, "_", unit, ".rds")
    ),
    version = 2
    )
  }
  out
}
#' @keywords internal
iotable_get_new <- function(labelled_io_data = NULL,
                            source = "naio_10_cp1700",
                            geo = "BE",
                            year = 2020,
                            unit = "MIO_EUR",
                            stk_flow = "DOM",
                            labelling = "iotables",
                            data_directory = NULL,
                            force_download = FALSE) {
  # ---- 1. Handle built-in / legacy datasets ---------------------------------
  if (source %in% c(
    "germany_1995",
    "croatia_2010_1700", "croatia_2010_1800", "croatia_2010_1900"
  )) {
    return(iotable_get_builtin(source, labelling, year, geo, unit))
  }

  # ---- 2. Handle UK 2010 Analytical Tables ----------------------------------
  if (grepl("^uk_2010", source)) {
    # UK tables are stored internally and need no download
    return(iotable_get_uk_saved(source = source, labelling = labelling))
  }

  # ---- 3. Handle Eurostat datasets ------------------------------------------
  validate_source(source)

  if (source %in% c(
    "naio_10_cp1620", "naio_10_cp1630",
    "naio_10_pyp1620", "naio_10_pyp1630"
  )) {
    if (stk_flow != "TOTAL") {
      warning("Stock/flow forced to 'TOTAL' for tax and margin tables.")
      stk_flow <- "TOTAL"
    }
  }

  # ---- 4. Retrieve or reuse bulk dataset ------------------------------------
  if (is.null(labelled_io_data)) {
    labelled_io_data <- iotables_download(
      source = source,
      data_directory = data_directory,
      force_download = force_download
    )
  }

  # ---- 5. Parameter checks ---------------------------------------------------
  if (!geo %in% labelled_io_data$geo) {
    stop(glue::glue("No data for geo='{geo}' in {source}."))
  }
  if (!unit %in% labelled_io_data$unit) {
    stop(glue::glue("No data for unit='{unit}' in {source}."))
  }
  if (!year %in% labelled_io_data$year) {
    stop(glue::glue("No data for year={year} in {source}."))
  }
  if (!stk_flow %in% labelled_io_data$stk_flow) {
    warning(glue::glue("stk_flow='{stk_flow}' not found; using first available entry."))
  }

  # ---- 6. Select table from nested tibble -----------------------------------
  selected <- labelled_io_data %>%
    dplyr::filter(
      .data$geo == geo,
      .data$unit == unit,
      .data$year == year,
      .data$stk_flow == stk_flow
    )

  if (nrow(selected) != 1) {
    stop(glue::glue("No unique match for geo={geo}, year={year}, unit={unit}, stk_flow={stk_flow}."))
  }

  io_table <- selected$data[[1]]

  # ---- 7. Clean up -----------------------------------------------------------
  io_table <- io_table %>%
    dplyr::mutate(dplyr::across(where(is.factor), as.character)) %>%
    dplyr::mutate(values = as.numeric(trimws(values)))

  # ---- 8. Attach metadata ----------------------------------------------------
  io_table_labelled <- io_table %>%
    iotable_attach_metadata(source = source, labelling = labelling)

  # ---- 9. Pivot to wide form -------------------------------------------------
  if (labelling == "iotables") {
    io_table_wide <- io_table_labelled %>%
      dplyr::arrange(iotables_row, iotables_col) %>%
      tidyr::pivot_wider(names_from = iotables_col, values_from = values)
  } else {
    io_table_wide <- io_table_labelled %>%
      tidyr::pivot_wider(names_from = induse, values_from = values)
  }

  # ---- 10. Optional save -----------------------------------------------------
  if (!is.null(data_directory)) {
    save_name <- file.path(
      data_directory,
      paste0(geo, "_", year, "_", source, "_", stk_flow, "_", unit, ".rds")
    )
    saveRDS(io_table_wide, save_name, version = 2)
    message("Saved processed IO table to: ", save_name)
  }

  io_table_wide
}
#' Get available years from bulk IO tables
#'
#' @description
#' Query which years are available for a given Eurostat IO product,
#' country (`geo`), and currency unit in a bulk download.
#'
#' @details
#' This function is usually called indirectly via [iotable_get()].
#' You normally do not need to call [iotables_download()] yourself
#' unless working with bulk Eurostat files.
#'
#' Supported Eurostat products include (non-exhaustive):
#'
#' - `"naio_10_cp1700"` — Symmetric IO table, basic prices (product × product)
#' - `"naio_10_cp1750"` — Symmetric IO table, basic prices (industry × industry)
#' - `"naio_10_pyp1700"` — Symmetric IO table (product × product),
#'   previous years’ prices
#' - `"naio_10_pyp1750"` — Symmetric IO table (industry × industry),
#'   previous years’ prices
#' - `"naio_10_cp1620"` / `"naio_10_pyp1620"` — Trade & transport margins
#' - `"naio_10_cp1630"` / `"naio_10_pyp1630"` — Taxes less subsidies on products
#'
#' See the [Eurostat Symmetric Input–Output Tables page](
#' https://ec.europa.eu/eurostat/web/esa-supply-use-input-tables/overview).
#'
#' @param source Character. Eurostat product code (see Details).
#' @param labelled_io_data Optional labelled IO data from
#'   [iotables_download()]. If supplied, avoids re-reading from disk.
#' @param geo Country code or name (e.g. `"SK"` or `"Slovakia"`).
#' @param unit Currency unit. Defaults to `"MIO_NAC"` (millions of national
#'   currency). Alternative: `"MIO_EUR"`.
#' @param stk_flow Flow type. Defaults to `"DOM"` (domestic output).
#'   Alternatives:
#'   - `"IMP"` for imports
#'   - `"TOTAL"` for total output
#'   For sources `"naio_10_cp1620"` (margins) and `"naio_10_cp1630"` (taxes),
#'   only `"TOTAL"` is used.
#' @param time_unit Return mode for time. `"year"` (default) returns numeric
#'   years; `"time"` returns a vector of dates.
#' @param data_directory Optional path used with [iotable_get()] or
#'   [iotables_download()] to persist bulk data.
#' @param force_download Logical. Defaults to `TRUE`. If `FALSE`, reuse an
#'   existing file in `data_directory` or `tempdir()` when available.
#'
#' @return A numeric vector of years, or a date vector if
#'   `time_unit = "time"`.
#'
#' @importFrom dplyr filter select mutate rename left_join arrange across
#' @importFrom forcats fct_reorder
#' @importFrom lubridate year
#' @family iotables processing functions
#'
#' @examples
#' germany_years <- iotable_year_get(
#'   source = "germany_1995", geo = "DE", unit = "MIO_EUR"
#' )
#' # Return as dates
#' germany_dates <- iotable_year_get(
#'   source = "germany_1995", geo = "DE",
#'   unit = "MIO_EUR", time_unit = "time"
#' )
#'
#' @export

iotable_year_get <- function(labelled_io_data = NULL,
                             source = "germany_1995",
                             geo = "DE",
                             unit = "MIO_EUR",
                             time_unit = "year",
                             stk_flow = "TOTAL",
                             data_directory = NULL,
                             force_download = TRUE) {
  ## Initialize variables ------------
  # This function needs to be modernized at one point.  It does what it should but it is
  # superflous and uses old non-standard evaluation.
  values <- . <- NULL # non-standard evaluation creates a varning in build.
  time <- t_cols2 <- t_rows2 <- by_row <- by_col <- tmp_rds <- NULL
  account_group <- digit_1 <- digit_2 <- group <- quadrant <- NULL
  iotables_row <- iotables_col <- prod_na <- induse <- variable <- NULL
  row_order <- col_order <- iotables_label <- code <- numeric_label <- label <- NULL

  source_inputed <- source
  unit_input <- unit
  geo_input <- geo
  stk_flow_input <- stk_flow

  if (source %in% c(
    "naio_10_cp1620", "naio_10_cp1630",
    "naio_10_pyp1620", "naio_10_pyp1630"
  )
  ) {
    stk_flow_input <- "TOTAL" # tax and margin tables only have one version
  }

  if (!time_unit %in% c("year", "time")) {
    time_unit <- "year"
  }
  if (source == "germany_1995") {
    time_unit <- "time"
  }



  ## Veryfing source parameter and loading the labelling  ----
  prod_ind <- c(
    "naio_10_cp1700", "naio_10_cp1750", "naio_10_pyp1700",
    "naio_10_pyp1750", "naio_10_cp1620", "naio_10_cp1630",
    "naio_10_pyp1620", "naio_10_pyp1630"
  )
  trow_tcol <- c("croatia_2010_1700", "croatia_2010_1800", "croatia_2010_1900")
  croatia_files <- c("croatia_2010_1700", "croatia_2010_1800", "croatia_2010_1900")

  if (source %in% prod_ind) {
    metadata_rows <- iotables::metadata %>% # tables that follow prod_ind vocabulary
      filter(variable == "prod_na") %>%
      dplyr::rename(
        prod_na = code,
        prod_na_lab = label,
        row_order = numeric_label,
        iotables_row = iotables_label
      )

    metadata_cols <- iotables::metadata %>%
      dplyr::filter(variable == "induse") %>%
      dplyr::rename(
        induse = code,
        induse_lab = label,
        col_order = numeric_label,
        iotables_col = iotables_label
      )
  } else if (source %in% trow_tcol) {
    # tables that follow trow_tcol vocabulary

    metadata_rows <- iotables::metadata %>%
      dplyr::filter(variable == "t_rows") %>%
      dplyr::rename(
        t_rows2 = code,
        t_rows2_lab = label,
        row_order = numeric_label,
        iotables_row = iotables_label
      )

    metadata_cols <- iotables::metadata %>%
      dplyr::filter(variable == "t_cols") %>%
      dplyr::rename(
        t_cols2 = code,
        t_cols2_lab = label,
        col_order = numeric_label,
        iotables_col = iotables_label
      )
  } else if (source == "germany_1995") { # German simplified tables
    metadata_rows <- germany_metadata_rows
    metadata_cols <- germany_metadata_cols
  } else {
    stop("This type of input-output database is not (yet) recognized by iotables.")
  }

  metadata_rows <- mutate(metadata_rows, across(where(is.factor), as.character))
  metadata_cols <- mutate(metadata_cols, across(where(is.factor), as.character))

  # Exception handling for wrong paramters -----------------------
  if (is.null(labelled_io_data)) {
    # if not directly inputed data
    if (is.null(geo)) stop("Error: no country selected.")

    if (!unit %in% c("MIO_NAC", "MIO_EUR", "T_NAC")) {
      stop("Currency unit must be MIO_NAC, MIO_EUR or T_NAC")
    }
    if (source %in% c("naio_10_cp1620", "naio_10_cp1630")) {
      if (stk_flow != "TOTAL") {
        stk_flow_input <- "TOTAL"
        warning("The parameter stk_flow was changed to TOTAL.")
      }
    }

    # Creating a temporary file name for the input-output table -------------
    tmp_rds1 <- file.path(
      tempdir(), paste0(source, "_iotables.rds")
    ) # if iotables labelled version was created earlier
    tmp_rds2 <- file.path(
      tempdir(), paste0(source, "_short.rds")
    ) # if short labelled version was created earlier
    tmp_rds3 <- file.path(
      tempdir(), paste0(source, ".rds")
    ) # if non-labelled was created earlier
    if (source_inputed == "germany_1995") {
      labelled_io_data <- iotables::germany_1995 # use germany example
    } else if (source_inputed == "croatia_2010_1700") {
      labelled_io_data <- iotables::croatia_2010_1700 %>%
        mutate(year = lubridate::year(time))
    } else if (source_inputed == "croatia_2010_1800") {
      labelled_io_data <- iotables::croatia_2010_1800 %>%
        mutate(year = lubridate::year(time))
    } else if (source_inputed == "croatia_2010_1900") {
      labelled_io_data <- iotables::croatia_2010_1900 %>%
        mutate(year = lubridate::year(time))
    } else {
      if (any(c(tmp_rds1, tmp_rds2, tmp_rds3) %in%
        list.files(path = tempdir()))) {
        tmp_rds <- c(tmp_rds1, tmp_rds2, tmp_rds3)[which(!is.null(c(tmp_rds1, tmp_rds2, tmp_rds3)))]

        labelled_io_data <- readRDS(tmp_rds)
      } else { # getting or downloading the bulk longform data
        labelled_io_data <- iotables_download(source,
          data_directory = data_directory,
          force_download = force_download
        )
      }
    } # use eurostat files
  } # end of possible downloads or data retrieval if not directly inputed

  ## Veryfing parameters ----

  if (nchar(geo_input) == 2 & geo_input == tolower(geo_input)) {
    geo_input <- toupper(geo_input)
    warning("Warning: country code changed to upper case.")
  }

  if (!unit_input %in% labelled_io_data$unit) {
    stop("This currency unit is not found in the raw data frame.")
  }

  if (!geo_input %in% labelled_io_data$geo) {
    stop("This currency unit is not found in the raw data frame.")
  }

  ## Converting factors to characters ------

  selected_tables <- which( ## get the number of table to be selected
    as.character(labelled_io_data$geo) == geo &
      labelled_io_data$unit == unit
  )

  if (time_unit == "year") {
    return_values <- sort(unique(labelled_io_data$year[selected_tables]))
  } else {
    return_values <- sort(unique(labelled_io_data$time[selected_tables]))
  }

  if (length(return_values > 0)) {
    # message ( "The following years are available for ", geo, " in ", unit , " currency units:\n",
    #           paste(return_values, collapse = '; ' ), ".")
  } else {
    warning(
      "No tables are available for ",
      geo, " in ", unit, " currency units."
    )
  }

  return_values
}
#' @keywords internal
"_PACKAGE"

## usethis namespace: start
## usethis namespace: end
NULL
#' iotables: Reproducible Input–Output Analysis for Eurostat and National Data
#'
#' @description
#' Tools for downloading, structuring, and analysing input–output and
#' supply–use tables, with metadata aligned to Eurostat’s ESA 2010 framework.
#'
#' @docType package
#' @name iotables
"_PACKAGE"
#' Download input–output tables (Eurostat only)
#'
#' @description
#' Downloads and prepares symmetric input–output (IO) or supply–use tables
#' directly from Eurostat. This modern version excludes all built-in
#' datasets (`germany_1995`, `croatia_2010_*`, `uk_2010_*`) which are handled
#' internally by [iotable_get()].
#'
#' @details
#' Files are cached under `tempdir()` as RDS
#' (e.g. `"naio_10_cp1750_processed.rds"`).
#' The temporary directory is cleared when the R session ends. To persist
#' downloads across sessions (recommended for analytics), supply
#' `data_directory`.
#'
#' @param source Character. Eurostat dataset ID (e.g. `"naio_10_cp1700"`).
#' @param geo Country code (optional).
#' @param year Numeric (optional).
#' @param unit Character, usually `"MIO_EUR"` or `"MIO_NAC"`.
#' @param stk_flow Stock/flow indicator (`"DOM"`, `"IMP"`, `"TOTAL"`), optional.
#' @param data_directory Directory to save processed data (default: `tempdir()`).
#' @param force_download Logical, whether to force a new Eurostat download.
#'
#' @return
#' A **nested tibble** with metadata columns (`geo`, `year`, `unit`, etc.)
#' and a list-column `data` containing tidy IO tables.
#'
#' @family import functions
#' @importFrom utils object.size
#' @importFrom glue glue
#' @importFrom dplyr rename mutate select filter
#' @importFrom tidyselect any_of
#' @importFrom tidyr nest
#' @importFrom rlang set_names
#' @importFrom eurostat get_eurostat label_eurostat set_eurostat_cache_dir
#' @export
iotables_download <- function(source = "naio_10_cp1700",
                              geo = NULL,
                              year = NULL,
                              unit = NULL,
                              stk_flow = NULL,
                              data_directory = NULL,
                              force_download = FALSE) {
  data_directory <- data_directory # force it into local environment

  # ---- Guard clause: block built-in datasets ------------------------------
  builtin_sources <- c(
    "germany_1995",
    "croatia_2010_1700", "croatia_2010_1800", "croatia_2010_1900",
    "uk_2010", "uk_2010_siot", "uk_2010_coeff", "uk_2010_inverse",
    "netherlands_2000"
  )

  if (source %in% builtin_sources) {
    stop(glue::glue(
      "The dataset '{source}' is a built-in example handled by ",
      "[iotable_get_builtin()].\n",
      "Use that function instead of iotables_download()."
    ), call. = FALSE)
  }

  if (is.null(force_download)) force_download <- FALSE

  # ---- Validate source and setup cache --------------------------------------
  validate_source(source)
  cache_dir <- file.path(tempdir(), "eurostat")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)
  eurostat::set_eurostat_cache_dir(cache_dir)

  # ---- Download from Eurostat ----------------------------------------------
  if (!is.null(geo) || !is.null(year) || !is.null(unit) || !is.null(stk_flow)) {
    # Use lightweight JSON downloader when filters are given
    filters <- list()
    if (!is.null(geo)) filters$geo <- geo
    if (!is.null(year)) filters$time <- as.character(year)
    if (!is.null(unit)) filters$unit <- unit
    if (!is.null(stk_flow)) filters$stk_flow <- stk_flow

    downloaded <- get_eurostat_filtered(
      id      = as.character(source),
      filters = filters
    )

    message("Downloaded filtered subset (", nrow(downloaded), " rows).")
  } else {
    # Fallback to full Eurostat dataset + caching
    downloaded <- tryCatch(
      eurostat::get_eurostat(
        id        = source,
        cache     = !force_download,
        cache_dir = cache_dir
      ),
      error = function(e) {
        stop("Eurostat download failed for '", source, "': ", conditionMessage(e))
      }
    )
    message("Downloaded full dataset (", format(object.size(downloaded), units = "MiB"), ").")
  }

  message("Downloaded ", format(object.size(downloaded), units = "MiB"))

  # ---- Label using Eurostat vocabulary -------------------------------------
  downloaded_labelled <- downloaded %>%
    eurostat::label_eurostat(fix_duplicated = TRUE) %>%
    dplyr::mutate(rows = seq_len(nrow(downloaded))) %>%
    rlang::set_names(paste0(names(.), "_lab")) %>%
    dplyr::rename(rows = rows_lab) %>%
    dplyr::select(-tidyselect::any_of("values_lab")) %>%
    {
      # inside braces to allow conditional rename
      if ("TIME_PERIOD_lab" %in% names(.)) {
        dplyr::rename(., time_lab = TIME_PERIOD_lab)
      } else {
        .
      }
    }
  # ---- Standardize time and year fields ------------------------------------
  downloaded_time <- downloaded %>%
    dplyr::rename_with(~ gsub("TIME_PERIOD", "time", .x)) %>%
    dplyr::mutate(year = lubridate::year(time))

  # ---- Combine labelled + raw versions -------------------------------------
  combined <- downloaded_time %>%
    dplyr::mutate(rows = seq_len(nrow(downloaded_time))) %>%
    dplyr::left_join(downloaded_labelled, by = "rows") %>%
    dplyr::select(-rows)

  # ---- Sanity checks -------------------------------------------------------
  assertthat::assert_that(
    is.numeric(combined$values),
    msg = "combined$values must be numeric."
  )

  # ---- Free up memory -----------------------------------------------
  rm(downloaded_labelled)
  invisible(gc())

  # ---- Nest by metadata (identical to legacy schema) -----------------------
  nesting_vars <- c(
    "geo", "geo_lab", "time", "time_lab",
    "year", "unit", "unit_lab",
    "stk_flow", "stk_flow_lab"
  )

  non_nesting_vars <- setdiff(names(combined), nesting_vars)

  if (length(non_nesting_vars) == 0) {
    # lightweight download already corresponds to one table
    downloaded_nested <- tibble::tibble(
      geo = unique(combined$geo),
      year = unique(combined$year),
      unit = unique(combined$unit),
      stk_flow = unique(combined$stk_flow),
      time = unique(combined$time),
      data = list(combined)
    )
    message("Lightweight download contains a single SIOT; wrapped into nested structure.")
  } else {
    message("Creating nested structure...")
    downloaded_nested <- tidyr::nest(combined,
      data = -dplyr::any_of(nesting_vars)
    )
    message("Nesting done.")
  }

  # ---- Validation of nested structure --------------------------------------
  if (nrow(downloaded_nested) > 0) {
    assertthat::assert_that(
      all(
        vapply(
          downloaded_nested$data,
          function(df) is.numeric(df$values),
          logical(1)
        )
      ),
      msg = "Each nested table must have numeric `values`."
    )
  }

  # ---- Save ----------------------------------------------------------------
  # Build a safe and descriptive filename
  filter_suffix <- c()

  if (!is.null(geo)) filter_suffix <- c(filter_suffix, paste0("geo-", geo))
  if (!is.null(year)) filter_suffix <- c(filter_suffix, paste0("year-", year))
  if (!is.null(unit)) filter_suffix <- c(filter_suffix, paste0("unit-", unit))
  if (!is.null(stk_flow)) filter_suffix <- c(filter_suffix, paste0("stk-", stk_flow))

  # Join with underscores, sanitize for filesystem
  filter_suffix <- paste(filter_suffix, collapse = "_")
  if (filter_suffix != "") filter_suffix <- paste0("_", gsub("[^A-Za-z0-9_\\-]", "", filter_suffix))

  base_filename <- paste0(source, filter_suffix, "_processed.rds")

  save_path <- if (is.null(data_directory)) {
    file.path(tempdir(), base_filename)
  } else {
    assertthat::assert_that(
      dir.exists(data_directory),
      msg = paste("data_directory not found:", data_directory)
    )
    file.path(data_directory, base_filename)
  }

  saveRDS(downloaded_nested, save_path, version = 2)

  if (interactive()) message("Saved processed file to ", save_path)

  # ---- Final cleanup -----------------------------------------------
  vars_to_remove <- c("downloaded_labelled", "downloaded_time", "combined")
  vars_to_remove <- vars_to_remove[vars_to_remove %in% ls()]
  if (length(vars_to_remove) > 0) rm(list = vars_to_remove, envir = environment())
  invisible(gc())

  # ---- Return --------------------------------------------------------------
  downloaded_nested
}
#' Legacy downloader for input–output tables (Eurostat)
#'
#' @description
#' Download standard input–output (IO) and related tables. At the moment,
#' only Eurostat products are supported. You usually do not need to call
#' this directly; [iotable_get()] will invoke it as needed and return a
#' filtered, tidy table.
#'
#' @details
#' Files are cached under `tempdir()` as RDS (e.g., `"naio_10_cp1750.rds"`).
#' The temporary directory is cleared when the R session ends. To persist
#' downloads across sessions (recommended for analytics), supply
#' `data_directory` and the processed, **nested** output will also be
#' written there as `"<source>_processed.rds"`.
#'
#' Supported Eurostat products include (non-exhaustive):
#'
#' - `naio_10_cp1700` — Symmetric IO table, basic prices (product × product)
#' - `naio_10_pyp1700` — Same, previous years’ prices
#' - `naio_10_cp1750` — Symmetric IO table, basic prices (industry × industry)
#' - `naio_10_pyp1750` — Same, previous years’ prices
#' - `naio_10_cp15` — Supply table at basic prices incl. margins/taxes
#' - `naio_10_cp16` — Use table at purchasers’ prices
#' - `naio_10_cp1610` — Use table at basic prices
#' - `naio_10_pyp1610` — Use table at basic prices (previous years’ prices)
#' - `naio_10_cp1620` — Trade and transport margins at basic prices
#' - `naio_10_pyp1620` — Trade and transport margins at previous years’ prices
#' - `naio_10_cp1630` — Taxes less subsidies on products at basic prices
#' - `naio_10_pyp1630` — Taxes less subsidies on products, prev. years’ prices
#' - `uk_2010` — United Kingdom IO Analytical Tables (handled internally)
#'
#' Eurostat API/format changes (e.g., `TIME_PERIOD` vs `time`) are handled
#' for backward compatibility.
#'
#' @param source Character. The Eurostat product code (see above) or `"uk_2010"`.
#' @param data_directory Optional directory path where the processed nested
#'   tables will be saved as `"<source>_processed.rds"`. If `NULL` (default),
#'   results are saved to `tempdir()`.
#' @param force_download Logical. If `FALSE` (default), reuse a cached file
#'   in `data_directory` or `tempdir()` when available. If `TRUE`, force a
#'   fresh download from Eurostat.
#'
#' @return
#' A **nested** `data.frame` (one row per IO table) with metadata columns
#' (`geo`, `unit`, `year`, `stk_flow`, etc.) and a list-column `data`
#' containing the tidy table for each combination.
#'
#' @examples
#' \donttest{
#' io_tables <- iotables_download(source = "naio_10_pyp1750")
#' }
#'
#' @family import functions
#' @importFrom dplyr filter select mutate left_join rename any_of recode
#' @importFrom tidyr nest
#' @importFrom eurostat get_eurostat label_eurostat
#' @importFrom lubridate year
#' @importFrom rlang set_names
#' @importFrom glue glue
#' @importFrom assertthat assert_that
#' @export

iotables_download_old <- function(source = "naio_10_cp1700",
                                  data_directory = NULL,
                                  force_download = FALSE) {
  ## Parameter validation ---------------------------------------------
  if (!source %in% c("uk_2010", "germany_1995")) {
    validate_source(source)
    downloaded <- tempdir_data(source, force_download)
  } else if (source == "uk_2010") {
    return(uk_2010_get())
  }

  if (all(c("year", "data") %in% names(downloaded))) {
    # This is already processed
    message("Returning the processed SIOTs from tempdir. You can override this with force_download=TRUE.")
    return(downloaded)
  }

  assert_that(
    "data.frame" %in% class(downloaded) & ncol(downloaded) > 6 & nrow(downloaded) > 1,
    msg = glue("The download of {source} was not successful.")
  )

  lab_names <- paste0(names(downloaded), "_lab")

  # label the raw Eurostat file, add rename variables with _lab suffix
  downloaded_labelled <- downloaded %>%
    eurostat::label_eurostat(fix_duplicated = TRUE)

  assert_that(
    length(names(downloaded_labelled)) == length(lab_names),
    msg = "in iotables_download() ncol(downloaded_labelled) != ncol(downloaded)"
  )

  downloaded_labelled <- downloaded_labelled %>% # add meaningful labels to raw data
    rlang::set_names(lab_names) %>%
    mutate(rows = seq_len(nrow(downloaded))) %>% # because long and wide formats are not symmetric
    rename(values = values_lab)

  if ("TIME_PERIOD_lab" %in% names(downloaded_labelled)) {
    ## Breaking change in eurostat 4.0.0
    ## keep this for backward compatiblitiy
    downloaded_labelled <- downloaded_labelled %>%
      rename(time_lab = TIME_PERIOD_lab)
  }

  downloaded_labelled <- downloaded_labelled %>%
    mutate(year = lubridate::year(time_lab))

  # Join the labelled and the not labelled files, so that both versions are avialable

  downloaded <- downloaded %>%
    mutate(rows = seq_len(nrow(downloaded))) %>%
    left_join(downloaded_labelled, by = c("rows", "values"))

  if ("TIME_PERIOD" %in% names(downloaded)) {
    ## Breaking change in eurostat 4.0.0
    ## keep this for backward compatiblitiy
    downloaded <- downloaded %>%
      rename(time = TIME_PERIOD)
  }

  if (source == "naio_cp17_r2") {
    # Harmonize certain CPA aggregate codes
    cpa_map <- c(
      "CPA_N80-N82" = "CPA_N80-82",
      "CPA_R90-R92" = "CPA_R90-92",
      "CPA_E37-E39" = "CPA_E37-39",
      "CPA_C10-C12" = "CPA_C10-12",
      "CPA_C13-C15" = "CPA_C13-15",
      "CPA_C31_C32" = "CPA_C31_32",
      "CPA_J59_J60" = "CPA_J59_60",
      "CPA_J62_J63" = "CPA_J62_63",
      "CPA_M69_M70" = "CPA_M69_70",
      "CPA_Q87_Q88" = "CPA_Q87_88",
      "CPA_M74_M75" = "CPA_M74_75",
      "CPA_O84"     = "CPA_O",
      "CPA_P85"     = "CPA_P",
      "CPA_D35"     = "CPA_D"
    )

    downloaded$t_cols2 <- dplyr::recode(downloaded$t_cols2, !!!cpa_map)
    downloaded$t_rows2 <- dplyr::recode(downloaded$t_rows2, !!!cpa_map)
  } # end of _r2


  if ("stk_flow" %in% names(downloaded)) {
    downloaded_nested <- nest(
      downloaded,
      data = -any_of(c(
        "geo", "geo_lab", "time", "time_lab",
        "year", "unit", "unit_lab", "stk_flow", "stk_flow_lab"
      ))
    )
  } else {
    downloaded_nested <- nest(
      downloaded,
      data = -any_of(c(
        "geo", "geo_lab", "time", "time_lab",
        "year", "unit", "unit_lab"
      ))
    )
  }

  if (!is.null(data_directory)) {
    assert_that(dir.exists(data_directory),
      msg = glue::glue("The data_directory={data_directory} does not exist.")
    )

    save_file_name <- file.path(data_directory, paste0(source, "_processed.rds")) # shoud have different name for processed
    message("Saving ", nrow(downloaded_nested), " input-output tables.")
    saveRDS(downloaded_nested, file = save_file_name, version = 2)
    message(
      "Saved the raw data of this table type in ",
      save_file_name, "."
    )
  } else {
    save_file_name <- file.path(tempdir(), paste0(source, "_processed.rds"))
    message("Saving ", nrow(downloaded_nested), " input-output tables into the temporary directory.")
    saveRDS(downloaded_nested, file = save_file_name, version = 2)
    message(
      "Saved the raw data of this table type in temporary directory ",
      save_file_name, "."
    )
  }

  downloaded_nested
}
#' @title Extract metadata from a downloaded IO table
#'
#' @description
#' Returns only the metadata (e.g. country, year, unit, flow) from a nested
#' input–output (IO) table created by [iotables_download()]. Removes the
#' heavy `data` list-column, leaving just metadata rows.
#'
#' @param dat Optional. A nested tibble as returned by [iotables_download()].
#'   If `NULL`, the function attempts to load it from `tempdir()` using the
#'   same cache naming convention (`"<source>_processed.rds"`).
#' @param source Character. A valid data source code (see Details).
#'
#' @return
#' A tibble with metadata columns only (no `data` list-column).
#'
#' @importFrom assertthat assert_that
#' @importFrom tibble as_tibble
#' @importFrom glue glue
#' @export
iotables_metadata_get <- function(dat = NULL,
                                  source = "naio_10_cp1700") {
  validate_source(source)

  # Load cached file if dat not provided
  if (is.null(dat)) {
    cache_file <- file.path(tempdir(), paste0(source, "_processed.rds"))
    if (!file.exists(cache_file)) {
      message(glue(
        "No cached dataset found for source='{source}' in tempdir():\n{cache_file}\n",
        "Try running iotables_download(source = '{source}') first."
      ))
      return(invisible(NULL))
    }

    dat <- tryCatch(
      readRDS(cache_file),
      error = function(e) {
        message("Failed to read cached data: ", conditionMessage(e))
        NULL
      }
    )
  }

  # Validate structure
  if (is.null(dat) || !"data" %in% names(dat)) {
    message(glue(
      "No valid nested data found for source='{source}'.",
      " Did you run iotables_download() first?"
    ))
    return(invisible(NULL))
  }

  # Drop heavy list-column
  metadata <- dat[, setdiff(names(dat), "data"), drop = FALSE]

  # Return a clean tibble
  tibble::as_tibble(metadata)
}
#' @title Read input-output tables from temporary directory
#' @description Validate the \code{source} input parameter and try to load the table
#' from the current sessions' temporary directory.
#' @details
#' Possible \code{source} parameters:
#'  \describe{
#'  \item{\code{naio_10_cp1700}}{Symmetric input-output table at basic prices (product by product)}
#'  \item{\code{naio_10_pyp1700}}{Symmetric input-output table at basic prices (product by product) (previous years prices)}
#'  \item{\code{naio_10_cp1750}}{Symmetric input-output table at basic prices (industry by industry)}
#'  \item{\code{naio_10_pyp1750}}{Symmetric input-output table at basic prices (industry by industry) (previous years prices)}
#'  \item{\code{naio_10_cp15}}{Supply table at basic prices incl. transformation into purchasers' prices}
#'  \item{\code{naio_10_cp16}}{Use table at purchasers' prices}
#'  \item{\code{naio_10_cp1610}}{Use table at basic prices}
#'  \item{\code{naio_10_pyp1610}}{Use table at basic prices (previous years prices) (naio_10_pyp1610)}
#'  \item{\code{naio_10_cp1620}}{Table of trade and transport margins at basic prices}
#'  \item{\code{naio_10_pyp1620}}{Table of trade and transport margins at previous years' prices}
#'  \item{\code{naio_10_cp1630}}{Table of taxes less subsidies on products at basic prices}
#'  \item{\code{naio_10_pyp1630}}{Table of taxes less subsidies on products at previous years' prices}
#'  \item{\code{uk_2010_siot}}{United Kingdom Input-Output Analytical Tables data}
#' }
#' @param source See the available list of sources above in the Description.
#' Defaults to  \code{source = "naio_10_cp1700"}.
#' @return A nested data frame. Each input-output table is in a separate
#' row of the nested output, where all the metadata are in columns, and the
#' actual, tidy, ordered input-output table is in the data \code{data} column.
#' @family import functions
#' @examples
#' \donttest{
#' # The table must be present in the sessions' temporary directory:
#' iotables_download(source = "naio_10_pyp1750")
#'
#' iotables_read_tempdir(source = "naio_10_pyp1750")
#' }
#' @export

iotables_read_tempdir <- function(source = "naio_10_cp1700") {
  validate_source(source)
  temporary_file <- file.path(tempdir(), paste0(source, "_processed.rds"))

  if (file.exists(temporary_file)) {
    readRDS(temporary_file)
  }
}
#' Check if HTML output is required
#'
#' @importFrom knitr is_html_output
#' @name is_html_output
NULL
#' Check if Latex output is required
#'
#' @importFrom knitr is_latex_output
#' @name is_latex_output
NULL
#' @title Create the Leontief inverse
#'
#' @description Computes the **Leontief inverse**, which measures the total
#' (direct + indirect) requirements of all products or industries for one unit
#' of final demand.
#'
#' @details The Leontief inverse is defined as \deqn{L = (I - A)^{-1}} where
#' \eqn{A} is the input-coefficient (or technology-coefficient) matrix created
#' by [input_coefficient_matrix_create()].
#'
#' Each element \eqn{l_{ij}} of \eqn{L} shows the total production of product
#' *i* required—both directly and indirectly—to satisfy one unit of final demand
#' for product *j*.
#'
#' This formulation follows the *Eurostat Manual of Supply, Use and Input–Output
#' Tables* (Beutel 2008, Chapter 15; see equations (19), (43)) and the *UN
#' Handbook on Supply and Use Tables and Input–Output Tables with Extensions and
#' Applications* (2018 Rev. 1, pp. 619–621). The Leontief inverse is also called
#' the **total requirements matrix** in both manuals.
#'
#' For the analogous inverse based on output coefficients, see
#' [ghosh_inverse_create()].
#'
#' @param technology_coefficients_matrix A technology-coefficient matrix created
#'   by [input_coefficient_matrix_create()].
#' @param digits Optional integer specifying rounding precision. Default `NULL`
#'   (no rounding).
#'
#' @return A `data.frame` with the original key column and the Leontief inverse
#' in the remaining columns. If `digits` is supplied, values are rounded.
#'
#' @importFrom dplyr mutate across
#' @family analytic object functions
#'
#' @references Beutel, J. (2008). *Eurostat Manual of Supply, Use and
#' Input–Output Tables.* Luxembourg: Office for Official Publications of the
#' European Communities.
#'
#' Validation examples: – Table 15.6 (p. 485): Direct requirements (input
#' coefficients) – Table 15.10 (p. 488): Total requirements (Leontief inverse)
#'
#' Results reproduced by `input_coefficient_matrix_create()` and
#' `leontief_inverse_create()` using the built-in dataset `iotable_get(source =
#' "germany_1995")`.
#'
#' @examples
#' # --- Minimal hand-checkable 2×2 system ---
#' minimal_matrix <- data.frame(
#'   sector = c("A", "B"),
#'   A = c(0.2, 0.4),
#'   B = c(0.1, 0.2)
#' )
#' leontief_inverse_create(minimal_matrix, digits = 3)
#'
#' # --- Full Eurostat example (Germany 1995) ---
#' cm_de <- input_coefficient_matrix_create(
#'   data_table = iotable_get(source = "germany_1995")
#' )
#' leontief_inverse_create(cm_de)
#' @export
leontief_inverse_create <- function(technology_coefficients_matrix,
                                    digits = NULL) {
  leontief_matrix <- leontief_matrix_create(
    technology_coefficients_matrix = technology_coefficients_matrix
  )

  Lm <- as.matrix(leontief_matrix[, 2:ncol(leontief_matrix)])

  inverse <- solve(Lm)

  if (sum(vapply(inverse, function(x) sum(is.nan(x)), numeric(1))) > 0) {
    stop("Error: Could not invert the Leontief-matrix.")
  }

  named_inverse <- cbind(
    as.data.frame(leontief_matrix[, 1]),
    as.data.frame(inverse)
  ) %>%
    mutate(across(where(is.factor), as.character))

  names(named_inverse) <- names(leontief_matrix)
  row.names(named_inverse) <- seq_len(nrow(named_inverse))

  if (is.null(digits)) {
    return(named_inverse)
  } else {
    round_table(named_inverse, digits = digits)
  }
}

#' @rdname leontief_inverse_create
#' @export
leontieff_inverse_create <- function(technology_coefficients_matrix,
                                     digits = NULL) {
  .Deprecated(
    new = leontief_inverse_create(technology_coefficients_matrix,
      digits = NULL
    ),
    msg = "leontieff_inverse_create() is spelled correctly as leontief_inverse_create()"
  )

  leontief_inverse_create(technology_coefficients_matrix,
    digits = NULL
  )
}
#' @title Create the Leontief matrix (I − A)
#'
#' @description
#' Builds the **Leontief matrix** \eqn{(I - A)} from a technology (input)
#' coefficients matrix \eqn{A}. This is the intermediate step used before
#' computing the Leontief inverse with [leontief_inverse_create()].
#'
#' @details
#' In Eurostat terminology (*Manual of Supply, Use and Input–Output Tables*),
#' the technology coefficients matrix \eqn{A} is obtained by dividing each column
#' of the inter-industry flows by the total output of that industry.
#' The Leontief matrix is then \eqn{I - A}, also called the *matrix of
#' intermediate coefficients subtracted from identity*.
#'
#' This function removes any TOTAL rows/columns (e.g. `"total"`, `"cpa_total"`)
#' before forming \eqn{I - A}. It returns a `data.frame` with the original key
#' column followed by the numeric block of \eqn{I - A}.
#'
#' @param technology_coefficients_matrix A technology coefficients matrix created
#'   by [input_coefficient_matrix_create()] or [output_coefficient_matrix_create()].
#'   The first column must be a key; remaining columns must be numeric.
#'
#' @return
#' A `data.frame` whose first column is the key and whose remaining columns
#' contain the Leontief matrix \eqn{(I - A)}.
#'
#' @family analytic object functions
#'
#' @references
#' Beutel, J. (2008). *Eurostat Manual of Supply, Use and Input–Output Tables.*
#' Luxembourg: Office for Official Publications of the European Communities.
#'
#' Validation examples:
#' – Table 15.6 (p. 485): Direct requirements (input coefficients A)
#' – **Table 15.9 (p. 487): Leontief matrix (I − A)**
#' – Table 15.10 (p. 488): Leontief inverse (total requirements L = (I − A)⁻¹)
#'
#' Results reproduced by `input_coefficient_matrix_create()`,
#' `leontief_matrix_create()`, and `leontief_inverse_create()` using the built-in
#' dataset `iotable_get(source = "germany_1995")`.
#'
#' @examples
#' # From input coefficients (usual case)
#' tm <- input_coefficient_matrix_create(iotable_get(), households = FALSE)
#' L <- leontief_matrix_create(tm)
#'
#' @importFrom dplyr mutate across
#' @export

leontief_matrix_create <- function(technology_coefficients_matrix) {
  key_column <- as.character(
    unlist(technology_coefficients_matrix[, 1])
  )

  total_row <- which(c("total", "cpa_total") %in% tolower(key_column))
  total_col <- which(c("total", "cpa_total") %in% tolower(names(technology_coefficients_matrix)))

  if (length(total_row) > 0) {
    technology_coefficients_matrix <- technology_coefficients_matrix[-total_row, ]
  }

  if (length(total_col) > 0) {
    technology_coefficients_matrix <- technology_coefficients_matrix[, -total_col]
  }

  Tm <- as.matrix(technology_coefficients_matrix[, 2:ncol(technology_coefficients_matrix)])

  if (nrow(Tm) != ncol(Tm)) stop("Error: the input matrix is not symmetric.")

  IminusA <- diag(nrow(Tm)) - Tm

  if (sum(vapply(IminusA, function(x) sum(is.nan(x)), numeric(1))) > 0) {
    warning("Warning: There are invalid elements in the Leontief-matrix.")
  }

  Leontief <- cbind(
    as.data.frame(technology_coefficients_matrix[, 1]),
    as.data.frame(IminusA)
  )

  names(Leontief)[1] <- names(technology_coefficients_matrix)[1]
  Leontief[, 1] <- as.character(Leontief[, 1])

  Leontief
}

#' @rdname leontief_matrix_create
#' @export
leontieff_matrix_create <- function(technology_coefficients_matrix) {
  .Deprecated(
    new = leontief_matrix_create(technology_coefficients_matrix),
    msg = "leontieff_matrix_create() is spelled correctly as leontief_matrix_create()"
  )

  leontief_matrix_create(technology_coefficients_matrix)
}
#' Round Matrix Values
#'
#' Round all numeric values in an input–output style table to a specified number
#' of digits. The key column (first column) is preserved unchanged.
#'
#' @param data_table A symmetric input–output table, use table, supply table,
#'   tax table, or margins table.
#' @param digits Integer number of decimal places to round to. Defaults to `0`.
#'
#' @return A `data.frame` (or tibble) with the key column intact and all other
#'   numeric columns rounded to the given precision.
#'
#' @details
#' This is useful for comparing results across software or publications that
#' present rounded tables.
#'
#' @family iotables processing functions
#'
#' @examples
#' de_coeff <- input_coefficient_matrix_create(iotable_get())
#' head(matrix_round(de_coeff, digits = 2))
#'
#' @importFrom dplyr mutate across
#' @export
matrix_round <- function(data_table, digits = 0) {
  data_table %>%
    mutate(across(where(is.numeric), function(x) round(x, digits)))
}
#' Create multipliers
#'
#' Wrapper around [equation_solve()] that computes total multipliers by
#' post-multiplying an input indicator vector with a Leontief inverse and
#' adds a key column carrying the multiplier name for consistent joins.
#'
#' In the Eurostat IO framework, multipliers measure *total* effects per
#' unit of **final demand**, by product or industry (via the Leontief
#' inverse \eqn{(I - A)^{-1}}). This contrasts with *direct effects*,
#' which reflect only the immediate (first-round) impact.
#'
#' @param input_vector A named numeric vector (or 1-column matrix)
#'   created by [input_indicator_create()] whose names match the ordering
#'   of the Leontief inverse columns.
#' @param Im A Leontief inverse matrix created by
#'   [leontief_inverse_create()]. Column names must correspond to products
#'   or industries consistent with `input_vector`.
#' @param multiplier_name A string used for the key column that labels the
#'   returned multipliers. Default is `"multiplier"`.
#' @param digits Optional integer. If supplied and non-negative, round the
#'   resulting multipliers to this number of decimal places. Negative
#'   values are ignored (no rounding).
#'
#' @return A data frame with:
#' * a first key column (character) named as the first column of
#'   `input_vector` and filled with `multiplier_name`, and
#' * one numeric column per product/industry containing the multipliers.
#'
#' @details
#' The function delegates the numerical solve to [equation_solve()] and
#' then formats the result for tidy joining with other IO tables. Ensure
#' that the dimension ordering and names of `input_vector` and `Im`
#' correspond; otherwise results will be misaligned.
#'
#' @seealso [equation_solve()], [input_indicator_create()],
#'   [leontief_inverse_create()]
#'
#' @family multiplier functions
#'
#'  @references
#' Beutel, J. (2008).
#' *Eurostat Manual of Supply, Use and Input–Output Tables.*
#' Luxembourg: Office for Official Publications of the European
#' Communities.
#'
#' Validation examples:
#' – Table 15.16 (pp. 503–504): Total multipliers (Germany 1995)
#'
#' Results reproduced by `multiplier_create()` using
#' `iotable_get(source = "germany_1995")`.
#'
#' @examples
#' # Minimal workflow -----------------------------------------------
#' data_table <- iotable_get()
#'
#' coeff_de <- input_coefficient_matrix_create(data_table)
#'
#' de_gva_indicator <- input_indicator_create(
#'   data_table = data_table,
#'   input = "gva"
#' )
#'
#' I_de <- leontief_inverse_create(coeff_de)
#'
#' de_gva_multipliers <- multiplier_create(
#'   input_vector = de_gva_indicator,
#'   Im = I_de,
#'   multiplier_name = "employment_multiplier",
#'   digits = 4
#' )
#'
#' @export

multiplier_create <- function(input_vector,
                              Im,
                              multiplier_name = "multiplier",
                              digits = NULL) {
  if (!is.null(digits) && digits < 0) digits <- NULL

  multipliers <- equation_solve(
    LHS = input_vector,
    Im = Im
  )

  if (!is.null(digits)) {
    multipliers <- round(multipliers, digits)
  }
  names(multipliers) <- names(Im)[2:ncol(Im)]
  row_name <- as.data.frame(multiplier_name)
  names(row_name)[1] <- names(input_vector)[1]

  named_multipliers <- cbind(row_name, multipliers)
  named_multipliers[, 1] <- as.character(named_multipliers[, 1])

  if (!is.null(digits)) matrix_round(named_multipliers, digits) else named_multipliers
}
#' @importFrom dplyr filter select mutate rename left_join arrange all_of
#' @importFrom dplyr across where
#' @importFrom tidyr pivot_wider
#' @importFrom forcats fct_reorder
#' @importFrom utils data

#' @keywords internal
order_iotable <- function(iotable, stk_flow, source, labelling) {
  # Logically this should be called from iotables_download, too.
  # But now it is called from iotable_get.

  croatia_files <- c("croatia_2010_1700", "croatia_2010_1800", "croatia_2010_1900")
  uk_tables <- c("uk_2010_siot", "uk_2010_use", "uk_2010_imports", "uk_2010_coeff", "uk_2010_inverse")

  ## Exception handling for tax and margin tables ------------------------------------------------
  stk_flow_input <- adjust_stk_flow(stk_flow = stk_flow, source = source)

  ## Define the tables that follow the prod_ind vocabulary ---------------------------------------
  prod_ind <- define_prod_ind()

  ## Getting the vocabulary information ----------------------------------------------------------
  ## Source file is utils-metadata.R

  if (source %in% uk_tables) {
    metadata_uk_2010 <- getdata("metadata_uk_2010")
    metadata_cols <- metadata_uk_2010 %>%
      filter(!is.na(uk_col)) %>%
      select(-all_of(c("uk_row", "uk_row_label", "prod_na", "row_order"))) %>%
      mutate(uk_col = gsub("\\.", "-", as.character(uk_col))) %>%
      mutate(uk_col = gsub(" & ", "-", as.character(uk_col))) %>%
      mutate(uk_col = trimws(uk_col, "both"))

    metadata_rows <- metadata_uk_2010 %>%
      filter(!is.na(uk_row)) %>%
      select(-all_of(c("uk_col", "uk_col_label", "induse", "col_order"))) %>%
      mutate(uk_row = gsub("\\.", "-", as.character(uk_row))) %>%
      mutate(uk_row = gsub(" & ", "-", as.character(uk_row)))
  } else {
    metadata_rows <- get_metadata_rows(source) %>% mutate(across(where(is.factor), as.character))
    metadata_cols <- get_metadata_cols(source) %>% mutate(across(where(is.factor), as.character))
  }

  ## Factor reordering & row ordering -------------------------------------------------------------
  if (source %in% c(prod_ind, uk_tables)) {
    ## Ordering IOTs following the prod_ind vocabulary
    ## First define the joining variables for left_join with metadata
    col_join <- names(iotable)[which(names(iotable) %in% c("induse", "induse_lab", "iotables_col"))]
    row_join <- names(iotable)[which(names(iotable) %in% c("prod_na", "prod_na_lab", "iotables_row"))]

    ## Define the variables that will not be used from the metadata
    remove_vars <- c(
      "quadrant", "account_group", "variable",
      "group", "eu_prod_na"
    )
    remove_vars <- remove_vars[remove_vars %in% names(metadata_cols)]

    if ("stk_flow" %in% names(iotable)) {
      # The germany_1995 files have no stk_input columns.
      iotable_labelled <- iotable %>%
        filter(stk_flow == stk_flow_input)
    } else {
      iotable_labelled <- iotable
    }

    iotable_labelled <- iotable_labelled %>%
      mutate(across(where(is.factor), as.character)) %>%
      left_join(metadata_cols, by = col_join) %>%
      select(-all_of(remove_vars)) %>% # remove repeating columns before joining rows
      mutate(across(where(is.factor), as.character)) %>%
      left_join(metadata_rows, by = row_join)

    if (nrow(iotable_labelled) == 0) {
      stop(
        "No rows found with parameters order_iotable(source='", source,
        "' labelling= '", labelling, "' and stk_flow = '", stk_flow, "')."
      )
    }

    ## Do the reordering if the metadata variable is called prod_na
    iotable_labelled <- iotable_labelled %>%
      arrange(row_order, col_order) %>%
      mutate(prod_na = fct_reorder(prod_na, as.numeric(row_order))) %>%
      mutate(induse = fct_reorder(induse, as.numeric(col_order)))

    if (all(c("uk_row", "uk_col") %in% names(iotable_labelled))) {
      iotable_labelled <- iotable_labelled %>%
        mutate(iotables_row = fct_reorder(uk_row, as.numeric(row_order))) %>%
        mutate(iotables_col = fct_reorder(uk_col, as.numeric(col_order)))
    }

    if (all(c("iotables_row", "iotables_col") %in% names(iotable_labelled))) {
      iotable_labelled <- iotable_labelled %>%
        mutate(iotables_row = fct_reorder(iotables_row, as.numeric(row_order))) %>%
        mutate(iotables_col = fct_reorder(iotables_col, as.numeric(col_order)))
    }
  } else if (!source %in% croatia_files) {
    ## Ordering IOTs that do not follow the prod_na vocabulary
    if (all(c("uk_row", "uk_col") %in% names(iotable_labelled))) {
      iotable_labelled <- iotable_labelled %>%
        mutate(iotables_row = fct_reorder(uk_row, as.numeric(row_order))) %>%
        mutate(iotables_col = fct_reorder(uk_col, as.numeric(col_order)))
    }
    if (all(c("iotables_row", "iotables_col") %in% names(iotable_labelled))) {
      iotable_labelled <- iotable_labelled %>%
        mutate(iotables_row = fct_reorder(iotables_row, as.numeric(row_order))) %>%
        mutate(iotables_col = fct_reorder(iotables_col, as.numeric(col_order)))
    }
  } else {
    ## This is the exception for Croatia
    iotable_labelled <- iotable

    # First join the necessary vocabulary from the metadata...
    by_col <- names(iotable)[which(names(iotable) %in% c("t_cols2", "t_cols2_lab", "iotables_col"))]
    by_row <- names(iotable)[which(names(iotable) %in% c("t_rows2", "t_rows2_lab", "iotables_row"))]

    iotable_labelled <- iotable %>%
      mutate(across(where(is.factor), as.character)) %>%
      left_join(metadata_cols, by = by_col) %>%
      left_join(metadata_rows, by = by_row) %>%
      arrange(row_order, col_order)

    iotable_labelled <- iotable_labelled %>%
      arrange(row_order, col_order) %>% # ?needed
      mutate(t_rows2 = fct_reorder(t_rows2, as.numeric(row_order))) %>%
      mutate(t_cols2 = fct_reorder(t_cols2, as.numeric(col_order))) %>%
      mutate(iotables_row = fct_reorder(iotables_row, as.numeric(row_order))) %>%
      mutate(iotables_col = fct_reorder(iotables_col, as.numeric(col_order)))
  }


  ## selecting which labelling to use -------------------------------------------------
  if (labelling == "iotables") {
    ## Only one labelling can be selected, start with the
    ## internal package  'iotables' labelling
    iotable_labelled_w <- iotable_labelled %>%
      arrange(iotables_row, iotables_col) %>%
      select(all_of(c("iotables_col", "iotables_row", "values"))) %>%
      pivot_wider(names_from = iotables_col, values_from = values)
  } else if (labelling == "short" & source %in% prod_ind) {
    ## Labelling with the Eurostat prod_ind vocabulary
    iotable_labelled_w <- iotable_labelled %>%
      select(all_of(c("prod_na", "induse", "values"))) %>%
      filter(!is.na(prod_na)) %>%
      pivot_wider(names_from = induse, values_from = values)
  } else if (source %in% uk_tables) {
    iotable_labelled_w <- iotable_labelled %>%
      select(all_of(c("uk_row", "uk_col", "values"))) %>%
      filter(!is.na(uk_row)) %>%
      pivot_wider(names_from = uk_col, values_from = values)
  } else {
    ## Labelling with the special Croatia replication files
    iotable_labelled_w <- iotable_labelled %>%
      select(all_of(c("t_rows2", "t_cols2", "values"))) %>%
      pivot_wider(names_from = t_cols2, values_from = values)
  }

  # Return the labelled IOT in wide format:
  iotable_labelled_w
}
#' Create an output coefficient matrix
#'
#' Create an output-coefficient matrix from a symmetric input–output table or
#' a use table. Output coefficients can be interpreted as the market shares
#' of products in total output (row-wise normalization).
#'
#' @details
#' Let \eqn{Z} be the inter-industry flow block and \eqn{x} the vector of
#' product output (or, for final-demand shares, total final use).
#' The output-coefficient matrix \eqn{B} is defined row-wise as
#' \eqn{b_{ij} = z_{ij} / x_i}. In practice, zeros in the denominator can make
#' equations unsolvable; this function replaces zeros with a small epsilon
#' (`1e-6`) to avoid division by zero.
#'
#' Eurostat, *Manual of Supply, Use and Input-Output Tables* (e.g., pp. 495,
#' 507) describes output coefficients and the Ghosh framework you may use
#' these with.
#'
#' @param data_table A symmetric input–output table, use table, margins, or
#'   tax table retrieved by [iotable_get()]. If you request
#'   `total = "tfu"` (total final use), you must supply a full table from
#'   [iotable_get()] because the TFU column is in the second quadrant.
#' @param total Which total to use for normalization. Use `"total"` (or the
#'   present table variant name, e.g. `"CPA_TOTAL"`) for output by product, or
#'   `"tfu"` / `"total_final_use"` / `"final_demand"` for total final use.
#'   Default: `"tfu"`.
#' @param digits Integer number of decimal places for rounding. Default `NULL`
#'   (no rounding).
#'
#' @return A `data.frame` whose first column is the key (product labels) and
#'   the remaining columns form the output-coefficient matrix. Column order
#'   follows the input.
#'
#' @importFrom dplyr mutate across
#'
#' @examples
#' data_table <- iotable_get()
#' output_coefficient_matrix_create(
#'   data_table = data_table,
#'   total = "tfu",
#'   digits = 4
#' )
#'
#' @family analytic object functions
#' @export

output_coefficient_matrix_create <- function(data_table,
                                             total = "tfu",
                                             digits = NULL) {
  check_digits(digits = digits)

  data_table <- data_table %>%
    dplyr::mutate(dplyr::across(where(is.factor), function(x) as.character(x)))

  # Remove empty rows/cols
  data_table <- empty_remove(data_table)

  total_row <- which(tolower(as.character(unlist(data_table[, 1])))
  %in% c("cpa_total", "total"))

  if (length(total_row) == 0) {
    stop("Total row not found")
  } else {
    data_table <- data_table[1:(total_row - 1), ]
  }

  if (total == "total") {
    demand_col <- which(tolower(names(data_table)) %in% c("cpa_total", "total"))
    last_column <- quadrant_separator_find(data_table)
    if (length(demand_col) == 0) {
      stop("Please input a table that has a total column.")
    }
  } else if (tolower(total) %in% c("total_final_use", "tfu", "final_demand")) {
    demand_col <- which(tolower(names(data_table)) %in% c("tfu", "total_final_use"))
    last_column <- quadrant_separator_find(data_table, include_total = FALSE)
  } else {
    stop("Paramter 'output' must be any of 'CPA_TOTAL', 'TOTAL', 'final_demand', 'tfu' or 'total_final_use'.")
  }

  demand <- data_table[, demand_col]
  demand # (no-op line retained to avoid logic changes)

  # Keep only the first quadrant (key + inter-industry block) — use base subsetting
  keep_first_name <- names(data_table)[1]
  data_table <- data_table[, 1:last_column, drop = FALSE]

  # Build the first (key) column for the result
  first_col <- as.data.frame(data_table[, 1])
  names(first_col) <- keep_first_name

  null_to_eps <- function(x) ifelse(x == 0, 0.000001, x)

  demand <- null_to_eps(as.numeric(unlist(demand)))

  # Avoid division by zero with epsilon (row-wise denominator)
  data_table <- vapply(
    data_table[seq_len(nrow(data_table)), 2:last_column, drop = FALSE],
    null_to_eps,
    numeric(nrow(data_table))
  )

  output_coeff <- apply(
    data_table, 2,
    function(i) i / demand
  )

  output_coeff <- as.data.frame(output_coeff)
  output_coeff <- cbind(first_col, output_coeff)

  if (is.null(digits)) {
    return(output_coeff)
  }

  if (digits >= 0) {
    round_eps <- function(x, digits) ifelse(x == 1e-06, x, round(x, digits))
    output_coeff <- output_coeff %>%
      dplyr::mutate(dplyr::across(
        where(is.numeric),
        function(x) round_eps(x, digits)
      ))
  } else {
    stop("Error: not a valid rounding parameter.\nMust be an integer representing the rounding digits.")
  }
  output_coeff
}
#' Get the output (P1) vector
#'
#' @description
#' Convenience wrapper around [primary_input_get()] that returns the row
#' labelled **Output (P1)** from a symmetric input–output table (SIOT) or
#' from a use table retrieved by [iotable_get()].
#'
#' @details
#' In the Eurostat framework, **Output** is transaction **P1**, usually
#' recorded at **basic prices** (often labelled "output" or "output_bp").
#' It is a balancing item of the use table / SIOT, **not** a “primary
#' input” (primary inputs are value added components and imports, shown
#' in the third quadrant). This helper merely selects the row labelled
#' `"output"`, `"output_bp"`, `"P1"` or `"p1"` if present.
#'
#' @param data_table A symmetric input–output table or use table
#'   retrieved by [iotable_get()].
#'
#' @return
#' A one-row data frame: the first column is the key column; remaining
#' columns give output (P1) by product/industry.
#'
#' @seealso [primary_input_get()], [iotable_get()]
#' @family iotables processing functions
#'
#' @examples
#' # Output (P1) from the package demo table
#' iot_germany <- iotable_get()
#' output_get(data_table = iot_germany)
#'
#' @export


output_get <- function(data_table) {
  key_column <- as.character(unlist(data_table[, 1]))

  possible_names <- c("output", "output_bp", "p1", "P1")

  primary_input_get(
    data_table = data_table,
    primary_input = possible_names[
      possible_names %in% key_column
    ]
  )
}
#' Create output multipliers
#'
#' @description
#' Compute output multipliers from a Leontief inverse matrix.
#'
#' @details
#' The output multipliers are defined as the **column sums** of the
#' Leontief inverse \eqn{(I - A)^{-1}}, where \eqn{A} is the input
#' coefficient matrix. They measure the total direct and indirect
#' output generated in each industry per unit increase in final demand.
#'
#' See Eurostat (2008), *Manual of Supply, Use and Input–Output Tables*,
#' p. 500; UN (2018), *Handbook on Supply and Use Tables and Input–Output
#' Tables with Extensions and Applications*, §15.35.
#'
#' @param input_coefficient_matrix A technology–coefficient matrix as
#'   returned by [input_coefficient_matrix_create()].
#'
#' @return A one-row `data.frame` (or tibble) with:
#' - The first column a label `"output_multipliers"`.
#' - Remaining columns the multipliers for each industry.
#'
#' @family multiplier functions

#' @importFrom tibble as_tibble
#' @importFrom stats setNames
#'
#' @examples
#' de_input_coeff <- input_coefficient_matrix_create(
#'   iotable_get(),
#'   digits = 4
#' )
#'
#' output_multiplier_create(de_input_coeff)
#'
#' @export

output_multiplier_create <- function(input_coefficient_matrix) {
  inv <- leontief_inverse_create(input_coefficient_matrix)
  multipliers <- colSums(inv[, -1, drop = FALSE])
  key_col <- names(inv)[1]

  # build a named list in base R
  row <- c(
    list(output_multipliers = "output_multipliers"),
    as.list(multipliers)
  )
  names(row)[1] <- key_col

  tibble::as_tibble(row)
}
#' Get a primary input row
#'
#' Retrieve a named primary-input row from a symmetric input–output table,
#' a use table, or a supply table (as returned by [iotable_get()]).
#'
#' @details
#' In I–O accounting, *primary inputs* (e.g., compensation of employees,
#' consumption of fixed capital, taxes on production/subsidies, operating
#' surplus/mixed income, and—when relevant—imports used for domestic
#' production) are shown in the value-added block (third quadrant).
#'
#' @param data_table A symmetric I–O table, use table, or supply table as
#'   returned by [iotable_get()].
#' @param primary_input Character. The primary input to return. Accepts common
#'   synonyms (e.g., "compensation of employees", "cfc", "taxes on production",
#'   "operating surplus", "imports").
#'
#' @importFrom dplyr select mutate across where any_of
#' @return A data frame containing the key column and the matching primary-
#'   input row.
#'
#' @references
#' Eurostat (2008). *Eurostat Manual of Supply, Use and Input–Output Tables*,
#' ch. 13.
#' United Nations (2018). *Handbook on Supply and Use Tables and Input–Output
#' Tables with Extensions and Applications (Rev. 1, “white cover”)*, ch. 10.
#'
#' @family iotables processing functions
#'
#' @examples
#' # Get the Germany 1995 demo SIOT with default labelling
#' de_iot <- iotable_get(source = "germany_1995")
#'
#' # Select compensation of employees (row code: "compensation_employees")
#' primary_input_get(de_iot, "compensation_employees")
#'
#' # Get the same table with Eurostat short labelling
#' de_iot_short <- iotable_get(source = "germany_1995", labelling = "short")
#'
#' # Consumption of fixed capital (row code: "K1")
#' primary_input_get(de_iot_short, "K1")
#'
#' # Operating surplus and mixed income, net (row code: "B2A3N")
#' primary_input_get(de_iot_short, "B2A3N")
#' @export
primary_input_get <- function(data_table,
                              primary_input = "compensation_employees") {
  if (is.null(data_table)) {
    stop("No input-output table was given as input.")
  }
  if (!is.data.frame(data_table)) {
    stop("`data_table` must be a data.frame (or tibble).")
  }
  if (!is.character(primary_input) || length(primary_input) != 1L) {
    stop("`primary_input` must be a single character string.")
  }

  data_table <- dplyr::mutate(
    data_table,
    dplyr::across(dplyr::where(is.factor), as.character)
  )

  # Select all until the last column in the quadrant
  last_column <- quadrant_separator_find(data_table)
  if (!is.numeric(last_column) || length(last_column) != 1L ||
    is.na(last_column) || last_column < 2L ||
    last_column > ncol(data_table)) {
    stop("Quadrant separator is invalid for this table.")
  }

  # Limit to the economic block (by position, preserving current behavior)
  data_table <- data_table[, seq_len(last_column), drop = FALSE]

  # First column is the label/key column
  labels <- data_table[[1L]]

  hits <- which(labels == primary_input)
  if (length(hits) == 0L) {
    stop("The requested primary input was not found in the first column.")
  }
  if (length(hits) > 1L) {
    stop("Multiple rows match `primary_input`; labels must be unique.")
  }

  data_table[hits, , drop = FALSE]
}
#' @title Locate the end of the inter-industry block (Quadrant I)
#'
#' @description
#' Detects the **column index** of the last inter-industry (Quadrant I) column
#' in a wide symmetric input–output (SIOT) or use table. This separator is used
#' to split the inter-industry block from **final uses** (Quadrant III) and other
#' columns before computing coefficients and inverses.
#'
#' @details
#' The function applies a small set of **case-insensitive heuristics** over the
#' column names (first column is assumed to be the key/label column):
#'
#' 1. If a column named `"total"` or `"cpa_total"` exists, its index is used
#'    as the boundary. If `include_total = FALSE` (default), the **column
#'    before** total is returned.
#' 2. Otherwise, if a column named `"households"` or `"p13_s14"` exists,
#'    the separator is placed **immediately before** that column.
#' 3. Otherwise, if a column named one of `"cpa_u"`, `"cpa_t"`, or `"cpa_s96"`
#'    exists, that column index is used (these are common last CPA aggregates).
#' 4. Otherwise, if `"other_services_group"` exists, its index is used.
#'
#' If none of the above markers are found, the function returns **2** and emits
#' a warning. Returning 2 (i.e. first numeric column only) avoids aborting
#' downstream pipelines but indicates that column metadata should be checked.
#'
#' Notes:
#' - Matching is **case-insensitive**.
#' - If **multiple** potential columns match (e.g. both `"total"` and
#'   `"cpa_total"`), all matching indices are returned. Callers should ensure
#'   uniqueness upstream if a single index is required.
#' - Set `include_total = TRUE` when you explicitly want the index of the total
#'   column itself (e.g. for consistency checks).
#'
#' @param data_table A wide SIOT/use table where the first column is a key
#'   (product/industry label) and subsequent columns are numeric flows.
#' @param include_total Logical. If `TRUE`, and a `"total"`/`"cpa_total"` column
#'   is present, return its **own** index; if `FALSE` (default), return the
#'   **last inter-industry** column (i.e. one before total).
#'
#' @return An **integer** column index (or an integer vector if multiple matches
#'   exist). If no marker is found, returns `2L` with a warning.
#'
#' @examples
#' # Minimal SIOT (wide):
#' small_io <- data.frame(
#'   prod_na = c("CPA_A", "CPA_B", "CPA_C", "output"),
#'   CPA_A   = c(10, 4, 1, 35),
#'   CPA_B   = c(2, 8, 5, 30),
#'   CPA_C   = c(3, 2, 6, 30),
#'   total   = c(20, 16, 18, NA_real_)
#' )
#'
#' # End of Quadrant I (before 'total'):
#' quadrant_separator_find(small_io)
#' # include_total = TRUE returns the index of the 'total' column:
#' quadrant_separator_find(small_io, include_total = TRUE)
#'
#' @seealso \code{\link{coefficient_matrix_create}},
#'   \code{\link{input_coefficient_matrix_create}}
#' @keywords internal

quadrant_separator_find <- function(data_table,
                                    include_total = FALSE) {
  last_column <- 2
  if (any(c("total", "cpa_total") %in% tolower(names(data_table)))) {
    last_column <- which(tolower(names(data_table)) %in% c("total", "cpa_total"))
    if (!include_total) last_column <- last_column - 1 # if total columns are not needed, the last but total
  } else if (any(c("households", "p13_s14") %in% tolower(names(data_table)))) {
    last_column <- which(tolower(names(data_table)) %in% c("households", "p13_s14")) - 1
  } else if ("cpa_u" %in% tolower(names(data_table))) {
    last_column <- which(tolower(names(data_table)) == "cpa_u")
  } else if ("cpa_t" %in% tolower(names(data_table))) {
    last_column <- which(tolower(names(data_table)) == "cpa_t")
  } else if ("cpa_s96" %in% tolower(names(data_table))) {
    last_column <- which(tolower(names(data_table)) == "cpa_s96")
  } else if ("other_services_group" %in% tolower(names(data_table))) {
    last_column <- which(tolower(names(data_table)) == "other_services_group")
  }

  if (last_column == 2) {
    warning("The last column was not found")
  }
  last_column
}


#' @keywords internal
quadrant_separator_find_2 <- function(data_table, col_name = NULL) {
  if (!is.null(col_name)) {

  }
  var_names <- tolower(names(data_table))

  potential_total_columns <- c("cpa_total", "total", "cpa_tot")
  potential_quadrant_2 <- c("^p3", "tfu")
  potential_last_columns <- c("cpa_s96", "cpa_o-t", "cpa_u", "cpa_t")

  total_n <- which(var_names %in% potential_total_columns)
  next_n <- NULL
  prev_n <- max(which(var_names %in% potential_last_columns), na.rm = TRUE)

  ordered_patterns <- potential_quadrant_2[
    unlist(
      lapply(
        lapply(
          potential_quadrant_2, function(x) grepl(x, var_names)
        ), any
      )
    )
  ]

  if (length(ordered_patterns) > 0 && !is.na(ordered_patterns)[1]) {
    next_n <- min(which(grepl(ordered_patterns[1], var_names)), na.rm = TRUE)
  }

  if (length(total_n) == 1 && length(next_n) == 1) {
    if (total_n + 1 == next_n) {
      return(total_n - 1)
    }
  }

  if (length(total_n) == 1 && length(prev_n) == 1) {
    if (prev_n + 1 == total_n) {
      return(prev_n)
    }
  }

  if (length(prev_n) == 1 && length(next_n) == 1) {
    return(prev_n)
  }

  warning("Quadrant separator not found")

  return(NULL)
}
#' Systematically round numeric values in a table
#'
#' @description
#' Utility function to round all numeric columns in an input-output style
#' table. It is mainly intended for reproducibility and comparability with
#' external sources that report rounded values. Non-numeric columns are left
#' unchanged.
#'
#' Special cases:
#' - If `digits = NULL` (default), the function returns the input unchanged
#'   (no rounding).
#' - Values exactly equal to `1e-06` are preserved to avoid suppressing small
#'   "epsilon" entries that occur in published IOTs and SUTs.
#'
#' @param data_table A symmetric input–output table, a use table, a supply
#'   table, or a margins/taxes table. Must be a data frame or tibble.
#' @param digits Integer scalar giving the number of digits for rounding.
#'   If `NULL`, no rounding is performed. If not numeric, a warning is
#'   issued and the table is returned unchanged.
#'
#' @return A tibble (if input was a tibble) or data frame with numeric
#'   columns rounded according to `digits`. Non-numeric columns are
#'   unchanged. If `digits = NULL` or invalid, the table is returned
#'   unchanged.
#'
#' @details
#' Rounding conventions in published tables differ across sources:
#' - Eurostat (2008, *Manual of Supply, Use and Input-Output Tables*),
#'   presents benchmark IOTs rounded to integers (millions of EUR).
#' - UN (2018, *Handbook on SUTs and IOTs*), notes that examples may not
#'   sum exactly because of rounding (p. 15).
#'
#' This function allows the user to replicate such rounded presentations
#' while keeping analytic pipelines consistent. Internally, rounding should
#' be used with care: repeated rounding in intermediate steps may accumulate
#' error. For modelling, keep `digits = NULL` and apply rounding only when
#' reproducing published sources.
#'
#' @importFrom dplyr mutate across where if_else
#' @keywords internal

round_table <- function(data_table, digits = NULL) {
  # No rounding requested
  if (is.null(digits)) {
    return(data_table)
  }

  # Validate digits
  if (!is.numeric(digits) || length(digits) != 1L || !is.finite(digits)) {
    warning("Error: rounding digits must be numeric (finite scalar). No rounding took place.")
    return(data_table)
  }

  round_eps <- function(x, digits) {
    dplyr::if_else(is.na(x) | x == 1e-06, x, round(x, digits))
  }

  dplyr::mutate(
    data_table,
    dplyr::across(dplyr::where(is.numeric), ~ round_eps(.x, digits))
  )
}
#' Add Conforming Row(s) to an Input–Output Table
#'
#' Add a conforming row, or elements of a conforming row, to a named
#' input–output style data frame.
#'
#' @details
#' You can add rows in several ways:
#' * A **data frame** with one or more rows, where the first column contains
#'   row identifiers.
#' * A **named numeric vector**, which will be turned into a single-row
#'   data frame.
#'
#' If no `row_names` are supplied and the first column of `rows_to_add` is
#' numeric, new rows will be automatically labelled as `"new_row_1"`,
#' `"new_row_2"`, etc.
#'
#' Missing column values are filled with `empty_fill`, which defaults to `0`.
#' If you want to avoid division by zero in later computations, you can set
#' this to a very small value (e.g. `1e-6`).
#'
#' @param data_table A symmetric input–output table, a use table, a margins
#'   table, or a tax table retrieved by [iotable_get()].
#' @param rows_to_add A data frame or a named numeric vector containing the
#'   new row(s).
#' @param row_names Optional character vector giving names for the new key
#'   column. If `NULL`, names are inferred (see *Details*).
#' @param empty_fill Value used to fill missing columns. Defaults to `0`.
#'
#' @return
#' A `data.frame` containing the original `data_table` extended with the new
#' row(s).
#'
#' @family iotables processing functions
#' @importFrom dplyr bind_rows bind_cols
#'
#' @examples
#' rows_to_add <- data.frame(
#'   iotables_row = "CO2_emission",
#'   agriculture_group = 10448,
#'   industry_group = 558327, # construction is omitted
#'   trade_group = 11194
#' )
#'
#' rows_add(iotable_get(), rows_to_add = rows_to_add)
#'
#' rows_add(iotable_get(),
#'   rows_to_add = c(
#'     industry_group = 1534,
#'     trade_group = 4
#'   ),
#'   row_names = "CH4_emission"
#' )
#'
#' @export
rows_add <- function(data_table,
                     rows_to_add,
                     row_names = NULL,
                     empty_fill = 0) {
  if (is.numeric(rows_to_add)) {
    rows_to_add <- as.data.frame(t(rows_to_add))
  }

  if (is.null(row_names)) {
    if (!is.numeric(rows_to_add[, 1])) {
      key_column <- key_column_create(
        key_column_name = names(data_table)[1],
        key_column_values = unlist(rows_to_add[, 1])
      )
    } else {
      key_column <- key_column_create(
        key_column_name = names(data_table)[1],
        key_column_values = paste0("new_row_", seq_len(nrow(rows_to_add)))
      )
    }
  } else {
    if (nrow(rows_to_add) != length(row_names)) {
      stop("The number of rows to add and the number of row_names do not match.")
    }
    key_column <- key_column_create(
      key_column_name = names(data_table)[1],
      key_column_values = row_names
    )
  }

  columns_required <- ifelse(
    is_key_column_present(data_table),
    ncol(data_table) - 1,
    ncol(data_table)
  )

  numeric_names <- if (is_key_column_present(data_table)) {
    names(data_table)[-1]
  } else {
    names(data_table)
  }

  empty_values <- as.data.frame(
    matrix(
      rep(empty_fill, columns_required * nrow(rows_to_add)),
      ncol = columns_required
    )
  )
  names(empty_values) <- numeric_names
  empty_values <- bind_cols(key_column, empty_values)

  completed <- if (!is.numeric(rows_to_add[, 1])) {
    rows_to_add[, -1]
  } else {
    rows_to_add
  }

  to_complete_rows <- empty_values[, !names(empty_values) %in% names(completed)]
  dplyr::bind_rows(data_table, bind_cols(completed, to_complete_rows))
}
#' Add supplementary rows to an IO/SUT table
#'
#' @description
#' Append supplementary indicators (e.g., emissions coefficients) as new
#' rows to a symmetric input–output table (SIOT), use, supply, or margins
#' table. This is a light wrapper around [rows_add()].
#'
#' @details
#' Column names in `supplementary_data` must match the numeric columns of
#' `data_table`. If the key column is missing, it is created from
#' `supplementary_names` or auto-generated as `supplementary_row_#`.
#'
#' When a household final consumption column is present (e.g.,
#' `final_consumption_households`, `P3_S14`), new rows get `0` in that
#' column if the supplied values are `NA`.
#'
#' For terminology, see Eurostat’s *Manual of Supply, Use and Input-Output
#' Tables*.
#' (Eurostat, 2008; ISBN 978-92-79-04704-3)
#'
#' @param data_table
#'   A SIOT, use, supply, or margins table (key column + numeric columns).
#' @param supplementary_data
#'   A data frame (or tibble) of one or more rows to add. It may already
#'   contain a key column (first column). Otherwise, provide
#'   `supplementary_names` or the keys will be auto-generated. All other
#'   column names must match `data_table`.
#' @param supplementary_names
#'   Optional character vector of row names for the key column; length
#'   must equal `nrow(supplementary_data)`. Ignored if a key column is
#'   already present.
#'
#' @references
#' Table 15.13 (p. 494) in Beutel (2008),
#'  *Eurostat Manual of Supply, Use and Input–Output Tables*,
#' shows an environmental‐emission model built by adding CO₂ and CH₄ rows to
#' the German 1995 input–output coefficients.  The same construction is
#' reproduced here by `supplementary_add()` and the results are checked
#' against this example.

#' @return
#' A `data.frame` with the rows of `supplementary_data` bound to
#' `data_table` and aligned to its key and numeric columns.
#'
#' @seealso [convert_industry_to_product()]
#'
#' @family iotables processing functions
#' @importFrom dplyr bind_cols
#' @examples
#' de_io <- iotable_get()
#' CO2_coefficients <- data.frame(
#'   agriculture_group = 0.2379,
#'   industry_group = 0.5172,
#'   construction = 0.0456,
#'   trade_group = 0.1320,
#'   business_services_group = 0.0127,
#'   other_services_group = 0.0530
#' )
#' CH4_coefficients <- data.frame(
#'   agriculture_group = 0.0349,
#'   industry_group = 0.0011,
#'   construction = 0,
#'   trade_group = 0,
#'   business_services_group = 0,
#'   other_services_group = 0.0021
#' )
#' CO2 <- cbind(
#'   data.frame(iotables_row = "CO2"),
#'   CO2_coefficients
#' )
#' CH4 <- cbind(
#'   data.frame(iotables_row = "CH4_coefficients"),
#'   CH4_coefficients
#' )

#' de_coeff <- input_coefficient_matrix_create ( iotable_get() )
#' emissions <- rbind (CO2, CH4)
#'
#' # Check with the Eurostat Manual page 494:
#' supplementary_add(de_io, emissions)
#' @export

supplementary_add <- function(data_table,
                              supplementary_data,
                              supplementary_names = NULL) {
  if (!is.null(supplementary_names)) {
    if (length(supplementary_names) !=
      nrow(as.data.frame(supplementary_data))) {
      stop("New names do not match the dimensions of the supplementary data.")
    }
  }

  if (!is_key_column_present(supplementary_data)) {
    key_column <- key_column_create(
      names(data_table)[1],
      ifelse(is.null(supplementary_names),
        yes = paste0("supplementary_row_", 1:nrow(supplementary_data)),
        no = supplementary_names
      )
    )

    supplementary_data <- bind_cols(
      key_column, supplementary_data
    )
  } else {
    key_column <- supplementary_data[, 1]
    names(key_column) <- names(data_table)[1]
  }

  siot_ext <- rows_add(data_table, rows_to_add = supplementary_data)

  if (any(c("final_consumption_households", "p3_s14") %in% tolower(names(siot_ext)))) {
    household_col <- which(tolower(names(siot_ext)) %in% c("final_consumption_households", "p3_s14"))
    new_rows <- which(tolower(as.character(siot_ext[, 1])) %in% key_column)
    siot_ext[new_rows, household_col] <- ifelse(is.na(siot_ext[new_rows, household_col]), 0, siot_ext[new_rows, household_col])
  }

  siot_ext
}
#' @title Deprecated: Retrieve or download Eurostat dataset from temporary cache
#'
#' @description
#' ❌ **Deprecated** — This internal helper is retained only for backward
#' compatibility. It has been replaced by unified cache management inside
#' [iotables_download()] and [airpol_get()].
#'
#' The new caching system uses a session-local Eurostat cache directory
#' (`file.path(tempdir(), "eurostat")`) with persistent `.rds` storage for
#' downloaded tables.
#'
#' @param id Character. The Eurostat dataset identifier (e.g., `"naio_10_cp1700"`).
#' @param force_download Logical. If `TRUE`, forces a re-download and ignores
#' cached copies. Defaults to `FALSE`.
#'
#' @return A raw Eurostat data frame.
#' @keywords internal
#' @seealso [iotables_download()], [airpol_get()]
#' @importFrom eurostat get_eurostat clean_eurostat_cache
#' @export
tempdir_data <- function(id, force_download = FALSE) {
  deprecate_warn(
    # see utils.R
    old = "tempdir_data",
    new = "iotables_download",
    version = "0.9.5",
    details = "Use iotables_download() instead, which now manages Eurostat cache directly."
  )

  # Legacy behaviour
  tmpdir <- tempdir()
  processed_file <- file.path(tmpdir, paste0(id, "_processed.rds"))
  safe_read <- function(path) tryCatch(readRDS(path), error = function(e) NULL)

  if (!force_download && file.exists(processed_file)) {
    if (interactive()) message("Using cached processed file in tempdir().")
    data <- safe_read(processed_file)
    if (!is.null(data)) {
      return(data)
    }
  }

  cache_dir <- file.path(tmpdir, "eurostat")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)
  eurostat_files <- list.files(cache_dir, pattern = id, full.names = TRUE)

  if (!force_download && length(eurostat_files) >= 1) {
    if (interactive()) message("Using cached Eurostat file from ", cache_dir)
    data <- safe_read(eurostat_files[[1L]])
    if (!is.null(data)) {
      return(data)
    }
  }

  if (interactive()) {
    message(
      "Downloading Eurostat dataset ", id,
      " (force_download = ", force_download, ")."
    )
  }

  if (force_download) {
    unlink(processed_file, force = TRUE)
    if (length(eurostat_files)) unlink(eurostat_files, force = TRUE)
    suppressWarnings(eurostat::clean_eurostat_cache(cache_dir = cache_dir))
  }

  downloaded <- tryCatch(
    eurostat::get_eurostat(id, cache = !force_download, cache_dir = cache_dir),
    error = function(e) {
      message("Eurostat download failed for ", id, ": ", conditionMessage(e))
      NULL
    }
  )

  if (is.null(downloaded) || !is.data.frame(downloaded)) {
    stop("Download of ", id, " failed. Check Eurostat availability or identifier.")
  }

  downloaded
}
#' Add a total tax row (D.2–D.3 and D.29–D.39)
#'
#' @description
#' Create and append a **total tax** row by summing selected tax rows in the
#' primary inputs block (Quadrant III) of a SIOT or use table.
#'
#' @details
#' In Eurostat/ESA terminology, tax rows commonly include:
#' - **Taxes less subsidies on products** (codes D.2–D.3), and
#' - **Other net taxes on production** (codes D.29–D.39).
#'
#' These appear in the value-added (primary inputs) section of the use/SIOT
#' layout. The function sums the specified rows **column-wise** over all
#' numeric columns and appends the result as `total_tax_name`. If a household
#' final consumption column is present (e.g. `final_consumption_households`
#' or `p3_s14`), any missing value in the new total row is replaced by zero.
#'
#' @param data_table A symmetric input–output table (SIOT) or use table
#'   whose primary inputs include tax rows (see Details). Typically obtained
#'   via [iotable_get()].
#' @param tax_names Character vector of row labels to sum. Defaults to
#'   `c("d21x31","d29x39")`, shorthand for D.2–D.3 and D.29–D.39. Matching
#'   is currently made against the **lower-cased key column**.
#' @param total_tax_name Character scalar for the new row label. Default
#'   `"TOTAL_TAX"`. (See Enhancements regarding case handling.)
#'
#' @return
#' A data frame like `data_table`, with one additional row named
#' `total_tax_name` that equals the element-wise sum of the rows in
#' `tax_names` over numeric columns.
#'
#' @section Terminology:
#' Eurostat uses the lines “Taxes less subsidies on products” and “Other net
#' taxes on production” in published tables; these correspond, respectively,
#' to D.2–D.3 and D.29–D.39.
#'
#' @references
#' Eurostat (2008). *Eurostat Manual of Supply, Use and Input–Output Tables*,
#' ch. 13.
#' United Nations (2018). *Handbook on Supply and Use Tables and Input–Output
#' Tables with Extensions and Applications (Rev. 1, “white cover”)*, ch. 10.
#'
#' @examples
#' de_io <- iotable_get()
#' total_tax_add(
#'   data_table = de_io,
#'   tax_names = c("net_tax_products", "net_tax_production"),
#'   total_tax_name = "total_tax"
#' )
#'
#' @family iotables processing functions
#' @importFrom dplyr full_join summarise mutate across
#' @importFrom tidyselect where
#' @export

total_tax_add <- function(data_table,
                          tax_names = c("d21x31", "d29x39"),
                          total_tax_name = "TOTAL_TAX") {
  . <- NULL

  if (is.null(tax_names)) {
    stop("Tax names must be set.")
  }

  key_column <- tolower(as.character(unlist(data_table[, 1])))

  if (!all(tax_names %in% key_column)) {
    stop(
      "The tax names ",
      paste(tax_names, collapse = ", "),
      " (not case sensitive) were not found in the data table."
    )
  }

  tax <- data_table[which(key_column %in% tax_names), ]

  tax <- summarise(tax, across(where(is.numeric), sum)) %>%
    cbind(data_table[1, 1], .) %>%
    dplyr::mutate(across(where(is.factor), as.character))

  tax[1, 1] <- total_tax_name

  names(tax)[1] <- names(data_table)[1]

  siot_ext <- full_join(
    mutate(data_table, across(where(is.factor), as.character)), tax,
    by = names(tax)
  )

  if (any(c("final_consumption_households", "p3_s14") %in% tolower(names(siot_ext)))) {
    household_col <- which(tolower(names(siot_ext)) %in% c("final_consumption_households", "p3_s14"))
    new_row <- which(tolower(as.character(siot_ext[, 1])) %in% total_tax_name)

    siot_ext[new_row, household_col] <- ifelse(test = is.na(siot_ext[new_row, household_col]),
      yes  = 0,
      no   = siot_ext[new_row, household_col]
    )
  } # end of households case

  siot_ext
}
#' Get United Kingdom Input-Output Analytical Tables, 2010
#'
#' This function will retrieve any primary input from the input-output
#' table: United Kingdom Input-Output Analytical Tables, 2010
#' (consistent with UK National Accounts Blue Book 2013 &
#'  UK Balance of Payments Pink Book 2013)
#' by Richard Wild.
#' @param path A path to the downloaded file, if already exists, given with
#' \code{file.path()} function.
#' @source \href{https://www.ons.gov.uk/file?uri=/economy/nationalaccounts/supplyandusetables/datasets/ukinputoutputanalyticaltablesdetailed/2010detailed/ukioanalyticaltablesio1062010detailedpubversion.xls}{ukioanalyticaltablesio1062010detailedpubversion.xls}
#' @importFrom dplyr select mutate across left_join
#' @importFrom dplyr bind_cols
#' @importFrom tidyr pivot_longer pivot_wider
#' @importFrom tibble rownames_to_column tibble
#' @importFrom rlang set_names
#' @importFrom utils download.file
#' @importFrom readxl read_excel

#' @examples
#' \dontrun{
#' uk2010 <- uk_2010_get()
#' }
#' @keywords internal

uk_2010_get <- function(path = NULL) {
  ## Non-standard evaluation variable initiatlization -----------------

  if (is.null(path)) {
    path <- file.path(
      tempdir(),
      "ukioanalyticaltablesio1062010detailedpubversion.xls"
    )
  }

  if (!file.exists(path)) {
    utils::download.file("https://www.ons.gov.uk/file?uri=/economy/nationalaccounts/supplyandusetables/datasets/ukinputoutputanalyticaltablesdetailed/2010detailed/ukioanalyticaltablesio1062010detailedpubversion.xls",
      file.path(
        tempdir(),
        "ukioanalyticaltablesio1062010detailedpubversion.xls"
      ),
      mod = "wb"
    )
  }

  metadata_skip <- 1
  column_spec_skip <- 5

  for (i in 2:8) {
    data_skip <- column_spec_skip + 1

    uk_metadata <- readxl::read_excel(path,
      sheet = i,
      skip = metadata_skip,
      col_names = FALSE,
      n_max = 2
    ) %>%
      rlang::set_names("values") %>%
      bind_cols(tibble::tibble(vars = c("indicator", "unit"))) %>%
      pivot_wider(names_from = vars, values_from = values)
    # tidyr::spread ( vars, values )

    message("Reading ... ", uk_metadata$indicator)


    uk_column_specs <- readxl::read_excel(path,
      sheet = i,
      skip = column_spec_skip,
      col_names = FALSE,
      n_max = 2
    ) %>%
      select(-1) %>%
      tibble::rownames_to_column() %>%
      pivot_longer(-all_of("rowname"), names_to = "var", values_to = "value") %>%
      tidyr::pivot_wider(names_from = rowname, values_from = value) %>%
      rlang::set_names(c("remove", "uk_col", "uk_col_lab")) %>%
      dplyr::select(-remove) %>%
      mutate(across(where(is.factor), as.character))

    uk_data_sheet <- readxl::read_excel(path,
      sheet = i,
      skip = data_skip,
      col_names = TRUE
    ) %>%
      pivot_longer(
        cols = 3:ncol(.),
        names_to = "uk_col_lab",
        values_to = "values"
      ) %>%
      # tidyr::gather( uk_col_lab, values, !!3:ncol(.)) %>%
      rlang::set_names(c("uk_row", "uk_row_lab", "uk_col_lab", "values")) %>%
      mutate(values = as.numeric(as.character(.data$values))) %>%
      dplyr::left_join(uk_column_specs,
        by = "uk_col_lab"
      ) %>%
      mutate(indicator = uk_metadata$indicator) %>%
      mutate(unit = uk_metadata$unit) %>%
      mutate(across(where(is.factor), as.character))

    uk_data_sheet <- uk_data_sheet %>%
      mutate(
        uk_col = ifelse(grepl("on-market", uk_col_lab),
          paste0("NM_", uk_col),
          uk_col
        ),
        uk_row = ifelse(grepl("on-market", uk_row_lab),
          paste0("NM_", uk_row),
          uk_row
        )
      ) %>%
      mutate(
        uk_col = ifelse(grepl("NPISH", uk_col_lab),
          paste0("NPISH_", uk_col),
          uk_col
        ),
        uk_row = ifelse(grepl("NPISH", uk_row_lab),
          paste0("NPISH_", uk_row),
          uk_row
        )
      )

    if (i > 2) uk_data <- rbind(uk_data, uk_data_sheet) else uk_data <- uk_data_sheet
  }

  remove_dot <- function(x) gsub("\\.", "-", x)

  uk_data %>%
    mutate(uk_col_lab = gsub("\n", " ", uk_col_lab)) %>%
    mutate(uk_col_lab = trimws(.data$uk_col_lab, "both")) %>%
    mutate(uk_col = ifelse(is.na(.data$uk_col), uk_col_lab, uk_col)) %>%
    mutate(uk_row = ifelse(is.na(.data$uk_row), uk_row_lab, uk_row)) %>%
    mutate(across(all_of(c("uk_row", "uk_col")), remove_dot)) %>%
    mutate(values = ifelse(is.na(.data$values), 0, values)) %>%
    mutate(geo = "UK") %>%
    mutate(year = 2010) %>%
    mutate(unit = "MIO_NAC") %>%
    mutate(unit_lab = "Million national currency") %>%
    mutate(geo_lab = "United Kingdom")
}
#' Get United Kingdom Multipliers and Effects, 2010
#'
#' This function will retrieve the published effects and multipliers from the
#' United Kingdom Input-Output Analytical Tables, 2010
#' (consistent with UK National Accounts Blue Book 2013 &
#'  UK Balance of Payments Pink Book 2013)
#' by Richard Wild.
#' @param path A path to the downloaded file, if already exists, given with
#' \code{file.path()} function.
#' @source \href{https://www.ons.gov.uk/file?uri=/economy/nationalaccounts/supplyandusetables/datasets/ukinputoutputanalyticaltablesdetailed/2010detailed/ukioanalyticaltablesio1062010detailedpubversion.xls}{ukioanalyticaltablesio1062010detailedpubversion.xls}
#' @importFrom dplyr select across mutate rename
#' @importFrom tibble tibble
#' @importFrom rlang set_names
#' @importFrom utils download.file
#' @importFrom tidyr pivot_wider
#' @importFrom readxl read_excel

#' @examples
#' \dontrun{
#' uk_results <- iotables:::uk_2010_results_get()
#' }
uk_2010_results_get <- function(path = NULL) {
  if (is.null(path)) {
    path <- file.path(
      tempdir(),
      "ukioanalyticaltablesio1062010detailedpubversion.xls"
    )
  }

  if (!file.exists(path)) {
    utils::download.file("https://www.ons.gov.uk/file?uri=/economy/nationalaccounts/supplyandusetables/datasets/ukinputoutputanalyticaltablesdetailed/2010detailed/ukioanalyticaltablesio1062010detailedpubversion.xls",
      file.path(tempdir(), "ukioanalyticaltablesio1062010detailedpubversion.xls"),
      mod = "wb"
    )
  }

  metadata_skip <- 1
  column_spec_skip <- 5
  i <- 9
  data_skip <- column_spec_skip + 1

  uk_metadata <- readxl::read_excel(path,
    sheet = i,
    skip = metadata_skip,
    col_names = FALSE,
    n_max = 2
  ) %>%
    select(1) %>%
    set_names("values") %>%
    cbind(tibble::tibble(vars = c("indicator", "unit"))) %>%
    pivot_wider(names_from = vars, values_from = values)

  message("Reading ... ", uk_metadata$indicator)


  uk_published_multipliers <- readxl::read_excel(path,
    sheet = i,
    skip = 4,
    col_names = TRUE
  ) %>%
    select(-1) %>%
    dplyr::rename(
      uk_row_label = Product,
      output_multiplier_rank = Rank...4,
      employment_cost_multiplier = Rank...6,
      gva_multiplier_rank = Rank...8,
      employment_cost_effects_rank = Rank...10,
      gva_effects_rank = Rank...12
    ) %>%
    mutate(indicator = uk_metadata$indicator[1]) %>%
    mutate(across(where(is.factor), as.character))

  uk_published_multipliers
}
#' Various internal functions to work with IOT metadata, including the labelling
#' vocabularies, row and column ordering.
#' None of these functions should be exported.

#' Internal helper to load datasets safely from the iotables package
#'
#' @description
#' A robust internal utility that retrieves datasets by name, accepting
#' either a quoted string (`"ind_ava"`) or a bare object name (`ind_ava`).
#' It uses `utils::data()` to load objects into a temporary environment and
#' returns the requested dataset invisibly. If the dataset is not found,
#' a clear error message is raised (without warnings from `utils::data()`).
#'
#' @param x Unquoted or quoted dataset name (character or symbol).
#' @return The dataset as a data frame or tibble.
#' @keywords internal
#' @examples
#' \dontrun{
#' getdata(ind_ava)
#' getdata("prd_use")
#' }
getdata <- function(x) {
  # Handle both bare and quoted dataset names
  name <- tryCatch(
    {
      nm <- deparse(substitute(x))
      if (is.character(x) && length(x) == 1L) nm <- x
      nm
    },
    error = function(e) {
      stop("Invalid argument for 'x': must be a dataset name or string.", call. = FALSE)
    }
  )

  # Prepare an isolated environment
  e <- new.env(parent = emptyenv())

  # Try loading dataset quietly
  success <- tryCatch(
    suppressMessages(
      suppressWarnings(
        utils::data(list = name, envir = e, package = "iotables")
      )
    ),
    warning = function(w) { # suppress "data set not found"
      invokeRestart("muffleWarning")
    },
    error = function(err) {
      stop(
        "Dataset '", name, "' not found in iotables package data.",
        "\nOriginal message: ", conditionMessage(err),
        call. = FALSE
      )
    }
  )

  # Return dataset if found
  if (!exists(name, envir = e)) {
    stop("Dataset '", name, "' not found in iotables package data.", call. = FALSE)
  }

  e[[name]]
}



#' @keywords internal
define_prod_ind <- function() {
  ## Define which sources follow the prod_ind vocabulary.
  ## The rest of the potential sources follows the induse vocabulary, except for the Croatia
  ## replication data.

  c(
    "naio_10_cp1700", "naio_10_cp1750", "naio_10_pyp1700",
    "naio_10_pyp1750", "naio_10_cp15", "naio_10_cp16",
    "naio_10_cp1610", "naio_10_cp1620", "naio_10_cp1630",
    "naio_10_pyp1620", "naio_10_pyp1630", "germany_1995"
  )
}

#' @keywords internal
adjust_stk_flow <- function(stk_flow, source) {
  if (source %in% c(
    "naio_10_cp1620", "naio_10_cp1630",
    "naio_10_pyp1620", "naio_10_pyp1630"
  )
  ) {
    "TOTAL" # Tax and margin tables only have one version
  } else {
    stk_flow
  }
}

#' @keywords internal
get_vocabulary_prod_ind <- function() {
  getdata("metadata") %>% # For tables that follow prod_ind vocabulary
    filter(variable == "prod_na") %>%
    dplyr::rename(prod_na = code) %>%
    dplyr::rename(prod_na_lab = label) %>%
    dplyr::rename(row_order = numeric_label) %>%
    dplyr::rename(iotables_row = iotables_label)
}

#' @keywords internal
get_vocabulary_induse <- function() {
  getdata("metadata") %>% # For tables that follow the induse vocabulary
    filter(variable == "induse") %>%
    dplyr::rename(induse = code) %>%
    dplyr::rename(induse_lab = label) %>%
    dplyr::rename(col_order = numeric_label) %>%
    dplyr::rename(iotables_col = iotables_label)
}

#' @keywords internal
get_vocabulary_t_rows <- function() {
  getdata("metadata") %>%
    filter(variable == "t_rows") %>%
    dplyr::rename(t_rows2 = code) %>%
    dplyr::rename(t_rows2_lab = label) %>%
    dplyr::rename(row_order = numeric_label) %>%
    dplyr::rename(iotables_row = iotables_label)
}

#' @importFrom dplyr rename
#' @keywords internal
get_vocabulary_t_cols <- function() {
  getdata("metadata") %>%
    filter(variable == "t_cols") %>%
    dplyr::rename(t_cols2 = code) %>%
    dplyr::rename(t_cols2_lab = label) %>%
    dplyr::rename(col_order = numeric_label) %>%
    dplyr::rename(iotables_col = iotables_label)
}

#' @keywords internal
get_metadata_rows <- function(source) {
  prod_ind <- define_prod_ind()
  trow_tcol <- croatia_files <- c(
    "croatia_2010_1700", "croatia_2010_1800",
    "croatia_2010_1900"
  )

  uk_tables <- c(
    "uk_2010_siot", "uk_2010_use", "uk_2010_imports",
    "uk_2010_coeff", "uk_2010_inverse"
  )

  if (source %in% prod_ind) {
    get_vocabulary_prod_ind()
  } else if (source %in% trow_tcol) {
    get_vocabulary_t_rows()
  } else if (source %in% uk_tables) {
    getdata("metadata_uk_2010") %>%
      filter(!is.na(.data$uk_row)) %>%
      select(-all_of(c("uk_col", "uk_col_label", "induse", "col_order"))) %>%
      mutate(uk_row = gsub("\\.", "-", as.character(.data$uk_row))) %>%
      mutate(uk_row = gsub(" & ", "-", as.character(.data$uk_row)))
  } else {
    stop("Don't know which row name vocabulary to use.")
  }
}

#' @keywords internal
get_metadata_cols <- function(source) {
  prod_ind <- define_prod_ind()

  trow_tcol <- croatia_files <- c(
    "croatia_2010_1700", "croatia_2010_1800",
    "croatia_2010_1900"
  )

  uk_tables <- c("uk_2010_siot", "uk_2010_use", "uk_2010_imports", "uk_2010_coeff", "uk_2010_inverse")

  if (source %in% prod_ind) {
    get_vocabulary_induse()
  } else if (source %in% trow_tcol) {
    get_vocabulary_t_cols()
  } else if (source %in% uk_tables) {
    getdata("metadata_uk_2010") %>%
      filter(!is.na(.data$uk_col)) %>%
      select(-uk_row, -uk_row_label, -prod_na, -row_order) %>%
      mutate(uk_col = gsub("\\.", "-", as.character(.data$uk_col))) %>%
      mutate(uk_col = gsub(" & ", "-", as.character(.data$uk_col))) %>%
      mutate(uk_col = trimws(.data$uk_col, "both"))
  }
}
#' Pipe operator
#'
#' See \code{magrittr::\link[magrittr:pipe]{\%>\%}} for details.
#'
#' This re-exports the pipe operator from **magrittr** so that it can be
#' used within the package without explicitly attaching magrittr.
#'
#' @name %>%
#' @rdname pipe
#' @keywords internal
#' @export
#' @importFrom magrittr %>%
#' @usage lhs \%>\% rhs
#' @param lhs A value or the magrittr placeholder.
#' @param rhs A function call using magrittr semantics.
#' @return The result of calling `rhs(lhs)`.
NULL
#' @keywords internal
fn_na_to_null <- function(x) ifelse(is.na(x), 0, x)

#' @title Ensure L68-related columns exist
#'
#' @description Internal helper that guarantees the requested real-estate
#'   columns exist in a wide-format data frame. Missing columns are appended with
#'   zeros, while existing non-zero values are preserved.
#'
#' @param data A wide `data.frame`.
#' @param columns Character vector of column names that must be present.
#'
#' @return The input data frame with any missing columns added and filled with
#'   zeros.
#'
#' @keywords internal
ensure_l68_columns <- function(data, columns) {
  assertthat::assert_that(
    is.data.frame(data),
    msg = "`data` must be a data.frame"
  )

  assertthat::assert_that(
    is.character(columns),
    length(columns) > 0,
    msg = "`columns` must be a non-empty character vector"
  )

  missing_columns <- setdiff(columns, names(data))

  for (column in missing_columns) {
    data[[column]] <- 0
  }

  data
}

#' @title Validate source parameter
#'
#' @description Internal function that checks whether the given `source`
#'   argument matches one of the supported Eurostat or UK table identifiers.
#'
#' @param source A character string naming the desired source table.
#'
#' @return Invisibly returns the validated source string, otherwise throws an
#'   error if the source is not supported.
#'
#' @keywords internal
validate_source <- function(source) {
  possible_download_sources <- c(
    "naio_10_cp1700", "naio_10_cp1750",
    "naio_10_pyp1700", "naio_10_pyp1750",
    "naio_10_cp15", "naio_10_cp16",
    "naio_10_cp1610", "naio_10_pyp1610",
    "naio_10_cp1620", "naio_10_pyp1620",
    "naio_10_cp1630", "naio_10_pyp1630",
    "uk_2010"
  )
  source <- tolower(source)
  if (!source %in% possible_download_sources) {
    supported_tables <- paste(possible_download_sources, collapse = ", ")
    stop(
      source, " is not in supported tables [", supported_tables, "]"
    )
  }
  invisible(source)
}

#' @title Check if a key column is present
#'
#' @description Tests whether the first column of a data frame contains either
#'   non-numeric values (default) or any of the `potential_keywords` supplied.
#'
#' @param data_table A data frame with a key column in its first position.
#' @param potential_keywords Optional character vector of keywords expected in
#'   the key column. Defaults to `NULL`, in which case the function only asserts
#'   that the first column is not numeric.
#'
#' @return A logical scalar: `TRUE` if the key column is valid, otherwise throws
#'   an error with a descriptive message.
#'
#' @importFrom assertthat assert_that
#' @importFrom glue glue
#'
#' @keywords internal
is_key_column_present <- function(data_table, potential_keywords = NULL) {
  assertthat::assert_that(
    "data.frame" %in% class(data_table),
    msg = "The 'data_table' must be a data.frame."
  )

  if (!is.null(potential_keywords)) {
    msg_potential_keywords <- paste(potential_keywords, collapse = "', '")
    assertthat::assert_that(
      any(potential_keywords %in% data_table[, 1]),
      msg = glue::glue(
        "The data_table has no key column containing any of ",
        "'{msg_potential_keywords}'."
      )
    )
  } else {
    assertthat::assert_that(
      !is.numeric(data_table[, 1]),
      msg = "The data_table has no key column (expected non-numeric first col)."
    )
  }
  TRUE
}

#' @title Collapse character vectors
#'
#' @description A wrapper around [base::paste()] that conditionally collapses a
#'   character vector. If the vector length is greater than one, it is collapsed
#'   using the supplied separator. Used internally to create legible error
#'   messages.
#'
#' @param x A character vector.
#' @param collapse A separator string used if `x` has more than one element.
#'
#' @return A character string of length one if `x` has length > 1, otherwise the
#'   original vector unchanged.
#'
#' @keywords internal
chars_collapse <- function(x, collapse = ", ") {
  if (length(x) > 1) x <- paste(x, collapse = collapse)
  x
}


# Internal helper for deprecation messages without lifecycle dependency
#' @keywords internal
deprecate_warn <- function(old,
                           new = NULL,
                           version = NULL,
                           details = NULL) {
  msg <- paste0("⚠️  The function `", old, "()` is deprecated")
  if (!is.null(version)) msg <- paste0(msg, " since version ", version)
  if (!is.null(new)) msg <- paste0(msg, " — use `", new, "()` instead")
  if (!is.null(details)) msg <- paste0(msg, ". ", details)
  warning(msg, call. = FALSE)
}
#' Transpose a Vector to Long Form
#'
#' Convert a wide-form vector (e.g., indicators or multipliers) into long form,
#' which is often more useful for printing or joining. This is a thin wrapper
#' around [tidyr::pivot_longer()], provided so you do not need to load **tidyr**
#' explicitly.
#'
#' @param data_table A `data.frame` or tibble. The first column is assumed to
#'   be a key column.
#' @param names_to Name of the new column containing previous column names.
#'   Default: `"nace_r2"`.
#' @param values_to Name of the new column containing the values. Default:
#'   `"value"`.
#' @param key_column_name Optional. New name for the first (key) column. If
#'   `NULL` (default), the name is not changed.
#' @param .keep Logical. If `TRUE`, keep the indicator identifier column. If
#'   `FALSE` (default), drop it.
#'
#' @return A tibble in long format with a key column and, if requested, the
#'   indicator identifier column.
#'
#' @family iotables processing functions
#'
#' @examples
#' vector_transpose_longer(
#'   data.frame(
#'     indicator = "my_indicator",
#'     agriculture = 0.0123,
#'     manufacturing = 0.1436,
#'     trade = 0.0921
#'   )
#' )
#'
#' # Keep the indicator column
#' vector_transpose_longer(
#'   data.frame(
#'     indicator = "my_indicator",
#'     agriculture = 0.0123,
#'     manufacturing = 0.1436
#'   ),
#'   .keep = TRUE
#' )
#' @export
vector_transpose_longer <- function(data_table,
                                    names_to = "nace_r2",
                                    values_to = "value",
                                    key_column_name = NULL,
                                    .keep = FALSE) {
  is_key_column_present(data_table)
  key_column <- names(data_table)[1]

  return_df <- data_table %>%
    tidyr::pivot_longer(
      -all_of(key_column),
      names_to  = names_to,
      values_to = values_to
    )

  if (.keep) return_df else return_df[, -1]
}

#' @rdname vector_transpose_longer
vector_transpose <- function(data_table,
                             names_to = "nace_r2",
                             values_to = "value",
                             key_column_name = NULL,
                             .keep = FALSE) {
  .Deprecated(new = "vector_transpose_longer")

  vector_transpose_longer(data_table, names_to, values_to, key_column_name, .keep)
}


#' Transpose a Vector to Wide Form
#'
#' Convert a long-form vector (e.g., indicators, multipliers) into wide form,
#' which is often more useful for binding with input–output tables. This is a
#' thin wrapper around [tidyr::pivot_wider()], provided so you do not need to
#' load **tidyr** explicitly.
#'
#' @inheritParams key_column_create
#' @param data_table A `data.frame` or tibble, normally with a key column.
#'   If the key column must be created or replaced, use `key_column_name` and
#'   `key_column_values`.
#' @param names_from,values_from Columns specifying the names of the output
#'   columns (`names_from`) and the values to fill (`values_from`).
#' @param key_column_values Optional explicit key column values. Default:
#'   `NULL`, in which case values are inferred from the long data.
#'
#' @family iotables processing functions
#'
#' @examples
#' vector_transpose_wider(
#'   data_table = germany_airpol[, -2],
#'   names_from = "induse",
#'   values_from = "value"
#' )
#'
#' vector_transpose_wider(
#'   data_table = germany_airpol[1:8, 3:4],
#'   names_from = "induse",
#'   values_from = "value",
#'   key_column_values = "CO2_emission"
#' )
#' @export

vector_transpose_wider <- function(data_table,
                                   names_from,
                                   values_from,
                                   key_column_name = NULL,
                                   key_column_values = NULL) {
  if (is.null(key_column_name)) key_column_name <- names(data_table)[1]

  assertthat::assert_that(names_from %in% names(data_table),
    msg = glue("in vector_transpose_wider(data_table, names_from='{names_from}') '{names_from}' cannot be found in the data_table")
  )

  assertthat::assert_that(values_from %in% names(data_table),
    msg = glue("in vector_transpose_wider(data_table, values_from='{values_from}') '{values_from}' cannot be found in the data_table")
  )

  if (ncol(data_table) >= 2 && is_key_column_present(data_table) && is.null(key_column_values)) {
    pivot_wider(
      data_table,
      names_from = all_of(names_from),
      values_from = all_of(values_from)
    )
  } else if (is_key_column_present(data_table) && !is.null(key_column_values) &&
    names(data_table)[1] != names_from) {
    bind_cols(
      key_column_create(key_column_name, key_column_values),
      pivot_wider(
        data_table %>% select(-1),
        names_from = all_of(names_from),
        values_from = all_of(values_from)
      )
    )
  } else {
    bind_cols(
      key_column_create(key_column_name, key_column_values),
      pivot_wider(
        data_table,
        names_from = all_of(names_from),
        values_from = all_of(values_from)
      )
    )
  }
}


#' @title Create a key columnn
#' @description Create a key column for matching the dimensions of matrixes.
#' @details This function will likely be used with the creation of coefficients that need to be matched with
#' a matrix that has a key column.
#' @param key_column_name The name of the key column.
#' @param key_column_values The value(s) of the key column
#' @return A tibble with one column, named \code{key_column_name} and with values \code{key_column_values}.
#' @importFrom tibble tibble
#' @importFrom rlang set_names
#' @family iotables processing functions
#' @examples
#' key_column_create("iotables_row", c("CO2_multiplier", "CH4_multiplier"))
#' @export
key_column_create <- function(key_column_name,
                              key_column_values = NULL) {
  tibble::tibble(names = as.character(key_column_values)) %>%
    rlang::set_names(key_column_name)
}


---
title: "Environmental Impacts"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Environmental Impacts}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setupknitr, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
load(system.file(
  file.path("extdata", "environmental_impact_vignette.rda"),
  package = "iotables"
))
```

```{r setup, echo=FALSE, message=FALSE}
library(iotables)
library(dplyr, quietly = TRUE)
library(tidyr, quietly = TRUE)
```

In this example, we show which economic activities contribute most to greenhouse gas emissions in Belgium. We want to know how much an additional unit of production increases the CO₂-equivalent of various greenhouse gases, including methane (CH₄), nitrous oxide (N₂O), and fluorinated gases (e.g., chlorofluorocarbons, hydrochlorofluorocarbons, and halons).

While CO₂ is emitted in the greatest quantity, it is not the only culprit for global warming, and fluorinated gases have a particularly high potential to increase the greenhouse effect; therefore, in this example, we will work with the combined CO₂-equivalent effect of all greenhouse gases, abbreviated with `GHG`.

## Importing the data

The following expression will import the symmetric input-output table for Belgium (product-by-product, ESA 2010 transmission `naio_10_cp1700`). The \`stk_flow = "TOTAL"\`\`makes clear that we are not only considering effects in the domestic (Belgian) economy, but imports, too, because TOTAL covers both domestic and imported intermediate and final uses (ESA 2010 code TOTAL = DOM + IMP)

More about importing and working with matrices can be found in the articles ([Introduction to iotables](https://iotables.dataobservatory.eu/articles/intro.html), [Working with Eurostat Data](https://iotables.dataobservatory.eu/articles/working_with_eurostat.html).)

```{r getiotable, eval=FALSE}
# For faster building this data can be loaded from "../extdata/environmental_impact_vignette.rda"
BE <- iotable_get(
  source = "naio_10_cp1700",
  geo = "BE",
  year = 2020,
  labelling = "short",
  unit = "MIO_EUR",
  stk_flow = "TOTAL"
)
```

The following expression gets the the greenhouse gas emissions in CO₂ CO₂ equivalent thousand tons for Belgium in 2020. Under the hood, we download the air emissions accounts from the Eurostat data warehouse. Air Emissions Accounts (AEA), an official satellite account compiled according to the SEEA-CF (*System of Environmental-Economic Accounting 2012: Central Framework*), present data on air emissions in a way that is fully compatible with the concepts, principles and data of the national accounts, but needs further adjustment to input-output tables, which is accomplished by `airpol_get()`

```{r getairpol, eval=FALSE}
# For faster building this data has been loaded from "../extdata/environmental_impact_vignette.rda"
ghg <- airpol_get(
  airpol = "GHG",
  geo = "BE",
  year = 2020,
  unit = "THS_T"
)
```

See `?airpol_get` for the type of air pollutants that you can add to a European standard SIOT. In this case, we will first use the calculated CO₂-equivalent of mix of gases. We are calculating in thousands of tons in this case (`unit="THS_T"`).

Because we work with the `naio_10_cp1700` matrix, which is derived from product x product sources, the industry names of the SIOT start with `CPA`.

```{r siotnames}
names(BE)[1:3]
```

The AEA uses NACE Rev. 2 (industry basis):

```{r ghgnames}
names(ghg)[1:3]
```

The following utility will adjust the supplementary data. This corresponds to the bridge matrix (B) defined in Eurostat Manual §15.4.2 that is used to transform industry-based extensions to product-based form.

You do not need to make this step if you work with `naio_10_cp1750` SIOT data, which is estimated from industry x industry sources, and it uses NACE-like abbreviations.

```{r convertocpa}
ghg_prod <- convert_industry_to_product(ghg)
names(ghg_prod)[1:3]
```

## Direct and multiplied effects

The direct effects will show how many thousand tons of extra greenhouse gases will be emitted per million euros of output at basic prices (t CO₂-eq / million €) from Belgium's industries. We are adding with `supplementary_add()`—which wraps `rows_add()`—the greenhouse gas vector in a conforming form to inter-industry matrix of Belgium. We will only print the top five emitters.

```{r ghgindicators}
be_io <- BE %>%
  supplementary_add(ghg_prod)

ghg_indicator <- input_indicator_create(
  data_table = be_io,
  input_row  = "GHG_emission"
)
```

The greenhouse gas intensity indicator (direct emissions per unit of output):

```{r ghgindicator}
# Only the top 5 is printed, rename, arrange and top_n are tidyverse functions:
ghg_indicator %>%
  vector_transpose_longer(.keep = TRUE) %>%
  rename(GHG_emission_indicator = .data$value) %>%
  arrange(-.data$GHG_emission_indicator) %>%
  top_n(5)
```

In Belgium (based on the 2020 structure of the economy and considering 2020 emission levels) the most greenhouse gas intensive sectors are the usual suspects, but with a bit surprising top emitter.

| NACE code | Activity |
|:----------------------------|:-----------------------------------------:|
| A03 | Fishing and aquaculture |
| A01 | Crop and animal production, hunting and related service activities |
| H51 | Air transport |
| C23 | Manufacture of other non-metallic mineral products |
| D | Electricity, gas, steam and air conditioning supply |

This indicator shows only the direct greenhouse-gas emissions (CO₂, CH₄, N₂O and fluorinated gases) generated by each economic activity itself. It does not yet include the indirect emissions that occur along the value chain — the upstream supplier industries that provide intermediate inputs (backward linkages) or the downstream users that purchase and transform the outputs (forward linkages).

To capture the full environmental impact of final demand, these indirect effects are estimated using the Leontief inverse, which traces how additional demand for one product propagates through all interconnected industries.

The category *Manufacture of other non-metallic mineral products* requires some clarification. It covers a range of activities transforming mined or quarried non-metallic minerals — such as sand, gravel, stone, clay and refractory materials — by grinding, mixing, cutting, shaping or firing them into products for intermediate or final use. In practice, these are largely construction-related materials, so this sector reflects the environmental footprint of the building-products supply chain.

Let's make a reality check, and calculate only with CO₂:

```{r getco2indicators, eval=FALSE}
co2 <- airpol_get(
  airpol = "CO2",
  geo = "BE",
  year = 2020,
  unit = "THS_T"
)
```

```{r co2indicators}
be_io_c <- BE %>%
  supplementary_add(
    co2 %>% convert_industry_to_product()
  )

co2_indicator <- input_indicator_create(
  data_table  = be_io_c,
  input_row   = "CO2_emission"
)

# Only the top 5 is printed:
co2_indicator %>%
  vector_transpose_longer(.keep = TRUE) %>%
  rename(CO2_emission_indicator = .data$value) %>%
  arrange(-.data$CO2_emission_indicator) %>%
  top_n(5)
```

*Crop and animal production, hunting and related service activities* falls out, and *CPA_H50 Water transport* comes back. Are those barges really so clean? And what happened with the agriculture?

Let's check methane, which is a far more potent green house gas than CO₂.

```{r getmethaneindicators, eval=FALSE}
methane <- airpol_get(
  airpol = "CH4",
  geo = "BE",
  year = 2020,
  unit = "THS_T"
)
```

```{r methaneindicators}
be_io_m <- BE %>%
  supplementary_add(
    methane %>% convert_industry_to_product()
  )

methane_indicator <- input_indicator_create(
  data_table = be_io_m,
  input_row  = "CH4_emission"
)

# Only the top 5 is printed:
methane_indicator %>%
  vector_transpose_longer(.keep = TRUE) %>%
  rename(CH4_emission_indicator = .data$value) %>%
  arrange(-.data$CH4_emission_indicator) %>%
  top_n(5)
```

| NACE code | Activity |
|:----------------------------|:-----------------------------------------:|
| A01 | Crop and animal production, hunting and related service activities |
| E37-39 | Sewerage, waste management, remediation activities |
| D | Electricity, gas, steam and air conditioning supply |
| B | Mining and quarrying |
| A02 | Forestry and logging |

The appearance of *Mining and quarrying* is important, because it is the main input for the *Manufacture of other non-metallic mineral products*. Their effect may or may not be combined *in Belgium*, because the Belgian manufacturers can import mined or quarried products, too.

## Total effects

The multiplier considers these indirect effects, too. The top five polluters remain the same, but their ordering changes. *Crop and animal production, hunting and related service activities* goes ahead of *Fishing and aquaculture*---because methane is a more potent green house gas than CO₂. Cattle and sheep emit plenty of methane, and there are plenty of cattle and sheep in Belgium. The reason why it is important to consider these effects for each and every country, or, when possible, for regions, is that different countries produce different crops and animals. Producing poultry is far less problematic from a green house emission point of view than producing beef products.

As expected, the *Manufacture of other non-metallic mineral products* gets ahead of *Air transport* as it is highly interrelated with *Mining and quarrying*. Making building more sustainable would be a great achievement, but there is no really clear path: as we can see, *Forestry and logging* come with their problems, too.

```{r ghgmultiplier, message=FALSE, eval=FALSE}
I_be <- input_coefficient_matrix_create(
  data_table = BE,
  digits = 4
) %>%
  leontief_inverse_create()

ghg_multipliers <- multiplier_create(
  input_vector = ghg_indicator,
  Im = I_be,
  multiplier_name = "GHG_multiplier",
  digits = 4
)

# Only the top 5 is printed:
ghg_multipliers %>%
  vector_transpose_longer(.keep = TRUE) %>%
  rename(GHG_multiplier = .data$value) %>%
  arrange(-.data$GHG_multiplier) %>%
  top_n(5)
```

## Validation Summary

All analytical and extension functions used in this vignette were validated against the official numerical examples published in **Beutel (2008)**, *Eurostat Manual of Supply, Use and Input–Output Tables* (Luxembourg: Office for Official Publications of the European Communities).\
The table below lists the correspondence between each function and the reference table reproduced during package testing.

```{r validation, results='asis'}
cat(knitr::kable(
  data.frame(
    Function = c(
      "input_coefficient_matrix_create()",
      "leontief_matrix_create()",
      "leontief_inverse_create()",
      "supplementary_add()",
      "input_indicator_create()",
      "multiplier_create()"
    ),
    Concept = c(
      "Direct requirements (A)",
      "Leontief matrix (I − A)",
      "Total requirements (L = (I − A)⁻¹)",
      "Environmental extension (CO₂, CH₄)",
      "Input indicators (GVA, Compensation)",
      "Total multipliers (GVA, Employment)"
    ),
    Table = c("15.6", "15.9", "15.10", "15.13", "15.14", "15.16"),
    Page = c("485", "487", "488", "494", "498", "503–504")
  ),
  caption = "Cross-reference of package functions with Eurostat Manual (Beutel 2008)"
))
```

All functions were numerically cross-checked against the corresponding Eurostat tables within rounding tolerance (\< 1e-3), confirming that the `iotables` analytical pipeline—\
**A → (I − A) → L → extensions → indicators → multipliers**—\
faithfully reproduces the canonical Eurostat and UN SNA 2010 results.

```{r savevignettedata, eval=FALSE}
save(methane, co2, ghg, BE,
  file = here::here(
    "inst", "extdata", "environmental_impact_vignette.rda"
  )
)
```
---
title: "Introduction to iotables"
author: "Daniel Antal, based on the work of Jorg Beutel"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to iotables}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setupknitr, include=FALSE, message=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup,  message=FALSE}
library(iotables)
library(dplyr, quietly = T)
library(tidyr, quietly = T)
```

This introduction shows the reproducible workflow of iotables with the examples of the [Eurostat Manual of Supply, Use and Input-Output Tables](https://ec.europa.eu/eurostat/documents/3859598/5902113/KS-RA-07-013-EN.PDF/b0b3d71e-3930-4442-94be-70b36cea9b39?version=1.0). by Joerg Beutel (*Eurostat Manual*).

This vignette uses `library(tidyverse)`, more particularly `dplyr` and `tidyr`, just like all analytical functions of `iotables`. Even if you do not use `tidyverse`, this packages will be installed together with `iotables`. These functions are only used in the vignette to print the output, and they are not essential for the examples.

## Germany sample files

The `germany_1995` dataset is a simplified 6x6 sized SIOT taken from the [Eurostat Manual of Supply, Use and Input-Output Tables](https://ec.europa.eu/eurostat/documents/3859598/5902113/KS-RA-07-013-EN.PDF/b0b3d71e-3930-4442-94be-70b36cea9b39?version=1.0) (page 481). It is brought to a long form similar to the Eurostat bulk files. The testthat infrastructure of the iotables package is checking data processing functions and analytical calculations against these published results.

The following data processing functions select and order the data from the Eurostat-type bulk file. Since the first version of this package, Eurostat moved all SIOT data products to the ESA2010 vocabulary, but the manual still follows the ESA95 vocabulary. The labels of the dataset were slightly changed to match the current metadata names. The changes are minor and self-evident, the comparison of the `germany_1995` dataset and the Manual should cause no misunderstandings.

```{r iotables}
germany_io <- iotable_get(labelling = "iotables")
input_flow <- input_flow_get(
  data_table = germany_io,
  households = FALSE
)

de_output <- primary_input_get(germany_io, "output")
print(de_output[c(1:4)])
```

The `input_flow()` function selects the first quadrant, often called the input flow matrix, or inter-industry matrix, from the German input-output table. The `primary_input_get()` selects one of the primary inputs, in this case, the output from the table.

## Direct effects

The input coefficient matrix shows what happens in the whole domestic economy when an industry is facing additional demand, and it increases production. In the Germany example, all results are rounded to 4 digits for easier comparison with the Eurostat manual.

The input coefficients for domestic intermediates are defined in the [Eurostat Manual of Supply, Use and Input-Output Tables](https://ec.europa.eu/eurostat/documents/3859598/5902113/KS-RA-07-013-EN.PDF/b0b3d71e-3930-4442-94be-70b36cea9b39?version=1.0) on page 486. You can check the following results against Table 15.8 of the Eurostat manual. (Only the top-right corner of the resulting input coefficient matrix is printed for readability.)

\deqn{sum_{i=1}^n X_i}

The `input_coefficient_matrix_create()` function relies on the following equation. The numbering of the equations is the numbering of the *Eurostat Manual*.

(9) \deqn{a_{ij} = X_{ij} / x_{j}}{a_ij = X_ij / x_j} [recap: (43) is the same, and the same equation is (2) on page 484 with comparative results]

It checks the correct ordering of columns, and furthermore it fills up 0 values with 0.000001 to avoid division with zero.

```{r inputcoeff, echo=TRUE}
de_input_coeff <- input_coefficient_matrix_create(
  data_table = germany_io,
  digits = 4
)

## which is equivalent to:
de_input_coeff <- coefficient_matrix_create(
  data_table = germany_io,
  total = "output",
  return_part = "products",
  households = FALSE,
  digits = 4
)

print(de_input_coeff[1:3, 1:3])
```

These results are identical after similar rounding to the Table 15.6 of the Manual (on page 485.)

Similarly, the output coefficient matrix is defined in the following way:

(5) \eqn{o_{ij}} = \eqn{x_{ij} / x_{i}}

\eqn{o_{ij}} = output coefficient for domestic goods and services (i = 1, ..., 6; j = 1, ..., 6) \\eqn{x\_{ij}= flow of commodity i to sector j \\eqn{x\_{i} = output of sector i

```{r outputcoeff, echo=FALSE}
de_out <- output_coefficient_matrix_create(
  data_table = germany_io,
  total = "tfu",
  digits = 4
)

# Rounding is slightly different in the Eurostat manual:
print(de_out[1:3, 1:3])
```

These results are identical after similar rounding to the Table 15.7 of the [Eurostat Manual of Supply, Use and Input-Output Tables](https://ec.europa.eu/eurostat/documents/3859598/5902113/KS-RA-07-013-EN.PDF/b0b3d71e-3930-4442-94be-70b36cea9b39?version=1.0) on page 485. The diagonal values are the same in the input coefficient matrix and the output coefficient matrix.

The Leontief matrix is derived from Leontief equation system.

(19) \eqn{(I-A)x = y}

The Leontief matrix is defined as \eqn{(I-A)} and it is created with the `leontief_matrix_create()` function.

The Leontief inverse is \eqn{(I-A)^{-1}} and it is created with the `leontief_inverse_create()` function from the Leontief-matrix.

```{r leontief}
L_de <- leontief_matrix_create(
  technology_coefficients_matrix = de_input_coeff
)
I_de <- leontief_inverse_create(de_input_coeff)
I_de_4 <- leontief_inverse_create(
  technology_coefficients_matrix = de_input_coeff,
  digits = 4
)
print(I_de_4[, 1:3])
```

*You can check the Leontief matrix against Table 15.9 on page 487 of the* Eurostat Manual, *and the Leontief inverse against Table 15.10 on page 488. The ordering of the industries is different in the manual.*

## Creating indicators

### Creating technical indicators

Technical indicators assume constant returns to scale and fixed relationship of all inputs to each industry. With these conditions the technical input coefficients show how much input products, labour or capital is required to produce a unit of industry output.

(60) $a_{ij}$ = $z_{ij}$ / $x_j$ [technical input coefficients]

The helper function `primary_input_get()` selects a row from the SIOT and brings it to a conforming form. The `input_indicator_create()` creates the vector of technical input coefficients.

```{r employment_indicator}
de_emp <- primary_input_get(germany_io,
  primary_input = "employment_domestic_total"
)

de_emp_indicator <- input_indicator_create(
  data_table = germany_io,
  input_row  = "employment_domestic_total"
)

vector_transpose_longer(de_emp_indicator)
```

Often we want to analyse the effect of growing domestic demand on some natural units, such as employment or $CO_2$ emissions. The only difficulty is that we need data that is aggregated or disaggregated precisely with the same industry breakup as our SIOT table.

European employment statistics have greater detail than our tables, so employment statistics must be aggregated to conform the 60 (61, 62) columns of the SIOT. There is a difference in the columns based on how national statistics offices treat imputed real estate income and household production, and trade margins. Czech SIOTs are smaller than most SIOTs because they do not have these columns and rows.

In another vignette we will show examples on how to work with these real-life data. For the sake of following the calculations, we are continuing with the simplified 1990 German data.

### Creating income indicators

The input coefficients for value added are created with `input_indicator_create()`.

```{r gva_indicator}
de_gva <- primary_input_get(germany_io,
  primary_input = "gva"
)

de_gva_indicator <- input_indicator_create(
  data_table  = germany_io,
  input_row   = "gva"
)

vector_transpose_longer(de_gva_indicator)
```

This is equal to the equation on page 495 of the [Eurostat Manual of Supply, Use and Input-Output Tables](https://ec.europa.eu/eurostat/documents/3859598/5902113/KS-RA-07-013-EN.PDF/b0b3d71e-3930-4442-94be-70b36cea9b39?version=1.0). The results above can be checked on the bottom of page 498.

(44) $w_{ij}$ = $W_{j}$ / $x_j$ [input coefficients for value added]

You can create a matrix of input indicators, or direct effects on (final) demand with `direct_supply_effects_create()`. The function by default creates input requirements for final demand. With the code below it re-creates the Table 15.14 of the *Eurostat Manual*.

```{r input_indicator}
direct_effects_de <- coefficient_matrix_create(
  data_table  = germany_io,
  total       = "output",
  return_part = "primary_inputs"
)

direct_effects_de[1:6, 1:4]
```

*The 'total' row above is labelled as Domestic goods and services in the* Eurostat Manual. *The table can be found on page 498.*

## Multipliers

### Income multipliers

The SIOTs contain (with various breakups) three types of income:

-   Employee wages, which is usually a proxy for all household income.

-   Gross operating surplus, which is a form of corporate sector income.

-   Taxes that are the income of government.

These together make gross value added (GVA). If you are working with SIOTs that use basic prices, then GVA = GDP at producers' prices, or basic prices.

The GVA multiplier shows the additional gross value created in the economy if demand for the industry products is growing with unity. The wage multiplier (not shown here) shows the increase in household income.

The following equation is used to work with different income effects and multipliers (in the *Eurostat Manual*, p500):

$$
(63) Z = B(I-A)^{-1}
$$

-   $B$ = vector of input coefficients for wages or GVA or taxes.

-   $(I-A)^{-1}$: is the Leontief inverse

-   $Z$ = direct and indirect requirements for wages (or other income)

The indicator shows that manufacturing has the lowest, and other services has the highest gross value added component. This is hardly surprising, because manufacturing needs a lot of materials and imported components. When the demand for manufacturing in the domestic economy is growing by 1 unit, the gross value added is `r as.numeric(de_gva_indicator[3])`.

*You can check these values against the Table 15.16 of the [Eurostat Manual of Supply, Use and Input-Output Tables](https://ec.europa.eu/eurostat/documents/3859598/5902113/KS-RA-07-013-EN.PDF/b0b3d71e-3930-4442-94be-70b36cea9b39?version=1.0) on page 501 (row 10).*

You can recreate the whole matrix, when the data permits, with `input_multipliers_create()` as shown here. Alternatively, you can create your own custom multipliers with `multiplier_create()` as shown in the following example.

```{r inputmultipliers}
input_reqr <- coefficient_matrix_create(
  data_table  = iotable_get(),
  total       = "output",
  return_part = "primary_inputs"
)

multipliers <- input_multipliers_create(
  input_requirements = input_reqr,
  Im = I_de
)

multipliers
```

*You can check these results against the Table 15.16 on page 501 of the* Eurostat Manual. *The label 'total' refers to domestic intermediaries. The ordering of the rows is different from the* Manual.

These multipliers are Type-I multipliers. The type-I GVA multiplier shows the total effect in the domestic economy. The initial extra demand creates new orders in the backward linking industries, offers new product to build on in the forward-linking industry and creates new corporate and employee income that can be spent. Type-II multipliers will be introduced in a forthcoming vignette [not yet available.]

### Employment multipliers

The E matrix contains the input coefficients for labour (created by `input_indicator_create()`). The following matrix equation defines the employment multipliers.

(64) Z = E(I-A)^-1^

The `multiplier_create()` function performs the matrix multiplication, after handling many exceptions and problems with real-life data, such as different missing columns and rows in the national variations of the standard European table.

Please send a bug report on [Github](https://github.com/rOpenGov/iotables/issues) if you run into further real-life problems.

```{r employment_multiplier}
de_emp_indicator <- input_indicator_create(
  data_table = germany_io,
  input = "employment_domestic_total"
)

employment_multipliers <- multiplier_create(
  input_vector = de_emp_indicator,
  Im = I_de,
  multiplier_name = "employment_multiplier",
  digits = 4
)

vector_transpose_longer(employment_multipliers,
  values_to = "employment_multipliers"
)
```

You can check against the [Eurostat Manual of Supply, Use and Input-Output Tables](https://ec.europa.eu/eurostat/documents/3859598/5902113/KS-RA-07-013-EN.PDF/b0b3d71e-3930-4442-94be-70b36cea9b39?version=1.0) page 501 that these values are correct and on page 501 that the highest employment multiplier is indeed $z_i$ = `r max (as.numeric(employment_multipliers), na.rm=TRUE)`, the employment multiplier of agriculture.

For working with real-life, current employment data, there is a helper function to retrieve and process Eurostat employment statistics to a SIOT-conforming vector `employment_get()`. This function will be explained in a separate vignette.

### Output multipliers

`Output multipliers` and `forward linkages` are calculated with the help of output coefficients for product as defined on p486 and p495 of the the Eurostat Manual. The Eurostat Manual uses the definition of *output at basic prices* to define output coefficients which is no longer part of SNA as of SNA2010.

(5) $b_{ij}$ = $X_{ij}$ / $x_i$ [also (45) output coefficients for products / intermediates].

$x_i$: output of sector i

```{r outputmult}
de_input_coeff <- input_coefficient_matrix_create(
  data_table = iotable_get(),
  digits = 4
)

output_multipliers <- output_multiplier_create(input_coefficient_matrix = de_input_coeff)

vector_transpose_longer(output_multipliers,
  values_to = "output_multipliers"
)
```

*These multipliers can be checked against the Table 15.15 (The 8th, 'Total' row) on the page 500 of the* Eurostat Manual.

## Interindustrial linkage analysis

The `backward linkages`, i.e. demand side linkages, show how much incremental demand is created in the supplier sector when an industry is facing increased demand, produces more, and requires more inputs from suppliers.

`Forward linkages` on the other hand show the effect of increased production, which gives either more or cheaper supplies for other industries that rely on the output of the given industry.

For example, when a new concert is put on stage, orders are filled for real estate, security services, catering, etc, which show in the backward linkages. The concert attracts visitors that creates new opportunities for the hotel industry in forward linkages.

### Backward linkages

```{r backward}
de_coeff <- input_coefficient_matrix_create(iotable_get(), digits = 4)
I_de <- leontief_inverse_create(de_coeff)

vector_transpose_longer(backward_linkages(I_de),
  values_to = "backward_linkage_strength"
)
```

*You can check the results against Table 15.19 on page 506 of the* Eurostat Manual.

Manufacturing has the highest backward linkages, and other services the least. An increased demand for manufacturing usually affects supplier industries. Service industry usually have a high labour input, and their main effect is increased spending of the wages earned in the services.

### Forward linkages

Forward linkages show the strength of the new business opportunities when industry i starts to increase its production. Whereas backward linkages show the increased demand of the suppliers in industry i, forward linkages show the increased availability of inputs for other industries that rely on industry i as a supplier.

The forward linkages are defined as the sums of the rows in the Ghosh-inverse. The Ghosh-inverse is not explicitly named in the *Eurostat Manual*, but it is described in more detail in the United Nations' similar manual [Handbook on Supply and Use Tables and Input-Output Tables with Extensions and Applications](https://unstats.un.org/unsd/nationalaccount/docs/SUT_IOT_HB_Final_Cover.pdf) (see pp 636--638).

```{r ghoshinverse}
de_out <- output_coefficient_matrix_create(
  data_table = germany_io,
  total = "final_demand",
  digits = 4
)

ghosh_inverse_create(de_out, digits = 4)[, 1:4]
```

The Ghosh-inverse is \deqn{G = (I-B)^-1}

where B = the output coefficient matrix.

The forward linkages are the row-wise sums of the Ghosh-inverse

```{r forwardlinkages}
forward_linkages(output_coefficient_matrix = de_out)
```

*You can check the values of the forward linkages against the Table 15.20 on page 507 of* the Eurostat Manual.

## Environmental Impacts

At last, let's extend the input-output system with emissions data. For getting Eurostat's air pollution account data, use `airpol_get()`. We have included in the package the German emissions data from the *Eurostat Manual*.

```{r emissions}
data("germany_airpol")
emissions_de <- germany_airpol[, -3] %>%
  vector_transpose_wider(
    names_from = "iotables_col",
    values_from = "value"
  )
```

```{r emissionsprint}
emissions_de
```

```{r outputbp}
output_bp <- output_get(germany_io)
```

The output coefficients are created from the emission matrix with \eqn{B_{ij}} = \eqn{Em_{ij} / output_{j}}

```{r emmissioncoeffs}
emission_coeffs <- germany_io %>%
  supplementary_add(emissions_de) %>%
  input_indicator_create(input_row = as.character(emissions_de$airpol), digits = 4)
```

The emissions coefficients are expressed as 1000 tons per millions of euro output (at basic prices).

```{r emmissioncoeffsprint}
emission_coeffs[-1, 1:3]
```

And the multipliers (which include both the direct and indirect emissions of the industries) are created with

\eqn{B(I-A)^{-1}}

You can create a single multiplier with `?multiplier_create`.

```{r CO2multiplier}
multiplier_create(
  input_vector = emission_coeffs[2, ],
  Im = I_de,
  multiplier_name = "CO2_multiplier",
  digits = 4
)
```

To create a tidy table of indicators of using a loop:

```{r emissionmultipliers}
names(emission_coeffs)[1] <- names(I_de)[1]
emission_multipliers <- cbind(
  key_column_create(
    names(emission_coeffs)[1],
    gsub("_indicator", "_multiplier", unlist(emission_coeffs[-1, 1]))
  ),
  do.call(
    rbind,
    lapply(
      2:nrow(emission_coeffs),
      function(x) equation_solve(emission_coeffs[x, ], I_de)
    )
  ) %>% as.data.frame()
)

emission_multipliers[, -1] <- round(emission_multipliers[, -1], 4)

emission_multipliers[1:3, 1:4]
```

*You can check the results against the Table 15.13 of the* [Eurostat Manual of Supply, Use and Input-Output Tables](https://ec.europa.eu/eurostat/documents/3859598/5902113/KS-RA-07-013-EN.PDF/b0b3d71e-3930-4442-94be-70b36cea9b39?version=1.0) *on page 494.*

Because the equation of the final demand is:

`r paste0("final_demand = ", paste(names(germany_io)[9:13], collapse = " + "))`

we can calculate the final demand for the products of industries with creating the row-wise sums of the appropriate columns

```{r finaldemand}
final_demand <- rowSums(germany_io[1:6, 9:13])
```

And at last the emission content of the final demand is given by

\eqn{Z = B(I-A)^{-1}Y}

where the term

\eqn{B(I-A)^{-1}}

is the definition of the emission multipliers.

```{r emissioncontent}
emission_content <- as.data.frame(
  round(as.matrix(emission_multipliers[1:3, -1]) %*% diag(final_demand), 0)
)
names(emission_content) <- names(emission_multipliers[, -1])

emission_content <- data.frame(
  iotables_row = gsub("_multiplier", "_content", emission_multipliers[1:3, 1])
) %>%
  cbind(emission_content)

emission_content[, 1:4]
```

*This final result can be found on the bottom of the page 494 of the* [Eurostat Manual of Supply, Use and Input-Output Tables](https://ec.europa.eu/eurostat/documents/3859598/5902113/KS-RA-07-013-EN.PDF/b0b3d71e-3930-4442-94be-70b36cea9b39?version=1.0).
---
title: "Metadata Vocabularies for Input–Output Analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Metadata Vocabularies for Input–Output Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(iotables)
```

## Import and Normalisation Workflow

The five Eurostat vocabularies —\
`ind_ava`, `ind_use`, `prd_ava`, `prd_use`, and `cpa2_1` — were imported directly from the official Eurostat metadata registry (<https://dd.eionet.europa.eu/vocabulary/eurostat/>).\
Each dataset mirrors the structure of its corresponding SDMX codelist and preserves Eurostat’s identifiers and validity information.

### Data Sources

| Vocabulary | Description | Source URL |
|------------------------|------------------------|------------------------|
| `ind_ava` | Industries, adjustments and value added (rows for industry × industry SIOTs) | <https://dd.eionet.europa.eu/vocabulary/eurostat/ind_ava/> |
| `ind_use` | Industry uses (columns for industry × industry SIOTs) | <https://dd.eionet.europa.eu/vocabulary/eurostat/ind_use/> |
| `prd_ava` | Products, adjustments and value added (rows for product × product SIOTs) | <https://dd.eionet.europa.eu/vocabulary/eurostat/prd_ava/> |
| `prd_use` | Product uses (columns for product × product SIOTs) | <https://dd.eionet.europa.eu/vocabulary/eurostat/prd_use/> |
| `cpa2_1` | Statistical Classification of Products by Activity (CPA 2.1) | <https://dd.eionet.europa.eu/vocabulary/eurostat/cpa2_1/> |

### Import Steps

1.  **Raw Download**\
    Each vocabulary was retrieved as an Excel export from EIONET’s vocabulary registry.

2.  **Column Standardisation**\
    Columns were renamed to a unified schema: `id, label, status, status_modified, notation, group, quadrant, numeric_order, iotables_label, block, uri`

3.  **Quadrant and Block Assignment**\
    Each item was assigned a `quadrant` and a semantic `block` consistent across vocabularies:

    -   `10` = intermediate (Quadrant 1)

    -   `20` = primary_inputs (Quadrant 3)

    -   `30` = final_use (Quadrant 2)

    -   `50` = extension / diagnostic\
        Control totals such as *“Total supply at basic prices”* were retained as `block = "control_total"`.

4.  **Ordinal Ordering**\
    `numeric_order` was reindexed within each quadrant with consistent gaps (10, 20, …) to ensure reproducible ordering for matrix construction.

5.  **URI Generation**\
    Each code was linked to its SKOS concept using:

```{r uri, eval=FALSE}
df$uri <- sprintf(
  "https://dd.eionet.europa.eu/vocabularyconcept/eurostat/%s/%s",
  vocabulary_id,
  df$notation
)
```

6.  **Validation**\
    Each table was checked for:

    -   missing or duplicate IDs

    -   monotone numeric order

    -   alignment of quadrant ↔ block semantics

7.  **Storage and Naming**

The cleaned tibbles were stored as exported data objects:

```
data/ind_ava.rda data/ind_use.rda data/prd_ava.rda data/prd_use.rda
```

Each dataset can be loaded directly with `data(<name>)`.

### Adjustments to Vocabularies

Although the four Eurostat vocabularies (`ind_ava`, `ind_use`, `prd_ava`, `prd_use`) were imported directly from the official Eurostat metadata registry, some modifications were necessary to ensure compatibility with the actual Eurostat input–output datasets. The main data sources, in particular `naio_10_cp1750` and `naio_10_cp1700`, occasionally include variables that are not coded according to the published and standardised vocabularies. While these inconsistencies are usually clear to a manual user, they can create ambiguity in a reproducible workflow where automated matching is required.

For example, the *product × product* SIOTs for the Slovak Republic contain a more detailed industry breakdown than that defined in prd_ava and prd_use. To maintain alignment across datasets, all 0-, 1-, and 2-digit codes from the `cpa2_1` vocabulary were imputed into the four vocabularies. Each entry includes a validity flag in the status column, indicating whether the code is valid in the official Eurostat vocabulary or was adopted from observed but non-standard codes in the data. This approach preserves reproducibility while ensuring complete coverage of all codes encountered in current Eurostat data releases.

### Versioning

All four vocabularies correspond to the 2025 Eurostat CPA 2.1 / ESA 2010 edition.
---
title: "Terminology"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Terminology}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setupvignette, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(scipen = 999)
```

## Introduction

This vignette reviews the terminology used in input–output analysis, with reference to the *Eurostat Manual of Supply, Use and Input–Output Tables* (Beutel, 2008).

This vignette is therefore descriptive, documenting how the `iotables` package uses *Eurostat-style terminology* consistent with ESA 2010 and the System of National Accounts (SNA 2008).

```{r setup}
library(iotables)
```

Retrieve the demo dataset, the Germany 1995 Symmetric Input-Output Table:

```{r germany}
germany_siot <- iotable_get()
```

## Structure of input–output tables

An *input–output table (IOT)* describes the flow of products and services in an economy, linking industries (producers) with their inputs, outputs, and final uses. In a *symmetric input–output table (SIOT***)**, both rows and columns represent either products or industries.

Eurostat distinguishes four *quadrants* of a SIOT:

| Quadrant | Description | ESA 2010 / SNA 2008 Category |
|------------------------|------------------------|------------------------|
| **I** | Intermediate consumption — flows between industries or products | *Intermediate use* |
| **II** | Final demand — purchases by households, government, investment, exports | *Final use* |
| **III** | Primary inputs — compensation of employees, net taxes, gross operating surplus | *Primary inputs* |
| **IV** | Output totals — column sums at basic prices | *Output (P.1)* |

Quadrants I–III correspond to the *rows* of the table, while the column totals in Quadrant IV represent the total output of each industry or product.

## Core matrices and notation

Input–output analysis is built on a small set of matrices and vectors.\
The `iotables` package follows the same notation used in Beutel (2008).

| Symbol | Meaning | Definition | Function in `iotables` |
|------------------|------------------|------------------|------------------|
| **Z** | Intermediate-consumption matrix | Flows of products between industries | `iotable_get()` |
| **A** | Input (technical) coefficient matrix | $A_{ij} = Z_{ij} / X_{j}$` | `input_coefficient_matrix_create()` |
| **(I − A)** | Leontief matrix | Identity minus A | `leontief_matrix_create()` |
| **L = (I − A)⁻¹** | Leontief inverse | Total (direct + indirect) requirements | `leontief_inverse_create()` |
| **f** | Final-demand vector | Exogenous demand by category | retrieved from IOT |
| **x = Lf** | Total output vector | Fundamental Leontief equation | – |

**Eurostat equation references:**

-   $a_ij$ = $x_ij$ / $x_j$ — technical coefficient (19), (43) identical formulations for SIOTs

-   $x$ = $(I − A)⁻¹$ — total output

## Input and output coefficients

### Input coefficients (technical coefficients)

Each element of the **input coefficient matrix** A shows the share of input *i* used in producing one unit of output of industry *j*:

$$
a_{ij} = \frac{x_{ij}}{x_j}
$$

where\
- $a_{ij}$ = input coefficient for domestic goods and services\
- $x_{ij}$ = flow of product *i* to industry *j* (a cell in Quadrant I)\
- $x_j$ = total output of industry *j*

These coefficients are sometimes called **direct requirements** or **technical coefficients**.

hey are computed in `iotables` by:

```{r inputcoeff}
input_coefficient_matrix_create(
  data_table = iotable_get(source="germany_1995"),
  digits = 4)
```

### Output coefficients

The output coefficient matrix (Ghosh-type) expresses how the output of industry i is distributed across purchasing sectors j:

$$o_{ij} = \frac{x_{ij}}{x_i}$$

where

-   $o_{ij}$ = output coefficient (distribution ratio)

-   $x_{ij}$ = flow of product *i* to industry *j*

-   $x_{i}$ = total output of product *i*

These ratios describe the supply-side distribution structure and are computed by `output_coefficient_matrix_create()`.

## Linkages between industries (inter-industry analysis)

Two types of linkages are typically analysed:

-   **Backward linkage** – measures the strength of a sector’s demand on its suppliers.\
    It is given by the **column sum** of input coefficients or, when based on the Leontief inverse, includes all indirect effects through the supply chain.

-   **Forward linkage** – measures the influence of a sector as a supplier to others. It is given by the **row sum** of output coefficients, describing how the sector’s output feeds into other industries.

## Indicators and multipliers

### Direct indicators

An **input indicator** represents a specific row of the coefficient matrix A,\
for example value added (GVA), labour, or emissions per unit of output.

```{r inputindicatr}
input_indicator_create(
  data_table = iotable_get(), input_row = "gva")
```

### Multipliers

The income, product, employment, or emission multipliers are calculated with the following generic formula:


$$
(63) Z = B(I-A)^{1}
$$
- $B$ = matrix of input coefficients for primary input (income, employment, product, or pollutant)
- $I$ = unit matrix
- $A$ = matrix of input coefficients for intermediates
- $Y$ = Diagonal matrix for final demand by product
- $Z$ = matrix with results for direct and indirect requirements for primary inputs[^multipliers].

[^multipliers]: In the *Eurostat Manual*, the calculations are shown with (63) wages, (64) employment, (65) capital.

**Embodied emissions in final demand**:\

$$
(66) Z = B(I-A)^{1}Y
$$

- $B$ = matrix of input coefficients for primary input
- $I$ = unit matrix
- $A$ = matrix of input coefficients for intermediates
- $Y$ = Diagonal matrix for final demand by product
- $Z$ = matrix with results for direct and indirect requirements for primary inputs

See  *Eurostat Manual of Supply, Use and Input–Output Tables* (Beutel, 2008, pp.503-506.)

### Output coefficients

The output coefficients are ratios derived from quadrant I (intermediates) and quadrant II (final demand) of a sector.

The `output_coefficient_matrix_create()` function creates these coefficients based on equation (5) in the Eurostat Manual.

(5) $o_{ij}$ = $x_{ij}$ / $x_i$

$o_{ij}$ = output coefficient for domestic goods and services (i = 1, ..., 6; j = 1, ..., 6) $x_{ij}$ = flow of commodity i to sector j $x_j$ = output of sector i

## Summary of key equations

| No.        | Formula                     | Description                      |
|:---------------|:-------------------------|:-----------------------------|
| (5)        | $o_{ij}$ = $x_{ij}$ / $x_i$ | Output coefficient (Ghosh model) |
| (9)        | $a_{ij}$ = $x_{ij}$ / $x_j$ | Input (technical) coefficient    |
| (19), (43) | –                           | Identical to (9) for SIOTs       |
| (47)       | $x$ = $(I - A)^{-1}$        | Leontief model for total output  |
| (L)        | $L$ = $(I - A)^{-1}$        | Leontief inverse                 |
| (m)        | $m$ = $a \times L$          | Multiplier equation              |

## Validation summary (Eurostat Manual, Beutel 2008)

All analytical functions of `iotables` reproduce the benchmark examples from Beutel (2008), *Eurostat Manual of Supply, Use and Input–Output Tables.*

| Function | Concept | Beutel Table | Page |
|:-----------------|:-----------------|:-----------------|:----------------:|
| `input_coefficient_matrix_create()` | Direct requirements (A) | 15.6 | 485 |
| `leontief_matrix_create()` | Leontief matrix $(I − A)$ | 15.9 | 487 |
| `leontief_inverse_create()` | Total requirements ($L$ = $(I − A)^{1}$) | 15.10 | 488 |
| `supplementary_add()` | Environmental extension (CO₂, CH₄) | 15.13 | 494 |
| `input_indicator_create()` | Input indicators (GVA, Compensation) | 15.14 | 498 |
| `multiplier_create()` | Total multipliers (GVA, Employment) | 15.16 | 503–504 |

## References

-   **Beutel, J.** (2008). *Eurostat Manual of Supply, Use and Input–Output Tables.*\
    Luxembourg: Office for Official Publications of the European Communities.
-   **United Nations** (2018). *Handbook on Supply and Use Tables and Input–Output Tables with Extensions and Applications*, Rev. 1.\
    New York: United Nations.
-   **OECD** (2021). *Inter-Country Input–Output (ICIO) Manual.* Paris: OECD Publishing.
-   **United Nations** (2012). *System of Environmental-Economic Accounting 2012: Central Framework.*\
    New York: United Nations.
---
title: "United Kingdom Input-Output Analytical Tables"
author: "Daniel Antal, based on the work edited by Richard Wild"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{United Kingdom Input-Output Analytical Tables}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(dplyr, quietly = TRUE)
library(tidyr, quietly = TRUE)
library(testthat, quietly = TRUE)
```

The [United Kingdom Input-Output Analytical Tables 2010](https://webarchive.nationalarchives.gov.uk/20160114044923/http://www.ons.gov.uk/ons/rel/input-output/input-output-analytical-tables/2010/index.html) are used for testing the `iotables` package, because they are well-documented and detailed, and organised data is available. The analytical tables are published in an Excel table. A special reader function (which is not exported) was created to read-in all sheets of the Excel table.

It is unlikely these tables will be required for purposes other than validating the package. The UK IO tables for other years are available these are consistent with different Blue Books and there could therefore be important methodological and classification changes. Furthermore, ONS currently publishes ESA2010 compatible SIOTs with analytical tables annually.

```{r read_control_data, eval=FALSE}
uk_2010_data <- iotables_download(source = "uk_2010")
save(uk_2010_data, file = file.path("data-raw", "uk_2010_data.rda"))
uk_test_results <- iotables:::uk_2010_results_get()
# saved as package data
```

For the actual symmetric input-output table (see ) you can use the download function originally designed for the Eurostat bulk downloader.

```{r downloaded_excel_data}
library(iotables)
data(uk_2010_data)
uk_siot <- iotable_get(
  labelled_io_data = uk_2010_data,
  source = "uk_2010_siot"
)
uk_published_coeff <- iotable_get(
  labelled_io_data = uk_2010_data,
  source = "uk_2010_coeff"
)
uk_published_inverse <- iotable_get(
  labelled_io_data = uk_2010_data,
  source = "uk_2010_inverse"
)
```

## Matrix of Coefficients

The matrix of coefficients is described on page 14-15 and the data can be found in the _Matrix of coefficients (product by product) sheet_ of the Excel file.

```{r compare_coeff}
uk_input_coeff <- input_coefficient_matrix_create(data_table = uk_siot)

coeff_comparison <- select(uk_input_coeff, 1) %>%
  left_join(uk_published_coeff, by = "prod_na")

test_that("correct data is returned", {
  expect_equal(
    round(uk_input_coeff[, 2:8], 8),
    round(coeff_comparison[, 2:8], 8)
  )
})
```

Comparing the first seven columns of the two coefficient matrices are equal to eight decimal places. Given the size of the matrixes, not all columns are compared here, but such a comparison could be performed if needed. However, it is not necessary, because the latter results would show a deviation if parts of the matrix would be different.

## Leontief-inverse

The Leontief-inverse is described on pages 16-17 of the article. Again, comparing the first seven numerical columns we see that the recalculated inverse and the published inverse are identical to eight decimal places.

```{r compare_inverse}
uk_calculated_inverse <- leontief_inverse_create(uk_input_coeff)

inverse_comparison <- select(uk_calculated_inverse, 1) %>%
  left_join(uk_calculated_inverse, by = "prod_na")
```
```{r compare_inverse_2, eval=FALSE}
# Not evaluated in the vignette:
test_that("correct data is returned", {
  expect_equal(
    round(uk_calculated_inverse[, 2:8], 8),
    round(inverse_comparison[, 2:8], 8)
  )
})
```

## Employment cost effects

```{r compare_effects}
employment_effect_results <- uk_test_results %>%
  select(uk_row_label, `Employment cost effects`)

primary_inputs_uk <- coefficient_matrix_create(
  data_table  = uk_siot,
  total       = "output",
  return_part = "primary_inputs"
)

employment_input <- filter(primary_inputs_uk, prod_na == "D1")

employment_effects <- direct_effects_create(employment_input, uk_calculated_inverse) %>%
  gather(prod, values, !!2:ncol(.)) %>%
  mutate(prod_na = prod) %>%
  select(-prod) %>%
  left_join(select(metadata_uk_2010, prod_na, uk_row_label),
    by = "prod_na"
  ) %>%
  left_join(employment_effect_results, by = "uk_row_label") %>%
  filter(!is.na(uk_row_label)) %>%
  select(prod_na, uk_row_label, values, `Employment cost effects`)


iotables:::create_knitr_table(
  data_table = employment_effects[1:10, ],
  digits = 4,
  caption = "Comparison of Calculated And Published Employment Cost Effects",
  col.names = c("industry code", "row label", "calculated", "published"),
  col_width = c(2, 11, 3, 3)
)
```


The comparison of output multipliers show that our code gives the same results. Only ten industries are shown.

## GVA effects

GVA is not shown in the Excel table explicitly, but can be calculated as the sum of corporate income (*Operating surplus and mixed income*), household income (*Compensation of employees*) and net taxes on production (not products.)

```{r gva_effects}
uk_siot2 <- uk_siot %>%
  filter(prod_na %in% c("B2A3G", "D1", "D29X39")) %>%
  summarize_if(is.numeric, sum, na.rm = TRUE) %>%
  cbind(data.frame(prod_na = "GVA"), .) %>%
  rbind(uk_siot, .)

gva_effect_results <- uk_test_results %>%
  select(uk_row_label, `GVA effects`)

gva_input <- coefficient_matrix_create(
  data_table  = uk_siot2,
  total       = "output",
  return_part = "primary_inputs"
) %>%
  filter(prod_na == "GVA")

gva_effects <- direct_effects_create(
  gva_input,
  uk_calculated_inverse
) %>%
  gather(prod, values, !!2:ncol(.)) %>%
  mutate(prod_na = prod) %>%
  select(-prod) %>%
  left_join(select(metadata_uk_2010, prod_na, uk_row_label),
    by = "prod_na"
  ) %>%
  left_join(gva_effect_results, by = "uk_row_label") %>%
  filter(!is.na(uk_row_label)) %>%
  select(prod_na, uk_row_label, values, `GVA effects`)

iotables:::create_knitr_table(
  data_table = gva_effects[1:10, ],
  digits = 4,
  caption = "Comparison of Calculated And Published GVA Effects",
  col.names = c("industry code", "row label", "calculated", "published"),
  col_width = c(2, 11, 3, 3)
)
```

## Employment cost multipliers

Turning to multipliers, using the same inputs we get them back with the following code.

```{r compare_emp_multipliers}
empc_multiplier_results <- uk_test_results %>%
  select(uk_row_label, `Employment cost multiplier`)

empc_indicator_uk <- coefficient_matrix_create(
  data_table  = uk_siot,
  total       = "output",
  return_part = "primary_inputs"
) %>%
  filter(prod_na == "D1")

empc_multipliers <- input_multipliers_create(
  input_requirements = empc_indicator_uk,
  uk_calculated_inverse
) %>%
  gather(prod, values, !!2:ncol(.)) %>%
  mutate(prod_na = prod) %>%
  select(-prod) %>%
  left_join(select(metadata_uk_2010, prod_na, uk_row_label),
    by = "prod_na"
  ) %>%
  left_join(empc_multiplier_results, by = "uk_row_label") %>%
  filter(!is.na(uk_row_label)) %>%
  select(prod_na, uk_row_label, values, `Employment cost multiplier`)

iotables:::create_knitr_table(
  data_table = empc_multipliers[1:10, ], digits = 4,
  caption = "Comparison of Calculated And Published Employment Cost Multipliers",
  col.names = c("industry code", "row label", "calculated", "published"),
  col_width = c(2, 11, 3, 3)
)
```

## GVA multipliers

Following from the GVA effects, after summarizing GVA and adding it to the input requirements we can calculate the `GVA multipliers`.

```{r gva_comp, eval=FALSE}
gva_multipliers <- input_multipliers_create(
  input_requirements = gva_input,
  uk_calculated_inverse
) %>%
  gather(prod, values, !!2:ncol(.)) %>%
  mutate(prod_na = prod) %>%
  select(-prod) %>%
  left_join(select(metadata_uk_2010, prod_na, uk_row_label),
    by = "prod_na"
  ) %>%
  left_join(gva_multiplier_results, by = "uk_row_label") %>%
  filter(!is.na(uk_row_label)) %>%
  select(prod_na, uk_row_label, values, `GVA multiplier`)

iotables:::create_knitr_table(
  data_table = gva_multipliers[1:10, ],
  digits = 4,
  caption = "Comparison of Calculated And Published GVA Multipliers",
  col.names = c(
    "industry code", "row label",
    "calculated", "published"
  ),
  col_width = c(2, 11, 3, 3)
)
```


## Output multipliers

At last, the comparison of output multipliers show that our code gives the same results. Only ten industries are shown.

```{r compare_output_multipliers}
output_multiplier_results <- uk_test_results %>%
  select(uk_row_label, `Output multiplier`)

uk_output_multipliers <- output_multiplier_create(uk_input_coeff) %>%
  gather(prod, values, !!2:ncol(.)) %>%
  mutate(prod_na = prod) %>%
  select(-prod) %>%
  left_join(select(metadata_uk_2010, prod_na, uk_row_label),
    by = "prod_na"
  ) %>%
  left_join(output_multiplier_results,
    by = "uk_row_label"
  ) %>%
  filter(!is.na(uk_row_label)) %>%
  select(prod_na, uk_row_label, values, `Output multiplier`)

iotables:::create_knitr_table(
  data_table = uk_output_multipliers[1:10, ],
  digits = 4,
  caption = "Comparison of Calculated And Published Output Multipliers",
  col.names = c(
    "industry code", "row label",
    "calculated", "published"
  ),
  col_width = c(2, 11, 3, 3)
)
```

---
title: "Working With Eurostat Data"
author: "Daniel Antal, CFA"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working With Eurostat Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(iotables)
require(dplyr)
```

Symmetric input–output tables and their auxiliary tables are among the most complex and structured statistical products. They describe relationships across roughly 63×63 industries, covering the supply and use of GDP/GNP, as well as income distribution, trade and transport margins, and tax receipts for each industry.

Eurostat publishes symmetric input–output data in long form. Working with these data requires knowledge of the [Eurostat SNA vocabulary](https://dd.eionet.europa.eu/vocabulary/eurostat/na_item/view) to arrange them in the correct order of rows and columns. The preprocessing functions of the `iotables` package perform this task.

Beyond managing an extensive and sometimes poorly documented vocabulary, users often face “real-world” data issues such as missing rows or columns in some Member States or spelling inconsistencies in the vocabulary. Many hours of testing and exception handling have gone into the current processing functions, but further issues may still appear. Most testing has been carried out on `product x product` type SIOTs, as these are the most common among Member States. The functions also support `industry x industry` SIOTs, though additional vocabulary exceptions may occur in these cases. Please report such issues on [GitHub](https://github.com/rOpenGov/iotables/issues).

You are most likely to work with the product × product tables. For information about the availability of other data, see `?iotables_download`.

The analytical functions are described in more detail in the Germany 1990 vignette. The numbering of the equations follows the [Eurostat Manual of Supply, Use and Input–Output Tables](https://ec.europa.eu/eurostat/documents/3859598/5902113/KS-RA-07-013-EN.PDF/b0b3d71e-3930-4442-94be-70b36cea9b39?version=1.0) (Chapter 15). The manual was prepared in 2008 under the ESA95 standards. Eurostat now uses ESA2010 definitions, and some indicators in the manual are no longer available, though this generally does not cause problems.

Another useful reference on working with input–output tables is [Input–Output Analytical Tables: Methods and Application to UK National Accounts](https://webarchive.nationalarchives.gov.uk/20160114044923/http://www.ons.gov.uk/ons/rel/input-output/input-output-analytical-tables/2010/index.html). At the time of publication, the United Kingdom was a member of the European Union, and its national accounts followed EU ESA standards.

## Getting and processing Eurostat data

The following code, if specifically run (it will not run on default), will download the latest relevant data from the Eurostat data warehouse, and save it to a directory named *../not_included* . The iotables package uses the other rOpenGov package [Eurostat](https://github.com/rOpenGov/eurostat) with additional processing of the rather complex SIOT bulk files.

The contents of the [not_included](https://github.com/rOpenGov/iotables/tree/master/not_included) directory can be found on GitHub, but they are not released and distributed with the package.

```{r download, eval=FALSE}
# Not run
not_included_directory <- file.path("..", "not_included")
if (!dir.exists(not_included_directory)) dir.create(not_included_directory)
# The contents of the 'not_included' directory can be found on GitHub,
# but they are not released and distributed with the package.

naio_10_cp1700 <- iotables_download(
  "naio_10_cp1700", # SIOT
  data_directory = not_included_directory
)

# For inclusion in the package, the files must be smaller.
# Reducing the size of the bulk files will not affect
# the demonstration.

naio_10_cp1700 <- naio_10_cp1700 %>%
  dplyr::filter(geo %in% c("CZ", "SK")) %>%
  dplyr::filter(year %in% c(2010, 2015))

# Conforming employment data both sexes from 15 years old, year 2015.
# prod_na vocabulary for product x product conformity
emp_cz <- employment_get(
  geo = "CZ", year = "2015", sex = "Total",
  age = "Y_GE15", labelling = "prod_na",
  data_directory = not_included_directory,
  force_download = TRUE
)

# Conforming employment data #both sexes from 15 years old, year 2017.
emp_sk <- employment_get(
  geo = "SK",
  year = "2017", sex = "Total",
  age = "Y_GE15", labelling = "prod_na",
  data_directory = not_included_directory,
  force_download = TRUE
)

save(naio_10_cp1700, emp_sk, emp_cz,
  file = file.path(
    "..", "inst", "extdata",
    "naio_10_product_x_product.rda"
  )
)
```

For a quicker building of the vignette, the data is retrieved from the *not_included* directory. The chunk above can reproduce this data file.

```{r load}
# load from pre-saved file to increase running speed
load(system.file("extdata",
  "naio_10_product_x_product.rda",
  package = "iotables"
))
```

In this vignette example the Czech (2015) national currency unit and the Slovak (2010) euro tables are created.  Since the Slovak national currency is the euro, there is no difference between the Slovak national currency unit and euro tables.

```{r preprocess, eval=FALSE}
cz_io <- iotable_get(
  source = "naio_10_cp1700",
  geo = "CZ",
  year = 2015,
  unit = "MIO_NAC",
  stk_flow = "TOTAL",
  labelling = "short"
)

sk_io <- iotable_get(
  source = "naio_10_cp1700",
  geo = "SK",
  year = 2015,
  unit = "MIO_EUR",
  stk_flow = "TOTAL",
  labelling = "short"
)

cz_input_flow <- input_flow_get(data_table = cz_io)

sk_input_flow <- input_flow_get(data_table = sk_io)

cz_output <- output_get(data_table = cz_io)
sk_output <- output_get(data_table = sk_io)
```

By default, total rows and columns are removed when creating use tables.
## Analytic functions {#analytic-functions}

### Input coefficients matrix

Iotables removes the columns and rows that are completely empty and creates the input coefficient matrix, which is used for most of the analytical functions.

The `input_coefficient_matrix_create()` function relies on the following equation. The numbering of the equations is the numbering of the Eurostat Manual.

(9)  $a_{ij}$ = $X_{ij}$ / $x_j$  [recap: (43) is the same]

It checks the correct ordering of columns, and furthermore it fills up 0 values with 0.000001 to avoid division with zero.

```{r inputcoeff, results='asis'}
input_coeff_matrix_cz <- input_coefficient_matrix_create(
  data_table = cz_io
)

input_coeff_matrix_sk <- input_coefficient_matrix_create(
  data_table = sk_io
)

knitr::kable(head(input_coeff_matrix_cz[, 1:8]))
```

In the Czech SIOTs, they are removed by the statistical authority, so the Czech SIOTs appear smaller.

Most countries do not use the *L_68A*, *CPA_U* [Services provided by extraterritorial organisations and bodies] and *CPA_T* [Services of households as employers; undifferentiated goods and services produced by households for own use]industries, instead they use *L_68B* for the income component of real estates, and they do not calculate the   In order to prevent division by zero errors, they are symmetrically removed from rows and columns.  This will not change the results.

### Creating the Leontief-matrix and its inverse {#leontieff-inverse}

The Leontief matrix is derived from Leontief equation system.

(19) $(I-A)x = y$

The Leontief matrix is defined as $(I-A)$ and it is created with the `leontieff_matrix_create()` function.

The Leontief inverse is (I-A)^-1^ and it is created with the `leontieff_inverse_create()` function from the Leontief-matrix.

The code chunk below prints a small part of the Czech Leontief-inverse.

```{r leontieff, results='asis'}
L_cz <- leontieff_matrix_create(input_coeff_matrix_cz)
I_cz <- leontieff_inverse_create(input_coeff_matrix_cz)

L_sk <- leontieff_matrix_create(input_coeff_matrix_sk)
I_sk <- leontieff_inverse_create(input_coeff_matrix_sk)

knitr::kable(head(I_cz[, 1:8]))
```

You can create the Leontief-matrix and its inverse from the output coefficient matrix, too, starting with `output_coefficient_matrix_create()` if you know what you are doing!

## Direct effect indicators

The direct effects can be compared to intermediate production, domestic product or total supply.

>The calculation follows the Eurostat Manual on p497-499

(60)  $a_{ij}$ = $z_{ij}$ / $x_j$  [recap: (43) is the same]

$a_{ij}$ = input coefficient
$z_{ij}$ = input of type i in sector j (i.e. products or capital or labour)
$x_j$ = output of sector j

By default, `direct_supply_effects_create()` will compare inputs to total final demand / supply. You can make comparisons to total product or total output, too. The code below prints a part of the Czech direct effects rounded to 4 digits.

```{r direct, results='asis'}
primary_inputs_cz <- coefficient_matrix_create(
  data_table = cz_io,
  total = "output",
  return = "primary_inputs"
)

primary_inputs_sk <- coefficient_matrix_create(
  data_table = sk_io,
  total = "output",
  return = "primary_inputs"
)

direct_cz <- direct_effects_create(primary_inputs_cz, I_cz)
direct_sk <- direct_effects_create(primary_inputs_sk, I_sk)

knitr::kable(head(direct_cz[, 1:8]), digits = 4)
```

Direct effects measure the initial, direct impact of the change in demand and supply for a product. When production goes up, it will create demand in all supply industries (backward linkages) and create opportunities in the industries that use the product themselves (forward linkages.)

This is not the total effect, because some of the increased production will translate into income, which in turn will be used to create further demand in all parts of the domestic economy. The total effect is characterized by multipliers.

## Total effects {#total-effects}

### Input multipliers
The `input_multipliers_create` function will create the various multipliers for each product.

(63) Z = B(I-A)^-1^

B = vector of input coefficients compared to final demand / supply.

Z = direct and indirect requirements for wages (or other income)

>The calculation follows the Eurostat Manual p 499-502.

The code chunk below prints a part of the Czech multipliers, rounded to 4 digits.

```{r total, results='asis' }
primary_inputs_cz <- coefficient_matrix_create(
  data_table = cz_io,
  total = "output",
  return = "primary_inputs"
)

primary_inputs_sk <- coefficient_matrix_create(
  data_table = sk_io,
  total = "output",
  return = "primary_inputs"
)

multipliers_cz <- input_multipliers_create(primary_inputs_cz, I_cz)
multipliers_sk <- input_multipliers_create(primary_inputs_sk, I_sk)

knitr::kable(head(multipliers_cz[, 1:8]), digits = 4)
```

### Employment indicators and multipliers {#employment-multipliers}

The creation of the employment indicator is facilitated with the data processing function `employment_get`. The employment data as input data is not part of the Eurostat SIOT files, and the Eurostat employment data uses a more disaggregated structure. This function downloads and brings the employment data to conforming aggregate vector.

Other inputs, for example, CO2 emissions may be used, but they are likely to be need a manual aggregation.  The helper function `conforming_vector_create` will create an empty vector that you can save as a .csv or Excel file and fill up manually with customary input data.

```{r employmenteffect, results='asis', message=FALSE}
# New function is needed to add employment vector to SIOT
names(emp_sk)[1] <- "prod_na"
names(emp_cz)[1] <- "prod_na"

emp_indicator_cz <- full_join(
  cz_io,
  emp_cz
) %>%
  coefficient_matrix_create(.,
    return_part = "primary_inputs"
  ) %>%
  filter(prod_na == "employment_total")


emp_effect_cz <- direct_effects_create(emp_indicator_cz, I_cz)

knitr::kable(emp_effect_cz[1:8], digits = 5)
```


```{r employmentindicator, results='asis'}
# New function is needed to add employment vector to SIOT

emp_multiplier_cz <- input_multipliers_create(
  emp_indicator_cz, I_cz
)

knitr::kable(emp_multiplier_cz[1:8], digits = 5)
```


### Output multipliers {#output-multipliers}

```{r output_multipliers, results='asis'}
output_multipliers_cz <- output_multiplier_create(input_coeff_matrix_cz)
output_multipliers_sk <- output_multiplier_create(input_coeff_matrix_sk)

knitr::kable(head(output_multipliers_cz[, 1:8]), digits = 4)
```

## Interindustrial linkage analysis {#interindustrial-linkage-analysis}

## Backward linkages {#backward-linkages}

Backward linkages show the effect on industries that are suppliers to the production (industry) in question.

```{r backward, results='asis'}
cz_bw <- backward_linkages(I_cz)
sk_bw <- backward_linkages(I_sk)

knitr::kable(head(cz_bw[, 1:8]), digits = 4)
```

## Forward linkages {#forward-linkages}

Forward linkages show the effects on other industries that use the product (industry output) at question as an input. Forward linkages can be derived from the ouput coefficient table.

```{r output_coeff, results='asis'}
output_coeff_cz <- output_coefficient_matrix_create(
  data_table = cz_io, total = "TFU", digits = 4
)

output_coeff_sk <- output_coefficient_matrix_create(
  data_table = sk_io, total = "TFU", digits = 4
)

knitr::kable(head(output_coeff_cz[, 1:8]))
```

From the output coefficient matrix we can create the Leontief-matrix for outputs, its inverse, and summarize for forward linkages.  These steps are taking place in the `forward_linkages` function.

```{r forward, results='asis', eval=FALSE}
cz_fw <- forward_linkages(output_coeff_cz)
sk_fw <- forward_linkages(output_coeff_sk)

knitr::kable(head(cz_fw), digits = 4)
```


## Write results into Excel files

This code will not run, unless you run it separately. The resulting files can be used to check calculations in Excel or other application.

The contents of the [not_included](https://github.com/rOpenGov/iotables/tree/master/not_included) directory can be found on GitHub, but they are not released and distributed with the package.


```{r reproduction_data, eval=FALSE }
require(xlsx)
cz_file_name <- file.path("..", "not_included", "CzechRep_test.xlsx")
# Czech Republic data
xlsx::write.xlsx(cz_io,
  file = cz_file_name, sheetName = "io_table",
  col.names = TRUE, row.names = TRUE, append = FALSE
)
xlsx::write.xlsx(cz_output,
  file = cz_file_name, sheetName = "cz_output",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(input_coeff_matrix_cz,
  file = cz_file_name,
  sheetName = "input_coeff_matrix_cz",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(L_cz,
  file = cz_file_name, sheetName = "L_cz",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(I_cz,
  file = cz_file_name, sheetName = "I_cz",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(direct_cz,
  file = cz_file_name,
  sheetName = "direct_cz",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(multipliers_cz,
  file = cz_file_name,
  sheetName = "multipliers_cz",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(emp_effect_cz,
  file = cz_file_name,
  sheetName = "emp_effect_cz_2015",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(emp_indicator_cz,
  file = cz_file_name,
  sheetName = "emp_indicator_cz",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(emp_multiplier_cz,
  file = cz_file_name,
  sheetName = "emp_multiplier_cz",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(cz_bw,
  file = cz_file_name,
  sheetName = "cz_backward_linkages",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(output_coeff_cz,
  file = cz_file_name,
  sheetName = "output_coeff_sk",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(cz_fw,
  file = cz_file_name,
  sheetName = "cz_forward_linkages",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(output_multipliers_cz,
  file = cz_file_name,
  sheetName = "output_multipliers_cz",
  col.names = TRUE, row.names = TRUE, append = TRUE
)


sk_file_name <- file.path("..", "not_included", "SlovakRep_test.xlsx")
# Czech Republic data
xlsx::write.xlsx(sk_io,
  file = sk_file_name, sheetName = "io_table",
  col.names = TRUE, row.names = TRUE, append = FALSE
)
xlsx::write.xlsx(sk_output,
  file = sk_file_name, sheetName = "sk_output",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(input_coeff_matrix_sk,
  file = sk_file_name,
  sheetName = "input_coeff_matrix_sk",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(L_sk,
  file = sk_file_name, sheetName = "L_sk",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(I_sk,
  file = sk_file_name, sheetName = "I_sk",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(direct_sk,
  file = sk_file_name,
  sheetName = "direct_sk",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(multipliers_sk,
  file = sk_file_name,
  sheetName = "multipliers_sk",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(emp_effect_sk,
  file = sk_file_name,
  sheetName = "emp_effect_sk_2015",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(emp_indicator_sk,
  file = sk_file_name,
  sheetName = "emp_indicator_sk",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(emp_multiplier_sk,
  file = sk_file_name,
  sheetName = "employment_multipliers_sk",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(sk_bw,
  file = sk_file_name,
  sheetName = "sk_backward_linkages",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(output_coeff_sk,
  file = sk_file_name,
  sheetName = "output_coeff_sk",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(sk_fw,
  file = sk_file_name,
  sheetName = "sk_forward_linkages",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
xlsx::write.xlsx(output_multipliers_sk,
  file = sk_file_name,
  sheetName = "output_multipliers_sk",
  col.names = TRUE, row.names = TRUE, append = TRUE
)
```
