---
title: "United Kingdom Input-Output Analytical Tables"
author: "Daniel Antal, based on the work edited by Richard Wild"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{United Kingdom Input-Output Analytical Tables}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(dplyr, quietly = TRUE)
library(tidyr, quietly = TRUE)
library(testthat, quietly = TRUE)
```

The [United Kingdom Input-Output Analytical Tables 2010](https://webarchive.nationalarchives.gov.uk/20160114044923/http://www.ons.gov.uk/ons/rel/input-output/input-output-analytical-tables/2010/index.html) are used for testing the `iotables` package, because they are well-documented and detailed, and organised data is available. The analytical tables are published in an Excel table. A special reader function (which is not exported) was created to read-in all sheets of the Excel table. 

It is unlikely these tables will be required for purposes other than validating the package. The UK IO tables for other years are available these are consistent with different Blue Books and there could therefore be important methodological and classification changes. Furthermore, ONS currently publishes ESA2010 compatible SIOTs with analytical tables annually.

```{r read_control_data, eval=FALSE}
uk_2010_data <- iotables_download(source = "uk_2010")
save(uk_2010_data, file = file.path("data-raw", "uk_2010_data.rda"))
uk_test_results <- iotables:::uk_2010_results_get()
# saved as package data
```

For the actual symmetric input-output table (see ) you can use the download function originally designed for the Eurostat bulk downloader. 

```{r downloaded_excel_data, warning=FALSE}
library(iotables)
data(uk_2010_data)
uk_siot <- iotable_get(
  labelled_io_data = uk_2010_data,
  source = "uk_2010_siot"
)
uk_published_coeff <- iotable_get(
  labelled_io_data = uk_2010_data,
  source = "uk_2010_coeff"
)
uk_published_inverse <- iotable_get(
  labelled_io_data = uk_2010_data,
  source = "uk_2010_inverse"
)
```

## Matrix of Coefficients

The matrix of coefficients is described on page 14-15 and the data can be found in the _Matrix of coefficients (product by product) sheet_ of the Excel file. 

```{r compare_coeff}
uk_input_coeff <- input_coefficient_matrix_create(
  data_table = uk_siot)

coeff_comparison <- select(uk_input_coeff, 1) %>%
  left_join(uk_published_coeff, by = "prod_na")

test_that("correct data is returned", {
  expect_equal(
    round(as.numeric(unlist(uk_input_coeff[, 2:8], 8))),
    round(as.numeric(unlist(coeff_comparison[, 2:8], 8)))
  )
})
```

Comparing the first seven columns of the two coefficient matrices are equal to eight decimal places. Given the size of the matrixes, not all columns are compared here, but such a comparison could be performed if needed. However, it is not necessary, because the latter results would show a deviation if parts of the matrix would be different.

## Leontief-inverse

The Leontief-inverse is described on pages 16-17 of the article. Again, comparing the first seven numerical columns we see that the recalculated inverse and the published inverse are identical to eight decimal places.

```{r compare_inverse}
uk_calculated_inverse <- leontief_inverse_create(uk_input_coeff)

inverse_comparison <- select(uk_calculated_inverse, 1) %>%
  left_join(uk_calculated_inverse, by = "prod_na")
```
```{r compare_inverse_2}
test_that("correct data is returned", {
  expect_equal(
    round(uk_calculated_inverse[, 2:8], 8),
    round(inverse_comparison[, 2:8], 8)
  )
})
```

## Employment cost effects

```{r compare_effects}
employment_effect_results <- uk_test_results %>%
  select(uk_row_label, `Employment cost effects`)

primary_inputs_uk <- coefficient_matrix_create(
  data_table  = uk_siot,
  total       = "output",
  return_part = "primary_inputs"
)

employment_input <- filter(primary_inputs_uk, prod_na == "D1")

employment_effects <- direct_effects_create(employment_input, uk_calculated_inverse) %>%
  gather(prod, values, !!2:ncol(.)) %>%
  mutate(prod_na = prod) %>%
  select(-prod) %>%
  left_join(select(metadata_uk_2010, prod_na, uk_row_label),
    by = "prod_na"
  ) %>%
  left_join(employment_effect_results, by = "uk_row_label") %>%
  filter(!is.na(uk_row_label)) %>%
  select(prod_na, uk_row_label, values, `Employment cost effects`)


iotables:::create_knitr_table(
  data_table = employment_effects[1:10, ],
  digits = 4,
  caption = "Comparison of Calculated And Published Employment Cost Effects",
  col.names = c("industry code", "row label", 
                "calculated", "published"),
  col_width = c(2, 11, 3, 3)
)
```


The comparison of output multipliers show that our code gives the same results. Only ten industries are shown.

## GVA effects

GVA is not shown in the Excel table explicitly, but can be calculated as the sum of corporate income (*Operating surplus and mixed income*), household income (*Compensation of employees*) and net taxes on production (not products.)

```{r gva_effects}
# --- 1. Add GVA row using primary incomes

uk_siot2 <- uk_siot %>%
  filter(prod_na %in% c("B2A3G", "D1", "D29X39")) %>%
  summarise(across(where(is.numeric), 
                   ~ sum(.x, na.rm = TRUE))) %>%
  mutate(prod_na = "GVA") %>%
  bind_rows(uk_siot, .)


# --- 2. Published GVA effects (from results table) 

gva_effect_results <- uk_test_results %>%
  select(uk_row_label, `GVA effects`)

# --- 3. Extract GVA row from primary input coefficients

gva_input <- coefficient_matrix_create(
  data_table  = uk_siot2,
  total       = "output",
  return_part = "primary_inputs"
) %>%
  filter(prod_na == "GVA")


# --- 4. Direct GVA effects calculation 

gva_effects <- direct_effects_create(
  gva_input,
  uk_calculated_inverse
) %>%
  # previously gather(prod, values, 2:ncol(.))
  pivot_longer(
    cols = -prod_na,
    names_to = "prod",
    values_to = "values"
  ) %>%
  mutate(prod_na = prod) %>%
  select(-prod) %>%
  left_join(
    metadata_uk_2010 %>% select(prod_na, uk_row_label),
    by = "prod_na"
  ) %>%
  left_join(gva_effect_results, by = "uk_row_label") %>%
  filter(!is.na(uk_row_label)) %>%
  select(prod_na, uk_row_label, values, `GVA effects`)


# --- 5. Output the knitr table

iotables:::create_knitr_table(
  data_table = gva_effects[1:10, ],
  digits = 4,
  caption = "Comparison of Calculated And Published GVA Effects",
  col.names = c("industry code", "row label", "calculated", "published"),
  col_width = c(2, 11, 3, 3)
)

```

## Employment cost multipliers

Turning to multipliers, using the same inputs we get them back with the following code.

```{r compare_emp_multipliers}
empc_multiplier_results <- uk_test_results %>%
  select(uk_row_label, `Employment cost multiplier`)

empc_indicator_uk <- coefficient_matrix_create(
  data_table  = uk_siot,
  total       = "output",
  return_part = "primary_inputs"
) 

empc_multipliers <- input_multipliers_create(
  Im = uk_calculated_inverse,
  input_requirements = empc_indicator_uk, 
  multiplier_name = "Employment cost multiplier"
) %>%
  pivot_longer(
    cols = -prod_na,
    names_to = "prod",
    values_to = "values"
  ) %>% 
  mutate(prod_na = prod) %>%
  select(-prod) %>%
  left_join(select(metadata_uk_2010, prod_na, uk_row_label),
    by = "prod_na"
  ) %>%
  left_join(empc_multiplier_results, by = "uk_row_label") %>%
  filter(!is.na(uk_row_label)) %>%
  select(prod_na, uk_row_label, values, `Employment cost multiplier`)

iotables:::create_knitr_table(
  data_table = empc_multipliers[1:10, ], digits = 4,
  caption = "Comparison of Calculated And Published Employment Cost Multipliers",
  col.names = c("industry code", "row label", "calculated", "published"),
  col_width = c(2, 11, 3, 3)
)
```

## GVA multipliers

Following from the GVA effects, after summarizing GVA and adding it to the input requirements we can calculate the `GVA multipliers`.

```{r gva_comp, eval=FALSE}
gva_multipliers <- input_multipliers_create(
  Im = uk_calculated_inverse, 
  input_requirements = gva_input
) %>%
  pivot_longer(
    cols = -prod_na,
    names_to = "prod",
    values_to = "values"
  ) %>%
  mutate(prod_na = prod) %>%
  select(-prod) %>%
  left_join(select(metadata_uk_2010, prod_na, uk_row_label),
    by = "prod_na"
  ) %>%
  left_join(gva_multiplier_results, by = "uk_row_label") %>%
  filter(!is.na(uk_row_label)) %>%
  select(prod_na, uk_row_label, values, `GVA multiplier`)

iotables:::create_knitr_table(
  data_table = gva_multipliers[1:10, ],
  digits = 4,
  caption = "Comparison of Calculated And Published GVA Multipliers",
  col.names = c(
    "industry code", "row label",
    "calculated", "published"
  ),
  col_width = c(2, 11, 3, 3)
)
```


## Output multipliers

At last, the comparison of output multipliers show that our code gives the same results. Only ten industries are shown.

```{r compare_output_multipliers}
output_multiplier_results <- uk_test_results %>%
  select(uk_row_label, `Output multiplier`)

uk_output_multipliers <- output_multiplier_create(uk_input_coeff) %>%
  pivot_longer(
    cols = -prod_na,
    names_to = "prod",
    values_to = "values"
  ) %>%
  mutate(prod_na = prod) %>%
  select(-prod) %>%
  left_join(select(metadata_uk_2010, prod_na, uk_row_label),
    by = "prod_na"
  ) %>%
  left_join(output_multiplier_results,
    by = "uk_row_label"
  ) %>%
  filter(!is.na(uk_row_label)) %>%
  select(prod_na, uk_row_label, values, `Output multiplier`)

iotables:::create_knitr_table(
  data_table = uk_output_multipliers[1:10, ],
  digits = 4,
  caption = "Comparison of Calculated And Published Output Multipliers",
  col.names = c(
    "industry code", "row label",
    "calculated", "published"
  ),
  col_width = c(2, 11, 3, 3)
)
```

